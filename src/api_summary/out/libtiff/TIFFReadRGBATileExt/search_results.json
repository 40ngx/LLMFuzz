{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "file:\\.(c|cpp|cc)$ lang:c++ count:all TIFFReadRGBATileExt",
  "Site": {
    "BuildVersion": "316984_2025-03-18_6.1-1f1695fa27f5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "c15ace4a9bb90693e1e9aaa55969b51859ec2633"
        },
        "content": "#include \"FDSan.h\"\n#include \u003ctiffio.hxx\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdint.h\u003e\n#include \u003cvector\u003e\n#include \u003cfstream\u003e\n#include \u003ciostream\u003e\n#include \u003csstream\u003e\n//\u003cID\u003e 520\n//\u003cPrompt\u003e [\"TIFFCurrentRow\",\"TIFFDefaultTileSize\",\"TIFFReadRGBATile\",\"TIFFCurrentTile\",\"TIFFFileno\",\"TIFFGetSeekProc\"]\n/*\u003cCombination\u003e: [uint32_t TIFFCurrentRow(TIFF * ),\n    void TIFFDefaultTileSize(TIFF * , uint32_t * , uint32_t * ),\n    int TIFFReadRGBATile(TIFF * , uint32_t , uint32_t , uint32_t * ),\n    uint32_t TIFFCurrentTile(TIFF * tif),\n    int TIFFFileno(TIFF * ),\n    TIFFSeekProc TIFFGetSeekProc(TIFF * )\n*/\n//\u003cscore\u003e 10, nr_unique_branch: 34\n//\u003cQuality\u003e {\"density\":8,\"unique_branches\":{\"_TIFFReadTileAndAllocBuffer\":[[986,35,986,66,0,0,4,0]],\"gtTileSeparate\":[[883,9,883,31,0,0,4,0],[885,13,885,31,0,0,4,1],[1017,15,1017,39,0,0,4,0],[1020,9,1020,33,0,0,4,0],[1024,24,1024,32,0,0,4,0],[1024,24,1024,32,0,0,4,1],[1029,20,1029,32,0,0,4,1]],\"gtTileContig\":[[740,9,740,31,0,0,4,0],[742,13,742,31,0,0,4,1],[813,15,813,39,0,0,4,0],[817,9,817,33,0,0,4,0],[821,24,821,32,0,0,4,0],[821,24,821,32,0,0,4,1],[826,20,826,32,0,0,4,1]],\"TIFFReadRGBATileExt\":[[3276,9,3276,26,0,0,4,0],[3276,9,3276,26,0,0,4,1],[3285,9,3285,32,0,0,4,0],[3285,9,3285,32,0,0,4,1],[3285,36,3285,59,0,0,4,0],[3285,36,3285,59,0,0,4,1],[3297,9,3297,36,0,0,4,1],[3298,9,3298,60,0,0,4,0],[3298,9,3298,60,0,0,4,1],[3311,9,3311,38,0,0,4,0],[3311,9,3311,38,0,0,4,1],[3316,9,3316,37,0,0,4,1],[3340,9,3340,33,0,0,4,0],[3340,37,3340,61,0,0,4,0],[3340,37,3340,61,0,0,4,1],[3343,21,3343,39,0,0,4,0],[3343,21,3343,39,0,0,4,1],[3353,30,3353,48,0,0,4,0],[3353,30,3353,48,0,0,4,1]]},\"library_calls\":[\"TIFFStreamOpen\",\"TIFFCurrentRow\",\"TIFFDefaultTileSize\",\"TIFFCurrentTile\",\"TIFFReadRGBATile\",\"TIFFFileno\",\"TIFFGetSeekProc\",\"TIFFClose\"],\"critical_calls\":[\"TIFFStreamOpen\",\"TIFFCurrentRow\",\"TIFFDefaultTileSize\",\"TIFFCurrentTile\",\"TIFFReadRGBATile\",\"TIFFFileno\",\"TIFFGetSeekProc\",\"TIFFClose\"],\"visited\":3}\n/*Here is the complete implementation of the fuzz driver based on the provided instructions:\n\n*/\n\n\nextern \"C\" int LLVMFuzzerTestOneInput_34(const uint8_t* data, size_t size) {\n\tif(size\u003c0) return 0;\n\n\tFILE *input_file_ptr = fopen(\"input_file\", \"wb\");\n\tif (input_file_ptr == NULL) {return 0;}\n\tfwrite(data, sizeof(uint8_t), size, input_file_ptr);\n\tfclose(input_file_ptr);\n\n    // Write data into input_file.\n    FILE* in_file = fopen(\"input_file\", \"wb\");\n    if (in_file == nullptr) {\n        assert_file_closed(\u0026in_file);\n\treturn 0;\n    }\n    fwrite(data, sizeof(uint8_t), size, in_file);\n    assert_file_closed(\u0026in_file);;\n\n    // Open input tiff in memory\n    std::istringstream s(std::string(data, data + size));\n    TIFF* in_tif = TIFFStreamOpen(\"MemTIFF\", \u0026s);\n    if (!in_tif) {\n        assert_file_closed(\u0026in_file);\n\treturn 0;\n    }\n\n    // 1. Call the APIs to achieve the event\n    uint32_t currentRow = TIFFCurrentRow(in_tif);\n    uint32_t tileSizeX, tileSizeY;\n    TIFFDefaultTileSize(in_tif, \u0026tileSizeX, \u0026tileSizeY);\n    uint32_t currentTile = TIFFCurrentTile(in_tif);\n    uint32_t* rgbaTile = new uint32_t[tileSizeX * tileSizeY];\n    int readRGBATile = TIFFReadRGBATile(in_tif, currentTile, currentRow, rgbaTile);\n    int fileNo = TIFFFileno(in_tif);\n    TIFFSeekProc seekProc = TIFFGetSeekProc(in_tif);\n\n    // 2. Use the results of the APIs if necessary\n    // ...\n\n    // 3. Consume the input data and size if needed\n    // ...\n\n    // 4. Release resources\n    TIFFClose(in_tif);\n    delete[] rgbaTile;\n\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n}",
        "name": "id_000034.cc",
        "path": "examples/libtiff/fuzzer_0/fuzzers/id_000034.cc",
        "url": "/github.com/PromptFuzz/PromptFuzz/-/blob/examples/libtiff/fuzzer_0/fuzzers/id_000034.cc"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              479,
              19
            ]
          ],
          "preview": "//\u003cQuality\u003e {\"density\":8,\"unique_branches\":{\"_TIFFReadTileAndAllocBuffer\":[[986,35,986,66,0,0,4,0]],\"gtTileSeparate\":[[883,9,883,31,0,0,4,0],[885,13,885,31,0,0,4,1],[1017,15,1017,39,0,0,4,0],[1020,9,1020,33,0,0,4,0],[1024,24,1024,32,0,0,4,0],[1024,24,1024,32,0,0,4,1],[1029,20,1029,32,0,0,4,1]],\"gtTileContig\":[[740,9,740,31,0,0,4,0],[742,13,742,31,0,0,4,1],[813,15,813,39,0,0,4,0],[817,9,817,33,0,0,4,0],[821,24,821,32,0,0,4,0],[821,24,821,32,0,0,4,1],[826,20,826,32,0,0,4,1]],\"TIFFReadRGBATileExt\":[[3276,9,3276,26,0,0,4,0],[3276,9,3276,26,0,0,4,1],[3285,9,3285,32,0,0,4,0],[3285,9,3285,32,0,0,4,1],[3285,36,3285,59,0,0,4,0],[3285,36,3285,59,0,0,4,1],[3297,9,3297,36,0,0,4,1],[3298,9,3298,60,0,0,4,0],[3298,9,3298,60,0,0,4,1],[3311,9,3311,38,0,0,4,0],[3311,9,3311,38,0,0,4,1],[3316,9,3316,37,0,0,4,1],[3340,9,3340,33,0,0,4,0],[3340,37,3340,61,0,0,4,0],[3340,37,3340,61,0,0,4,1],[3343,21,3343,39,0,0,4,0],[3343,21,3343,39,0,0,4,1],[3353,30,3353,48,0,0,4,0],[3353,30,3353,48,0,0,4,1]]},\"library_calls\":[\"TIFFStreamOpen\",\"TIFFCurrentRow\",\"TIFFDefaultTileSize\",\"TIFFCurrentTile\",\"TIFFReadRGBATile\",\"TIFFFileno\",\"TIFFGetSeekProc\",\"TIFFClose\"],\"critical_calls\":[\"TIFFStreamOpen\",\"TIFFCurrentRow\",\"TIFFDefaultTileSize\",\"TIFFCurrentTile\",\"TIFFReadRGBATile\",\"TIFFFileno\",\"TIFFGetSeekProc\",\"TIFFClose\"],\"visited\":3}"
        }
      ],
      "repository": {
        "name": "github.com/PromptFuzz/PromptFuzz",
        "url": "/github.com/PromptFuzz/PromptFuzz"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "c15ace4a9bb90693e1e9aaa55969b51859ec2633"
        },
        "content": "#include \"FDSan.h\"\n#include \"FuzzedDataProvider.h\"\n#include \u003ctiffio.hxx\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdint.h\u003e\n#include \u003cvector\u003e\n#include \u003cfstream\u003e\n#include \u003ciostream\u003e\n#include \u003csstream\u003e\n//\u003cID\u003e 520\n//\u003cPrompt\u003e [\"TIFFCurrentRow\",\"TIFFDefaultTileSize\",\"TIFFReadRGBATile\",\"TIFFCurrentTile\",\"TIFFFileno\",\"TIFFGetSeekProc\"]\n/*\u003cCombination\u003e: [uint32_t TIFFCurrentRow(TIFF * ),\n    void TIFFDefaultTileSize(TIFF * , uint32_t * , uint32_t * ),\n    int TIFFReadRGBATile(TIFF * , uint32_t , uint32_t , uint32_t * ),\n    uint32_t TIFFCurrentTile(TIFF * tif),\n    int TIFFFileno(TIFF * ),\n    TIFFSeekProc TIFFGetSeekProc(TIFF * )\n*/\n//\u003cscore\u003e 10, nr_unique_branch: 34\n//\u003cQuality\u003e {\"density\":8,\"unique_branches\":{\"_TIFFReadTileAndAllocBuffer\":[[986,35,986,66,0,0,4,0]],\"gtTileSeparate\":[[883,9,883,31,0,0,4,0],[885,13,885,31,0,0,4,1],[1017,15,1017,39,0,0,4,0],[1020,9,1020,33,0,0,4,0],[1024,24,1024,32,0,0,4,0],[1024,24,1024,32,0,0,4,1],[1029,20,1029,32,0,0,4,1]],\"gtTileContig\":[[740,9,740,31,0,0,4,0],[742,13,742,31,0,0,4,1],[813,15,813,39,0,0,4,0],[817,9,817,33,0,0,4,0],[821,24,821,32,0,0,4,0],[821,24,821,32,0,0,4,1],[826,20,826,32,0,0,4,1]],\"TIFFReadRGBATileExt\":[[3276,9,3276,26,0,0,4,0],[3276,9,3276,26,0,0,4,1],[3285,9,3285,32,0,0,4,0],[3285,9,3285,32,0,0,4,1],[3285,36,3285,59,0,0,4,0],[3285,36,3285,59,0,0,4,1],[3297,9,3297,36,0,0,4,1],[3298,9,3298,60,0,0,4,0],[3298,9,3298,60,0,0,4,1],[3311,9,3311,38,0,0,4,0],[3311,9,3311,38,0,0,4,1],[3316,9,3316,37,0,0,4,1],[3340,9,3340,33,0,0,4,0],[3340,37,3340,61,0,0,4,0],[3340,37,3340,61,0,0,4,1],[3343,21,3343,39,0,0,4,0],[3343,21,3343,39,0,0,4,1],[3353,30,3353,48,0,0,4,0],[3353,30,3353,48,0,0,4,1]]},\"library_calls\":[\"TIFFStreamOpen\",\"TIFFCurrentRow\",\"TIFFDefaultTileSize\",\"TIFFCurrentTile\",\"TIFFReadRGBATile\",\"TIFFFileno\",\"TIFFGetSeekProc\",\"TIFFClose\"],\"critical_calls\":[\"TIFFStreamOpen\",\"TIFFCurrentRow\",\"TIFFDefaultTileSize\",\"TIFFCurrentTile\",\"TIFFReadRGBATile\",\"TIFFFileno\",\"TIFFGetSeekProc\",\"TIFFClose\"],\"visited\":3}\n/*Here is the complete implementation of the fuzz driver based on the provided instructions:\n\n*/\n\n\nextern \"C\" int LLVMFuzzerTestOneInput_34(const uint8_t* f_data, size_t f_size) {\n\tif(f_size\u003c10) return 0;\n\n\t\n\t//fuzzer vars shim {\n\t\tFuzzedDataProvider fdp(f_data, f_size);\n\t\tFDPConsumeRawBytes(const uint8_t *, data, size, fdp)\n\t\tFDPConsumeRandomLengthString(char, fuzz_str_1, fuzz_str_sz_1, fdp);\n\t//fuzzer shim end}\n\n\n\n\n    // Write data into input_file.\n    FILE* in_file = fopen(\"input_file\", \"wb\");\n    if (in_file == nullptr) {\n        assert_file_closed(\u0026in_file);\n\treturn 0;\n    }\n    fwrite(data, sizeof(uint8_t), size, in_file);\n    assert_file_closed(\u0026in_file);;\n\n    // Open input tiff in memory\n    std::istringstream s(std::string(data, data + size));\n    TIFF* in_tif = TIFFStreamOpen(fuzz_str_1, \u0026s);\n    if (!in_tif) {\n        assert_file_closed(\u0026in_file);\n\treturn 0;\n    }\n\n    // 1. Call the APIs to achieve the event\n    uint32_t currentRow = TIFFCurrentRow(in_tif);\n    uint32_t tileSizeX, tileSizeY;\n    TIFFDefaultTileSize(in_tif, \u0026tileSizeX, \u0026tileSizeY);\n    uint32_t currentTile = TIFFCurrentTile(in_tif);\n    uint32_t* rgbaTile = new uint32_t[tileSizeX * tileSizeY];\n    int readRGBATile = TIFFReadRGBATile(in_tif, currentTile, currentRow, rgbaTile);\n    int fileNo = TIFFFileno(in_tif);\n    TIFFSeekProc seekProc = TIFFGetSeekProc(in_tif);\n\n    // 2. Use the results of the APIs if necessary\n    // ...\n\n    // 3. Consume the input data and size if needed\n    // ...\n\n    // 4. Release resources\n    TIFFClose(in_tif);\n    delete[] rgbaTile;\n\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n}",
        "name": "id_000034.cc",
        "path": "examples/libtiff/fuzzer_1/fuzzers/id_000034.cc",
        "url": "/github.com/PromptFuzz/PromptFuzz/-/blob/examples/libtiff/fuzzer_1/fuzzers/id_000034.cc"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              479,
              19
            ]
          ],
          "preview": "//\u003cQuality\u003e {\"density\":8,\"unique_branches\":{\"_TIFFReadTileAndAllocBuffer\":[[986,35,986,66,0,0,4,0]],\"gtTileSeparate\":[[883,9,883,31,0,0,4,0],[885,13,885,31,0,0,4,1],[1017,15,1017,39,0,0,4,0],[1020,9,1020,33,0,0,4,0],[1024,24,1024,32,0,0,4,0],[1024,24,1024,32,0,0,4,1],[1029,20,1029,32,0,0,4,1]],\"gtTileContig\":[[740,9,740,31,0,0,4,0],[742,13,742,31,0,0,4,1],[813,15,813,39,0,0,4,0],[817,9,817,33,0,0,4,0],[821,24,821,32,0,0,4,0],[821,24,821,32,0,0,4,1],[826,20,826,32,0,0,4,1]],\"TIFFReadRGBATileExt\":[[3276,9,3276,26,0,0,4,0],[3276,9,3276,26,0,0,4,1],[3285,9,3285,32,0,0,4,0],[3285,9,3285,32,0,0,4,1],[3285,36,3285,59,0,0,4,0],[3285,36,3285,59,0,0,4,1],[3297,9,3297,36,0,0,4,1],[3298,9,3298,60,0,0,4,0],[3298,9,3298,60,0,0,4,1],[3311,9,3311,38,0,0,4,0],[3311,9,3311,38,0,0,4,1],[3316,9,3316,37,0,0,4,1],[3340,9,3340,33,0,0,4,0],[3340,37,3340,61,0,0,4,0],[3340,37,3340,61,0,0,4,1],[3343,21,3343,39,0,0,4,0],[3343,21,3343,39,0,0,4,1],[3353,30,3353,48,0,0,4,0],[3353,30,3353,48,0,0,4,1]]},\"library_calls\":[\"TIFFStreamOpen\",\"TIFFCurrentRow\",\"TIFFDefaultTileSize\",\"TIFFCurrentTile\",\"TIFFReadRGBATile\",\"TIFFFileno\",\"TIFFGetSeekProc\",\"TIFFClose\"],\"critical_calls\":[\"TIFFStreamOpen\",\"TIFFCurrentRow\",\"TIFFDefaultTileSize\",\"TIFFCurrentTile\",\"TIFFReadRGBATile\",\"TIFFFileno\",\"TIFFGetSeekProc\",\"TIFFClose\"],\"visited\":3}"
        }
      ],
      "repository": {
        "name": "github.com/PromptFuzz/PromptFuzz",
        "url": "/github.com/PromptFuzz/PromptFuzz"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "c83e7858a9ec566cc91d65db74fd07b99789c0f0"
        },
        "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam \u003cwarmerdam@pobox.com\u003e\n * Copyright (c) 2007-2015, Even Rouault \u003ceven dot rouault at spatialys dot com\u003e\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n// If we use sunpro compiler on linux. Weird idea indeed!\n#if defined(__SUNPRO_CC) \u0026\u0026 defined(__linux__)\n#define _GNU_SOURCE\n#elif defined(__GNUC__) \u0026\u0026 !defined(_GNU_SOURCE)\n// Required to use RTLD_DEFAULT of dlfcn.h.\n#define _GNU_SOURCE\n#endif\n\n#include \"cpl_port.h\"  // Must be first.\n#include \"gtiff.h\"\n\n#include \u003ccassert\u003e\n#include \u003ccerrno\u003e\n#include \u003cclimits\u003e\n#include \u003ccmath\u003e\n#include \u003ccstdarg\u003e\n#include \u003ccstddef\u003e\n#include \u003ccstdio\u003e\n#include \u003ccstdlib\u003e\n#include \u003ccstring\u003e\n#if HAVE_FCNTL_H\n#include \u003cfcntl.h\u003e\n#endif\n#if HAVE_SYS_STAT_H\n#  include \u003csys/stat.h\u003e\n#endif\n\n#include \u003calgorithm\u003e\n#include \u003cmemory\u003e\n#include \u003cmutex\u003e\n#include \u003cset\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\n#include \"cpl_config.h\"\n#include \"cpl_conv.h\"\n#include \"cpl_csv.h\"\n#include \"cpl_error.h\"\n#include \"cpl_minixml.h\"\n#include \"cpl_multiproc.h\"\n#include \"cpl_port.h\"\n#include \"cpl_progress.h\"\n#include \"cpl_string.h\"\n#include \"cpl_virtualmem.h\"\n#include \"cpl_vsi.h\"\n#include \"cpl_vsi_virtual.h\"\n#include \"cpl_worker_thread_pool.h\"\n#include \"cplkeywordparser.h\"\n#include \"gdal.h\"\n#include \"gdal_csv.h\"\n#include \"gdal_frmts.h\"\n#include \"gdal_mdreader.h\"\n#include \"gdal_pam.h\"\n#include \"gdal_priv.h\"\n#include \"gdal_priv_templates.hpp\"\n#include \"geo_normalize.h\"\n#include \"geotiff.h\"\n#include \"geovalues.h\"\n#include \"gt_jpeg_copy.h\"\n#include \"gt_overview.h\"\n#include \"gt_wkt_srs.h\"\n#include \"gt_wkt_srs_priv.h\"\n#include \"ogr_spatialref.h\"\n#include \"tiff.h\"\n#include \"tif_float.h\"\n#include \"tiffio.h\"\n#ifdef INTERNAL_LIBTIFF\n#  include \"tiffiop.h\"\n#  include \"tif_lerc.h\"\n#    ifdef WEBP_SUPPORT\n#      include \"webp/encode.h\"\n#    endif\n#endif\n#include \"tiffvers.h\"\n#include \"tifvsi.h\"\n#include \"xtiffio.h\"\n\n\nCPL_CVSID(\"$Id: geotiff.cpp 327f91335ae848e9c94bac0c8451522410e5064e 2019-09-11 00:45:29 +0200 Even Rouault $\")\n\nstatic bool bGlobalInExternalOvr = false;\nstatic std::mutex gMutexThreadPool;\nCPLWorkerThreadPool *gpoCompressThreadPool = nullptr;\n\n// Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if TIFFLIB_VERSION \u003e= 20120922\n#define SUPPORTS_MORE_THAN_32768_DIRECTORIES\n#endif\n\nconst char* const szJPEGGTiffDatasetTmpPrefix = \"/vsimem/gtiffdataset_jpg_tmp_\";\n\ntypedef enum\n{\n    GTIFFTAGTYPE_STRING,\n    GTIFFTAGTYPE_SHORT,\n    GTIFFTAGTYPE_FLOAT,\n    GTIFFTAGTYPE_BYTE_STRING\n} GTIFFTagTypes;\n\ntypedef struct\n{\n    const char    *pszTagName;\n    int            nTagVal;\n    GTIFFTagTypes  eType;\n} GTIFFTags;\n\nstatic const GTIFFTags asTIFFTags[] =\n{\n    { \"TIFFTAG_DOCUMENTNAME\", TIFFTAG_DOCUMENTNAME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_IMAGEDESCRIPTION\", TIFFTAG_IMAGEDESCRIPTION,\n        GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_SOFTWARE\", TIFFTAG_SOFTWARE, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_DATETIME\", TIFFTAG_DATETIME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_ARTIST\", TIFFTAG_ARTIST, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_HOSTCOMPUTER\", TIFFTAG_HOSTCOMPUTER, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_COPYRIGHT\", TIFFTAG_COPYRIGHT, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_XRESOLUTION\", TIFFTAG_XRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    { \"TIFFTAG_YRESOLUTION\", TIFFTAG_YRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    // Dealt as special case.\n    { \"TIFFTAG_RESOLUTIONUNIT\", TIFFTAG_RESOLUTIONUNIT, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MINSAMPLEVALUE\", TIFFTAG_MINSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MAXSAMPLEVALUE\", TIFFTAG_MAXSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n\n    // GeoTIFF DGIWG tags\n    { \"GEO_METADATA\", TIFFTAG_GEO_METADATA, GTIFFTAGTYPE_BYTE_STRING },\n    { \"TIFF_RSID\", TIFFTAG_TIFF_RSID, GTIFFTAGTYPE_STRING },\n};\n\nconst char szPROFILE_BASELINE[] = \"BASELINE\";\nconst char szPROFILE_GeoTIFF[] = \"GeoTIFF\";\nconst char szPROFILE_GDALGeoTIFF[] = \"GDALGeoTIFF\";\n\n/************************************************************************/\n/*                          GTIFFSetInExternalOvr()                     */\n/************************************************************************/\n\nvoid GTIFFSetInExternalOvr( bool b )\n{\n    bGlobalInExternalOvr = b;\n}\n\n/************************************************************************/\n/*                     GTIFFGetOverviewBlockSize()                      */\n/************************************************************************/\n\nvoid GTIFFGetOverviewBlockSize( int* pnBlockXSize, int* pnBlockYSize )\n{\n    const char* pszVal = CPLGetConfigOption(\"GDAL_TIFF_OVR_BLOCKSIZE\", \"128\");\n    int nOvrBlockSize = atoi(pszVal);\n    if( nOvrBlockSize \u003c 64 || nOvrBlockSize \u003e 4096 ||\n        !CPLIsPowerOfTwo(nOvrBlockSize) )\n    {\n        static bool bHasWarned = false;\n        if( !bHasWarned )\n        {\n            CPLError( CE_Warning, CPLE_NotSupported,\n                      \"Wrong value for GDAL_TIFF_OVR_BLOCKSIZE : %s. \"\n                      \"Should be a power of 2 between 64 and 4096. \"\n                      \"Defaulting to 128\",\n                      pszVal );\n            bHasWarned = true;\n        }\n        nOvrBlockSize = 128;\n    }\n\n    *pnBlockXSize = nOvrBlockSize;\n    *pnBlockYSize = nOvrBlockSize;\n}\n\nenum\n{\n    ENDIANNESS_NATIVE,\n    ENDIANNESS_LITTLE,\n    ENDIANNESS_BIG\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffDataset                                */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand;\nclass GTiffDataset;\nclass GTiffJPEGOverviewBand;\nclass GTiffJPEGOverviewDS;\nclass GTiffRasterBand;\nclass GTiffRGBABand;\n\ntypedef enum\n{\n    VIRTUAL_MEM_IO_NO,\n    VIRTUAL_MEM_IO_YES,\n    VIRTUAL_MEM_IO_IF_ENOUGH_RAM\n} VirtualMemIOEnum;\n\n#if !defined(__MINGW32__)\nnamespace {\n#endif\ntypedef struct\n{\n    GTiffDataset *poDS;\n    bool          bTIFFIsBigEndian;\n    char         *pszTmpFilename;\n    int           nHeight;\n    uint16        nPredictor;\n    GByte        *pabyBuffer;\n    int           nBufferSize;\n    int           nStripOrTile;\n\n    GByte        *pabyCompressedBuffer;  // Owned by pszTmpFilename.\n    int           nCompressedBufferSize;\n    bool          bReady;\n} GTiffCompressionJob;\n#if !defined(__MINGW32__)\n}\n#endif\n\nclass GTiffDataset final : public GDALPamDataset\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffDataset)\n\n    friend class GTiffBitmapBand;\n    friend class GTiffJPEGOverviewDS;\n    friend class GTiffJPEGOverviewBand;\n    friend class GTiffOddBitsBand;\n    friend class GTiffRasterBand;\n    friend class GTiffRGBABand;\n    friend class GTiffSplitBand;\n    friend class GTiffSplitBitmapBand;\n\n    friend void  GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality );\n    friend void  GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode );\n\n    TIFF       *hTIFF;\n    VSILFILE   *fpL;\n#if defined(INTERNAL_LIBTIFF) \u0026\u0026 defined(DEFER_STRILE_LOAD)\n    uint32      nStripArrayAlloc;\n    vsi_l_offset m_nFileSize; // 0 when unknown, only valid in GA_ReadOnly mode\n#endif\n\n    bool        bStreamingIn;\n\n    bool        bStreamingOut;\n    CPLString   osTmpFilename{};\n    VSILFILE*   fpToWrite;\n    int         nLastWrittenBlockId;\n\n    GTiffDataset **ppoActiveDSRef;\n    GTiffDataset *poActiveDS;  // Only used in actual base.\n\n    bool        bScanDeferred;\n    void        ScanDirectories();\n\n    toff_t      nDirOffset;\n    bool        bBase;\n    // Useful for closing TIFF handle opened by GTIFF_DIR:\n    bool        bCloseTIFFHandle;\n\n    uint16      nPlanarConfig;\n    uint16      nSamplesPerPixel;\n    uint16      nBitsPerSample;\n    uint32      nRowsPerStrip;\n    uint16      nPhotometric;\n    uint16      nSampleFormat;\n    uint16      nCompression;\n\n    int         nBlocksPerBand;\n\n    int         nBlockXSize;\n    int         nBlockYSize;\n\n    int         nLoadedBlock;  // Or tile.\n    bool        bLoadedBlockDirty;\n    GByte       *pabyBlockBuf;\n\n    CPLErr      LoadBlockBuf( int nBlockId, bool bReadFromDisk = true );\n    CPLErr      FlushBlockBuf();\n    bool        bWriteErrorInFlushBlockBuf;\n\n    char        *pszProjection;\n    CPLString   m_osVertUnit{};\n    bool        bLookedForProjection;\n    bool        bLookedForMDAreaOrPoint;\n\n    void        LoadMDAreaOrPoint();\n    void        LookForProjection();\n#ifdef ESRI_BUILD\n    void        AdjustLinearUnit( short UOMLength );\n#endif\n\n    double      adfGeoTransform[6];\n    bool        bGeoTransformValid;\n\n    bool        bTreatAsRGBA;\n    bool        bCrystalized;\n\n    void        Crystalize();  // TODO: Spelling.\n    void        RestoreVolatileParameters(TIFF* l_hTIFF);\n\n    GDALColorTable *poColorTable;\n\n    void        WriteGeoTIFFInfo();\n    bool        SetDirectory( toff_t nDirOffset = 0 );\n\n    int         nOverviewCount;\n    GTiffDataset **papoOverviewDS;\n\n    // If \u003e 0, the implicit JPEG overviews are visible through\n    // GetOverviewCount().\n    int         nJPEGOverviewVisibilityCounter;\n    // Currently visible overviews. Generally == nJPEGOverviewCountOri.\n    int         nJPEGOverviewCount;\n    int         nJPEGOverviewCountOri;  // Size of papoJPEGOverviewDS.\n    GTiffJPEGOverviewDS **papoJPEGOverviewDS;\n    int         GetJPEGOverviewCount();\n\n    int         nGCPCount;\n    GDAL_GCP    *pasGCPList;\n\n    bool        IsBlockAvailable( int nBlockId,\n                                  vsi_l_offset* pnOffset = nullptr,\n                                  vsi_l_offset* pnSize = nullptr,\n                                  bool *pbErrOccurred = nullptr );\n\n    bool        bGeoTIFFInfoChanged;\n    bool        bForceUnsetGTOrGCPs;\n    bool        bForceUnsetProjection;\n\n    bool        bNoDataChanged;\n    bool        bNoDataSet;\n    double      dfNoDataValue;\n\n    bool        bMetadataChanged;\n    bool        bColorProfileMetadataChanged;\n    bool        m_bForceUnsetRPC = false;\n\n    bool        bNeedsRewrite;\n\n    void        ApplyPamInfo();\n    void        PushMetadataToPam();\n\n    GDALMultiDomainMetadata oGTiffMDMD{};\n\n    CPLString   osProfile{};\n    char      **papszCreationOptions;\n\n    bool        bLoadingOtherBands;\n\n    void*        pabyTempWriteBuffer;\n    int          nTempWriteBufferSize;\n    bool         WriteEncodedTile( uint32 tile, GByte* pabyData,\n                                   int bPreserveDataBuffer );\n    bool         WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                    int bPreserveDataBuffer );\n    template\u003cclass T\u003e\n    bool         HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents ) const;\n    bool         HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents );\n    inline bool  IsFirstPixelEqualToNoData( const void* pBuffer );\n\n    GTiffDataset* poMaskDS;\n    GTiffDataset* poBaseDS;\n    bool          bIsOverview_ = false;\n\n    CPLString    osFilename{};\n\n    bool         bWriteEmptyTiles;\n    bool         bFillEmptyTilesAtClosing;\n    void         FillEmptyTiles();\n\n    void         FlushDirectory();\n    CPLErr       CleanOverviews();\n\n    // Used for the all-in-on-strip case.\n    int           nLastLineRead;\n    int           nLastBandRead;\n    bool          bTreatAsSplit;\n    bool          bTreatAsSplitBitmap;\n\n    bool          bClipWarn;\n\n    bool          bIMDRPCMetadataLoaded;\n    char**        papszMetadataFiles;\n    void          LoadMetadata();\n\n    bool          bEXIFMetadataLoaded;\n    void          LoadEXIFMetadata();\n\n    bool          bICCMetadataLoaded;\n    void          LoadICCProfile();\n\n    bool          bHasWarnedDisableAggressiveBandCaching;\n\n    bool          bDontReloadFirstBlock;  // Hack for libtiff 3.X and #3633.\n\n    int           nZLevel;\n    int           nLZMAPreset;\n    int           nZSTDLevel;\n    int           nWebPLevel;\n    bool          bWebPLossless;\n    int           nJpegQuality;\n    int           nJpegTablesMode;\n#if HAVE_LERC\n    double        dfMaxZError = 0.0;\n    uint32        anLercAddCompressionAndVersion[2]{0,0};\n#endif\n\n    bool          bPromoteTo8Bits;\n\n    bool          bDebugDontWriteBlocks;\n\n    CPLErr        RegisterNewOverviewDataset( toff_t nOverviewOffset, int l_nJpegQuality );\n    CPLErr        CreateOverviewsFromSrcOverviews( GDALDataset* poSrcDS );\n    CPLErr        CreateInternalMaskOverviews( int nOvrBlockXSize,\n                                               int nOvrBlockYSize );\n\n    bool          bIsFinalized;\n    int           Finalize();\n\n    bool          bIgnoreReadErrors;\n\n    CPLString     osGeorefFilename{};\n\n    bool          bDirectIO;\n\n    VirtualMemIOEnum eVirtualMemIOUsage;\n    CPLVirtualMem* psVirtualMemIOMapping;\n\n    GTIFFKeysFlavorEnum eGeoTIFFKeysFlavor;\n\n    CPLVirtualMem *pBaseMapping;\n    int            nRefBaseMapping;\n\n    bool           bHasDiscardedLsb;\n    std::vector\u003cint\u003e anMaskLsb{};\n    std::vector\u003cint\u003e anOffsetLsb{};\n    void           DiscardLsb(GByte* pabyBuffer, int nBytes, int iBand) const;\n    void           GetDiscardLsbOption( char** papszOptions );\n\n    CPLWorkerThreadPool *poCompressThreadPool;\n    std::vector\u003cGTiffCompressionJob\u003e asCompressionJobs{};\n    CPLMutex      *hCompressThreadPoolMutex;\n    void           InitCompressionThreads( char** papszOptions );\n    void           InitCreationOrOpenOptions( char** papszOptions );\n    static void    ThreadCompressionFunc( void* pData );\n    void           WaitCompletionForBlock( int nBlockId );\n    void           WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        int nCompressedBufferSize );\n    bool           SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         int cc, int nHeight) ;\n\n    int            GuessJPEGQuality( bool\u0026 bOutHasQuantizationTable,\n                                     bool\u0026 bOutHasHuffmanTable );\n\n    void           SetJPEGQualityAndTablesModeFromFile();\n\n    int            DirectIO( GDALRWFlag eRWFlag,\n                             int nXOff, int nYOff, int nXSize, int nYSize,\n                             void * pData, int nBufXSize, int nBufYSize,\n                             GDALDataType eBufType,\n                             int nBandCount, int *panBandMap,\n                             GSpacing nPixelSpace, GSpacing nLineSpace,\n                             GSpacing nBandSpace,\n                             GDALRasterIOExtraArg* psExtraArg );\n\n    int            VirtualMemIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 int nBandCount, int *panBandMap,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GSpacing nBandSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    GByte          *m_pTempBufferForCommonDirectIO;\n    size_t          m_nTempBufferForCommonDirectIOSize;\n    template\u003cclass FetchBuffer\u003e CPLErr CommonDirectIO(\n        FetchBuffer\u0026 oFetcher,\n        int nXOff, int nYOff, int nXSize, int nYSize,\n        void * pData, int nBufXSize, int nBufYSize,\n        GDALDataType eBufType,\n        int nBandCount, int *panBandMap,\n        GSpacing nPixelSpace, GSpacing nLineSpace,\n        GSpacing nBandSpace );\n\n    bool        m_bReadGeoTransform;\n    bool        m_bLoadPam;\n    void        LoadGeoreferencingAndPamIfNeeded();\n\n    bool        m_bHasGotSiblingFiles;\n    char      **GetSiblingFiles();\n\n    void        IdentifyAuthorizedGeoreferencingSources();\n    bool        m_bHasIdentifiedAuthorizedGeoreferencingSources;\n    int         m_nPAMGeorefSrcIndex;\n    int         m_nINTERNALGeorefSrcIndex;\n    int         m_nTABFILEGeorefSrcIndex;\n    int         m_nWORLDFILEGeorefSrcIndex;\n    int         m_nGeoTransformGeorefSrcIndex;\n\n    void        FlushCacheInternal( bool bFlushDirectory );\n\n    int         m_nHasOptimizedReadMultiRange = -1;\n    int         HasOptimizedReadMultiRange();\n\n  protected:\n    virtual int         CloseDependentDatasets() override;\n\n  public:\n             GTiffDataset();\n    virtual ~GTiffDataset();\n\n    virtual const char *GetProjectionRef() override;\n    virtual CPLErr SetProjection( const char * ) override;\n    virtual CPLErr GetGeoTransform( double * ) override;\n    virtual CPLErr SetGeoTransform( double * ) override;\n\n    virtual int    GetGCPCount() override;\n    virtual const char *GetGCPProjection() override;\n    virtual const GDAL_GCP *GetGCPs() override;\n    CPLErr         SetGCPs( int, const GDAL_GCP *, const char * ) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n    virtual char **GetFileList() override;\n\n    virtual CPLErr IBuildOverviews( const char *, int, int *, int, int *,\n                                    GDALProgressFunc, void * ) override;\n\n    CPLErr         OpenOffset( TIFF *, GTiffDataset **ppoActiveDSRef,\n                               toff_t nDirOffset, bool bBaseIn, GDALAccess,\n                               bool bAllowRGBAInterface = true,\n                               bool bReadGeoTransform = false );\n\n    static GDALDataset *OpenDir( GDALOpenInfo * );\n    static GDALDataset *Open( GDALOpenInfo * );\n    static int          Identify( GDALOpenInfo * );\n    static GDALDataset *Create( const char * pszFilename,\n                                int nXSize, int nYSize, int nBands,\n                                GDALDataType eType, char ** papszParmList );\n    static GDALDataset *CreateCopy( const char * pszFilename,\n                                    GDALDataset *poSrcDS,\n                                    int bStrict, char ** papszOptions,\n                                    GDALProgressFunc pfnProgress,\n                                    void * pProgressData );\n    virtual void    FlushCache() override;\n\n    virtual char  **GetMetadataDomainList() override;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override;\n    virtual const char *GetMetadataItem( const char * pszName,\n                                         const char * pszDomain = \"\" ) override;\n    virtual void   *GetInternalHandle( const char * ) override;\n\n    virtual CPLErr          CreateMaskBand( int nFlags ) override;\n\n    // Only needed by createcopy and close code.\n    static void     WriteRPC( GDALDataset *, TIFF *, int, const char *,\n                              const char *, char **,\n                              bool bWriteOnlyInPAMIfNeeded = false );\n    static bool     WriteMetadata( GDALDataset *, TIFF *, bool, const char *,\n                                   const char *, char **,\n                                   bool bExcludeRPBandIMGFileWriting = false );\n    static void     WriteNoDataValue( TIFF *, double );\n    static void     UnsetNoDataValue( TIFF * );\n\n    static TIFF *   CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString\u0026 osTmpFilename );\n\n    CPLErr   WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                      int bPreserveDataBuffer );\n\n    static void SaveICCProfile( GTiffDataset *pDS, TIFF *hTIFF,\n                                char **papszParmList, uint32 nBitsPerSample );\n\n    static bool HasVerticalCS(const char* pszProjectionIn);\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                        GTiffJPEGOverviewDS                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffJPEGOverviewDS final : public GDALDataset\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffJPEGOverviewDS)\n\n    friend class GTiffJPEGOverviewBand;\n    GTiffDataset* poParentDS;\n    int nOverviewLevel;\n\n    int        nJPEGTableSize;\n    GByte     *pabyJPEGTable;\n    CPLString  osTmpFilenameJPEGTable{};\n\n    CPLString    osTmpFilename{};\n    GDALDataset* poJPEGDS;\n    // Valid block id of the parent DS that match poJPEGDS.\n    int          nBlockId;\n\n  public:\n    GTiffJPEGOverviewDS( GTiffDataset* poParentDS, int nOverviewLevel,\n                         const void* pJPEGTable, int nJPEGTableSize );\n    virtual ~GTiffJPEGOverviewDS();\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n};\n\nclass GTiffJPEGOverviewBand final : public GDALRasterBand\n{\n  public:\n    GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDS, int nBand );\n    virtual ~GTiffJPEGOverviewBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::GTiffJPEGOverviewDS( GTiffDataset* poParentDSIn,\n                                          int nOverviewLevelIn,\n                                          const void* pJPEGTable,\n                                          int nJPEGTableSizeIn ) :\n    poParentDS(poParentDSIn),\n    nOverviewLevel(nOverviewLevelIn),\n    nJPEGTableSize(nJPEGTableSizeIn),\n    pabyJPEGTable(nullptr),\n    poJPEGDS(nullptr),\n    nBlockId(-1)\n{\n    osTmpFilenameJPEGTable.Printf(\"/vsimem/jpegtable_%p\", this);\n\n    const GByte abyAdobeAPP14RGB[] = {\n        0xFF, 0xEE, 0x00, 0x0E, 0x41, 0x64, 0x6F, 0x62, 0x65, 0x00,\n        0x64, 0x00, 0x00, 0x00, 0x00, 0x00 };\n    const bool bAddAdobe =\n        poParentDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        poParentDS-\u003enPhotometric != PHOTOMETRIC_YCBCR \u0026\u0026\n        poParentDS-\u003enBands == 3;\n    pabyJPEGTable =\n        static_cast\u003cGByte*\u003e( CPLMalloc(\n            nJPEGTableSize + (bAddAdobe ? sizeof(abyAdobeAPP14RGB) : 0)) );\n    memcpy(pabyJPEGTable, pJPEGTable, nJPEGTableSize);\n    if( bAddAdobe )\n    {\n        memcpy( pabyJPEGTable + nJPEGTableSize, abyAdobeAPP14RGB,\n                sizeof(abyAdobeAPP14RGB) );\n        nJPEGTableSize += sizeof(abyAdobeAPP14RGB);\n    }\n    CPL_IGNORE_RET_VAL(\n        VSIFCloseL(\n            VSIFileFromMemBuffer(\n                osTmpFilenameJPEGTable, pabyJPEGTable, nJPEGTableSize, TRUE )));\n\n    const int nScaleFactor = 1 \u003c\u003c nOverviewLevel;\n    nRasterXSize = (poParentDS-\u003enRasterXSize + nScaleFactor - 1) / nScaleFactor;\n    nRasterYSize = (poParentDS-\u003enRasterYSize + nScaleFactor - 1) / nScaleFactor;\n\n    for( int i = 1; i \u003c= poParentDS-\u003enBands; ++i )\n        SetBand(i, new GTiffJPEGOverviewBand(this, i));\n\n    SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    if( poParentDS-\u003enPhotometric == PHOTOMETRIC_YCBCR )\n        SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n}\n\n/************************************************************************/\n/*                       ~GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::~GTiffJPEGOverviewDS()\n{\n    if( poJPEGDS != nullptr )\n        GDALClose( poJPEGDS );\n    VSIUnlink(osTmpFilenameJPEGTable);\n    if( !osTmpFilename.empty() )\n        VSIUnlink(osTmpFilename);\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewDS::IRasterIO(\n    GDALRWFlag eRWFlag,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace,\n    GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // For non-single strip JPEG-IN-TIFF, the block based strategy will\n    // be the most efficient one, to avoid decompressing the JPEG content\n    // for each requested band.\n    if( nBandCount \u003e 1 \u0026\u0026 poParentDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        (poParentDS-\u003enBlockXSize \u003c poParentDS-\u003enRasterXSize ||\n         poParentDS-\u003enBlockYSize \u003e 1) )\n    {\n        return BlockBasedRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                   pData, nBufXSize, nBufYSize,\n                                   eBufType, nBandCount, panBandMap,\n                                   nPixelSpace, nLineSpace, nBandSpace,\n                                   psExtraArg );\n    }\n\n    return GDALDataset::IRasterIO(\n        eRWFlag, nXOff, nYOff, nXSize, nYSize,\n        pData, nBufXSize, nBufYSize, eBufType,\n        nBandCount, panBandMap, nPixelSpace, nLineSpace, nBandSpace,\n        psExtraArg );\n}\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewBand()                       */\n/************************************************************************/\n\nGTiffJPEGOverviewBand::GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDSIn,\n                                              int nBandIn )\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n    eDataType =\n        poDSIn-\u003epoParentDS-\u003eGetRasterBand(nBandIn)-\u003eGetRasterDataType();\n    poDSIn-\u003epoParentDS-\u003eGetRasterBand(nBandIn)-\u003e\n        GetBlockSize(\u0026nBlockXSize, \u0026nBlockYSize);\n    const int nScaleFactor = 1 \u003c\u003c poDSIn-\u003enOverviewLevel;\n    nBlockXSize = (nBlockXSize + nScaleFactor - 1) / nScaleFactor;\n    nBlockYSize = (nBlockYSize + nScaleFactor - 1) / nScaleFactor;\n}\n\n/************************************************************************/\n/*                          IReadBlock()                                */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                          void *pImage )\n{\n    GTiffJPEGOverviewDS* poGDS = cpl::down_cast\u003cGTiffJPEGOverviewDS *\u003e(poDS);\n\n    // Compute the source block ID.\n    int nBlockId = 0;\n    int nParentBlockXSize, nParentBlockYSize;\n    poGDS-\u003epoParentDS-\u003eGetRasterBand(1)-\u003e\n        GetBlockSize(\u0026nParentBlockXSize, \u0026nParentBlockYSize);\n    const bool bIsSingleStripAsSplit = (nParentBlockYSize == 1 \u0026\u0026\n                           poGDS-\u003epoParentDS-\u003enBlockYSize != nParentBlockYSize);\n    if( !bIsSingleStripAsSplit )\n    {\n        int l_nBlocksPerRow = DIV_ROUND_UP(poGDS-\u003epoParentDS-\u003enRasterXSize,\n                                               poGDS-\u003epoParentDS-\u003enBlockXSize);\n        nBlockId = nBlockYOff * l_nBlocksPerRow + nBlockXOff;\n    }\n    if( poGDS-\u003epoParentDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        nBlockId += (nBand-1) * poGDS-\u003epoParentDS-\u003enBlocksPerBand;\n    }\n\n    if( !poGDS-\u003epoParentDS-\u003eSetDirectory() )\n        return CE_Failure;\n\n    // Make sure it is available.\n    const int nDataTypeSize = GDALGetDataTypeSizeBytes(eDataType);\n    vsi_l_offset nOffset = 0;\n    vsi_l_offset nByteCount = 0;\n    bool bErrOccurred = false;\n    if( !poGDS-\u003epoParentDS-\u003eIsBlockAvailable(nBlockId, \u0026nOffset, \u0026nByteCount, \u0026bErrOccurred) )\n    {\n        memset(pImage, 0, nBlockXSize * nBlockYSize * nDataTypeSize );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    const int nScaleFactor = 1 \u003c\u003c poGDS-\u003enOverviewLevel;\n    if( poGDS-\u003epoJPEGDS == nullptr || nBlockId != poGDS-\u003enBlockId )\n    {\n        if( nByteCount \u003c 2 )\n            return CE_Failure;\n        nOffset += 2;  // Skip leading 0xFF 0xF8.\n        nByteCount -= 2;\n\n        // Special case for last strip that might be smaller than other strips\n        // In which case we must invalidate the dataset.\n        TIFF* hTIFF = poGDS-\u003epoParentDS-\u003ehTIFF;\n        if( !TIFFIsTiled( hTIFF ) \u0026\u0026 !bIsSingleStripAsSplit \u0026\u0026\n            (nBlockYOff + 1 ==\n                 DIV_ROUND_UP( poGDS-\u003epoParentDS-\u003enRasterYSize,\n                               poGDS-\u003epoParentDS-\u003enBlockYSize ) ||\n             (poGDS-\u003epoJPEGDS != nullptr \u0026\u0026\n              poGDS-\u003epoJPEGDS-\u003eGetRasterYSize() !=\n              nBlockYSize * nScaleFactor)) )\n        {\n            if( poGDS-\u003epoJPEGDS != nullptr )\n                GDALClose( poGDS-\u003epoJPEGDS );\n            poGDS-\u003epoJPEGDS = nullptr;\n        }\n\n        CPLString osFileToOpen;\n        poGDS-\u003eosTmpFilename.Printf(\"/vsimem/sparse_%p\", poGDS);\n        VSILFILE* fp = VSIFOpenL(poGDS-\u003eosTmpFilename, \"wb+\");\n\n        // If the size of the JPEG strip/tile is small enough, we will\n        // read it from the TIFF file and forge a in-memory JPEG file with\n        // the JPEG table followed by the JPEG data.\n        const bool bInMemoryJPEGFile = nByteCount \u003c 256 * 256;\n        if( bInMemoryJPEGFile )\n        {\n            // If the previous file was opened as a /vsisparse/, must re-open.\n            if( poGDS-\u003epoJPEGDS != nullptr \u0026\u0026\n                STARTS_WITH(poGDS-\u003epoJPEGDS-\u003eGetDescription(), \"/vsisparse/\") )\n            {\n                GDALClose( poGDS-\u003epoJPEGDS );\n                poGDS-\u003epoJPEGDS = nullptr;\n            }\n            osFileToOpen = poGDS-\u003eosTmpFilename;\n\n            bool bError = false;\n            if( VSIFSeekL(fp, poGDS-\u003enJPEGTableSize + nByteCount - 1, SEEK_SET)\n                != 0 )\n                bError = true;\n            char ch = 0;\n            if( !bError \u0026\u0026 VSIFWriteL(\u0026ch, 1, 1, fp) != 1 )\n                bError = true;\n            GByte* pabyBuffer =\n                VSIGetMemFileBuffer( poGDS-\u003eosTmpFilename, nullptr, FALSE);\n            memcpy(pabyBuffer, poGDS-\u003epabyJPEGTable, poGDS-\u003enJPEGTableSize);\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            if( !bError \u0026\u0026 VSIFSeekL(fpTIF, nOffset, SEEK_SET) != 0 )\n                bError = true;\n            if( VSIFReadL( pabyBuffer + poGDS-\u003enJPEGTableSize,\n                           static_cast\u003csize_t\u003e(nByteCount), 1, fpTIF) != 1 )\n                bError = true;\n            if( bError )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        else\n        {\n            // If the JPEG strip/tile is too big (e.g. a single-strip\n            // JPEG-in-TIFF), we will use /vsisparse mechanism to make a\n            // fake JPEG file.\n\n            // Always re-open.\n            GDALClose( poGDS-\u003epoJPEGDS );\n            poGDS-\u003epoJPEGDS = nullptr;\n\n            osFileToOpen =\n                CPLSPrintf(\"/vsisparse/%s\", poGDS-\u003eosTmpFilename.c_str());\n\n            if( VSIFPrintfL(\n                    fp,\n                    \"\u003cVSISparseFile\u003e\u003cSubfileRegion\u003e\"\n                    \"\u003cFilename relative='0'\u003e%s\u003c/Filename\u003e\"\n                    \"\u003cDestinationOffset\u003e0\u003c/DestinationOffset\u003e\"\n                    \"\u003cSourceOffset\u003e0\u003c/SourceOffset\u003e\"\n                    \"\u003cRegionLength\u003e%d\u003c/RegionLength\u003e\"\n                    \"\u003c/SubfileRegion\u003e\"\n                    \"\u003cSubfileRegion\u003e\"\n                    \"\u003cFilename relative='0'\u003e%s\u003c/Filename\u003e\"\n                    \"\u003cDestinationOffset\u003e%d\u003c/DestinationOffset\u003e\"\n                    \"\u003cSourceOffset\u003e\" CPL_FRMT_GUIB \"\u003c/SourceOffset\u003e\"\n                    \"\u003cRegionLength\u003e\" CPL_FRMT_GUIB \"\u003c/RegionLength\u003e\"\n                    \"\u003c/SubfileRegion\u003e\u003c/VSISparseFile\u003e\",\n                    poGDS-\u003eosTmpFilenameJPEGTable.c_str(),\n                    static_cast\u003cint\u003e(poGDS-\u003enJPEGTableSize),\n                    poGDS-\u003epoParentDS-\u003eGetDescription(),\n                    static_cast\u003cint\u003e(poGDS-\u003enJPEGTableSize),\n                    nOffset,\n                    nByteCount) \u003c 0 )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n\n        if( poGDS-\u003epoJPEGDS == nullptr )\n        {\n            const char* apszDrivers[] = { \"JPEG\", nullptr };\n\n            CPLString osOldVal;\n            if( poGDS-\u003epoParentDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n                poGDS-\u003enBands == 4 )\n            {\n                osOldVal =\n                    CPLGetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"\");\n                CPLSetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"NO\");\n            }\n\n            poGDS-\u003epoJPEGDS =\n                static_cast\u003cGDALDataset *\u003e( GDALOpenEx(\n                    osFileToOpen,\n                    GDAL_OF_RASTER | GDAL_OF_INTERNAL,\n                    apszDrivers, nullptr, nullptr) );\n\n            if( poGDS-\u003epoJPEGDS != nullptr )\n            {\n                // Force all implicit overviews to be available, even for\n                // small tiles.\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               \"YES\");\n                GDALGetOverviewCount(GDALGetRasterBand(poGDS-\u003epoJPEGDS, 1));\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               nullptr);\n\n                poGDS-\u003enBlockId = nBlockId;\n            }\n\n            if( poGDS-\u003epoParentDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n                poGDS-\u003enBands == 4 )\n            {\n                CPLSetThreadLocalConfigOption(\n                    \"GDAL_JPEG_TO_RGB\",\n                    !osOldVal.empty() ? osOldVal.c_str() : nullptr );\n            }\n        }\n        else\n        {\n            // Trick: we invalidate the JPEG dataset to force a reload\n            // of the new content.\n            CPLErrorReset();\n            poGDS-\u003epoJPEGDS-\u003eFlushCache();\n            if( CPLGetLastErrorNo() != 0 )\n            {\n                GDALClose( poGDS-\u003epoJPEGDS );\n                poGDS-\u003epoJPEGDS = nullptr;\n                return CE_Failure;\n            }\n            poGDS-\u003enBlockId = nBlockId;\n        }\n    }\n\n    CPLErr eErr = CE_Failure;\n    if( poGDS-\u003epoJPEGDS )\n    {\n        GDALDataset* l_poDS = poGDS-\u003epoJPEGDS;\n\n        int nReqXOff = 0;\n        int nReqYOff = 0;\n        int nReqXSize = 0;\n        int nReqYSize = 0;\n        if( bIsSingleStripAsSplit )\n        {\n            nReqYOff = nBlockYOff * nScaleFactor;\n            nReqXSize = l_poDS-\u003eGetRasterXSize();\n            nReqYSize = nScaleFactor;\n        }\n        else\n        {\n            if( nBlockXSize == poGDS-\u003eGetRasterXSize() )\n            {\n                nReqXSize = l_poDS-\u003eGetRasterXSize();\n            }\n            else\n            {\n                nReqXSize = nBlockXSize * nScaleFactor;\n            }\n            nReqYSize = nBlockYSize * nScaleFactor;\n        }\n        int nBufXSize = nBlockXSize;\n        int nBufYSize = nBlockYSize;\n        if( nBlockXOff == DIV_ROUND_UP(poGDS-\u003epoParentDS-\u003enRasterXSize,\n                                       poGDS-\u003epoParentDS-\u003enBlockXSize) - 1 )\n        {\n            nReqXSize = poGDS-\u003epoParentDS-\u003enRasterXSize -\n                                nBlockXOff * poGDS-\u003epoParentDS-\u003enBlockXSize;\n        }\n        if( nReqXOff + nReqXSize \u003e l_poDS-\u003eGetRasterXSize() )\n        {\n            nReqXSize = l_poDS-\u003eGetRasterXSize() - nReqXOff;\n        }\n        if( !bIsSingleStripAsSplit \u0026\u0026\n            nBlockYOff == DIV_ROUND_UP(poGDS-\u003epoParentDS-\u003enRasterYSize,\n                                       poGDS-\u003epoParentDS-\u003enBlockYSize) - 1 )\n        {\n            nReqYSize = poGDS-\u003epoParentDS-\u003enRasterYSize -\n                                nBlockYOff * poGDS-\u003epoParentDS-\u003enBlockYSize;\n        }\n        if( nReqYOff + nReqYSize \u003e l_poDS-\u003eGetRasterYSize() )\n        {\n            nReqYSize = l_poDS-\u003eGetRasterYSize() - nReqYOff;\n        }\n        if( nBlockXOff * nBlockXSize \u003e poGDS-\u003eGetRasterXSize() - nBufXSize )\n        {\n            memset(pImage, 0, nBlockXSize * nBlockYSize * nDataTypeSize);\n            nBufXSize = poGDS-\u003eGetRasterXSize() - nBlockXOff * nBlockXSize;\n        }\n        if( nBlockYOff * nBlockYSize \u003e poGDS-\u003eGetRasterYSize() - nBufYSize )\n        {\n            memset(pImage, 0, nBlockXSize * nBlockYSize * nDataTypeSize);\n            nBufYSize = poGDS-\u003eGetRasterYSize() - nBlockYOff * nBlockYSize;\n        }\n\n        const int nSrcBand =\n            poGDS-\u003epoParentDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE ?\n            1 : nBand;\n        if( nSrcBand \u003c= l_poDS-\u003eGetRasterCount() )\n        {\n            eErr = l_poDS-\u003eGetRasterBand(nSrcBand)-\u003eRasterIO(GF_Read,\n                                 nReqXOff, nReqYOff, nReqXSize, nReqYSize,\n                                 pImage,\n                                 nBufXSize, nBufYSize, eDataType,\n                                 0, nBlockXSize * nDataTypeSize, nullptr );\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        GTIFFSetJpegQuality()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg quality on the IFD   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast\u003cGTiffDataset *\u003e(hGTIFFDS);\n    poDS-\u003enJpegQuality = nJpegQuality;\n\n    poDS-\u003eScanDirectories();\n\n    for( int i = 0; i \u003c poDS-\u003enOverviewCount; ++i )\n        poDS-\u003epapoOverviewDS[i]-\u003enJpegQuality = nJpegQuality;\n}\n\n/************************************************************************/\n/*                     GTIFFSetJpegTablesMode()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg tables mode on the   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast\u003cGTiffDataset *\u003e(hGTIFFDS);\n    poDS-\u003enJpegTablesMode = nJpegTablesMode;\n\n    poDS-\u003eScanDirectories();\n\n    for( int i = 0; i \u003c poDS-\u003enOverviewCount; ++i )\n        poDS-\u003epapoOverviewDS[i]-\u003enJpegTablesMode = nJpegTablesMode;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffRasterBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRasterBand : public GDALPamRasterBand\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffRasterBand)\n\n    friend class GTiffDataset;\n\n    GDALColorInterp    eBandInterp;\n\n    bool               bHaveOffsetScale;\n    double             dfOffset;\n    double             dfScale;\n    CPLString          osUnitType{};\n    CPLString          osDescription{};\n\n    int                DirectIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    std::set\u003cGTiffRasterBand **\u003e aSetPSelf{};\n    static void     DropReferenceVirtualMem( void* pUserData );\n    CPLVirtualMem * GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions );\n\n    void*           CacheMultiRange( int nXOff, int nYOff,\n                                     int nXSize, int nYSize,\n                                     int nBufXSize, int nBufYSize,\n                                     GDALRasterIOExtraArg* psExtraArg );\n\nprotected:\n    GTiffDataset       *poGDS;\n    GDALMultiDomainMetadata oGTiffMDMD{};\n\n    bool               bNoDataSet;\n    double             dfNoDataValue;\n\n    void NullBlock( void *pData );\n    CPLErr FillCacheForOtherBands( int nBlockXOff, int nBlockYOff );\n\npublic:\n             GTiffRasterBand( GTiffDataset *, int );\n    virtual ~GTiffRasterBand();\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override final;\n\n    virtual const char *GetDescription() const override final;\n    virtual void        SetDescription( const char * ) override final;\n\n    virtual GDALColorInterp GetColorInterpretation() override /*final*/;\n    virtual GDALColorTable *GetColorTable() override /*final*/;\n    virtual CPLErr          SetColorTable( GDALColorTable * ) override final;\n    virtual double          GetNoDataValue( int * ) override final;\n    virtual CPLErr          SetNoDataValue( double ) override final;\n    virtual CPLErr DeleteNoDataValue() override final;\n\n    virtual double GetOffset( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetOffset( double dfNewValue ) override final;\n    virtual double GetScale( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetScale( double dfNewValue ) override final;\n    virtual const char* GetUnitType() override final;\n    virtual CPLErr SetUnitType( const char *pszNewValue ) override final;\n    virtual CPLErr SetColorInterpretation( GDALColorInterp ) override final;\n\n    virtual char      **GetMetadataDomainList() override final;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override final;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override final;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override final;\n    virtual const char *GetMetadataItem(\n        const char * pszName, const char * pszDomain = \"\" ) override final;\n    virtual int    GetOverviewCount()  override final;\n    virtual GDALRasterBand *GetOverview( int ) override final;\n\n    virtual GDALRasterBand *GetMaskBand() override final;\n    virtual int             GetMaskFlags() override final;\n    virtual CPLErr          CreateMaskBand( int nFlags )  override final;\n\n    virtual CPLVirtualMem  *GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions )  override final;\n\n    GDALRasterAttributeTable* GetDefaultRAT() override final;\n    virtual CPLErr  GetHistogram(\n        double dfMin, double dfMax,\n        int nBuckets, GUIntBig * panHistogram,\n        int bIncludeOutOfRange, int bApproxOK,\n        GDALProgressFunc, void *pProgressData )  override final;\n\n    virtual CPLErr GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                        int *pnBuckets,\n                                        GUIntBig ** ppanHistogram,\n                                        int bForce,\n                                        GDALProgressFunc,\n                                        void *pProgressData)  override final;\n};\n\n/************************************************************************/\n/*                           GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::GTiffRasterBand( GTiffDataset *poDSIn, int nBandIn ) :\n    eBandInterp(GCI_Undefined),\n    bHaveOffsetScale(false),\n    dfOffset(0.0),\n    dfScale(1.0),\n    poGDS(poDSIn),\n    bNoDataSet(false),\n    dfNoDataValue(-9999.0)\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n\n/* -------------------------------------------------------------------- */\n/*      Get the GDAL data type.                                         */\n/* -------------------------------------------------------------------- */\n    const uint16 nBitsPerSample = poGDS-\u003enBitsPerSample;\n    const uint16 nSampleFormat = poGDS-\u003enSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if( nBitsPerSample \u003c= 8 )\n    {\n        eDataType = GDT_Byte;\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            oGTiffMDMD.SetMetadataItem( \"PIXELTYPE\", \"SIGNEDBYTE\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nBitsPerSample \u003c= 16 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if( nBitsPerSample == 32 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt16;\n        else if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float32;\n        else if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if( nBitsPerSample == 64 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float64;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat32;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt32;\n    }\n    else if( nBitsPerSample == 128 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat64;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try to work out band color interpretation.                      */\n/* -------------------------------------------------------------------- */\n    bool bLookForExtraSamples = false;\n\n    if( poGDS-\u003epoColorTable != nullptr \u0026\u0026 nBand == 1 )\n    {\n        eBandInterp = GCI_PaletteIndex;\n    }\n    else if( poGDS-\u003enPhotometric == PHOTOMETRIC_RGB\n             || (poGDS-\u003enPhotometric == PHOTOMETRIC_YCBCR\n                 \u0026\u0026 poGDS-\u003enCompression == COMPRESSION_JPEG\n                 \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                    \"YES\") )) )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_RedBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_GreenBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_BlueBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS-\u003enPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_YCbCr_YBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_YCbCr_CbBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YCbCr_CrBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS-\u003enPhotometric == PHOTOMETRIC_SEPARATED )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_CyanBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_MagentaBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YellowBand;\n        else if( nBand == 4 )\n            eBandInterp = GCI_BlackBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS-\u003enPhotometric == PHOTOMETRIC_MINISBLACK \u0026\u0026 nBand == 1 )\n    {\n        eBandInterp = GCI_GrayIndex;\n    }\n    else\n    {\n        bLookForExtraSamples = true;\n    }\n\n    if( bLookForExtraSamples )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_EXTRASAMPLES, \u0026count, \u0026v ) )\n        {\n            const int nBaseSamples = poGDS-\u003enSamplesPerPixel - count;\n            const int nExpectedBaseSamples =\n                (poGDS-\u003enPhotometric == PHOTOMETRIC_MINISBLACK) ? 1 :\n                (poGDS-\u003enPhotometric == PHOTOMETRIC_MINISWHITE) ? 1 :\n                (poGDS-\u003enPhotometric == PHOTOMETRIC_RGB) ? 3 :\n                (poGDS-\u003enPhotometric == PHOTOMETRIC_YCBCR) ? 3 :\n                (poGDS-\u003enPhotometric == PHOTOMETRIC_SEPARATED) ? 4 : 0;\n\n            if( nExpectedBaseSamples \u003e 0 \u0026\u0026\n                nBand == nExpectedBaseSamples + 1 \u0026\u0026\n                nBaseSamples != nExpectedBaseSamples )\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"Wrong number of ExtraSamples : %d. %d were expected\",\n                         count, poGDS-\u003enSamplesPerPixel - nExpectedBaseSamples);\n            }\n\n            if( nBand \u003e nBaseSamples\n                \u0026\u0026 nBand-nBaseSamples-1 \u003c count\n                \u0026\u0026 (v[nBand-nBaseSamples-1] == EXTRASAMPLE_ASSOCALPHA\n                    || v[nBand-nBaseSamples-1] == EXTRASAMPLE_UNASSALPHA) )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n        else\n        {\n            eBandInterp = GCI_Undefined;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Establish block size for strip or tiles.                        */\n/* -------------------------------------------------------------------- */\n    nBlockXSize = poGDS-\u003enBlockXSize;\n    nBlockYSize = poGDS-\u003enBlockYSize;\n}\n\n/************************************************************************/\n/*                          ~GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::~GTiffRasterBand()\n{\n    // So that any future DropReferenceVirtualMem() will not try to access the\n    // raster band object, but this would not conform to the advertised\n    // contract.\n    if( !aSetPSelf.empty() )\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Virtual memory objects still exist at GTiffRasterBand \"\n                  \"destruction\" );\n        std::set\u003cGTiffRasterBand**\u003e::iterator oIter = aSetPSelf.begin();\n        for( ; oIter != aSetPSelf.end(); ++oIter )\n            *(*oIter) = nullptr;\n    }\n}\n\n/************************************************************************/\n/*                        FetchBufferDirectIO                           */\n/************************************************************************/\n\nclass FetchBufferDirectIO final\n{\n    VSILFILE*    fp;\n    GByte       *pTempBuffer;\n    size_t       nTempBufferSize;\n\npublic:\n            FetchBufferDirectIO( VSILFILE* fpIn,\n                                 GByte* pTempBufferIn,\n                                 size_t nTempBufferSizeIn ) :\n                fp(fpIn),\n                pTempBuffer(pTempBufferIn),\n                nTempBufferSize(nTempBufferSizeIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( !FetchBytes(pTempBuffer, nOffset, nPixels, nDTSize, bIsByteSwapped,\n                        bIsComplex, nBlockId) )\n        {\n            return nullptr;\n        }\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        vsi_l_offset nSeekForward = 0;\n        if( nOffset \u003c= VSIFTellL(fp) ||\n            (nSeekForward = nOffset - VSIFTellL(fp)) \u003e nTempBufferSize )\n        {\n            if( VSIFSeekL(fp, nOffset, SEEK_SET) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO,\n                         \"Cannot seek to block %d\", nBlockId);\n                return false;\n            }\n        }\n        else\n        {\n            while( nSeekForward \u003e 0 )\n            {\n                vsi_l_offset nToRead = nSeekForward;\n                if( nToRead \u003e nTempBufferSize )\n                    nToRead = nTempBufferSize;\n                if( VSIFReadL(pTempBuffer, static_cast\u003csize_t\u003e(nToRead),\n                              1, fp) != 1 )\n                {\n                    CPLError(CE_Failure, CPLE_FileIO,\n                             \"Cannot seek to block %d\", nBlockId);\n                    return false;\n                }\n                nSeekForward -= nToRead;\n            }\n        }\n        if( VSIFReadL(pabyDstBuffer, nPixels * nDTSize, 1, fp) != 1 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2 );\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = true;\n};\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffRasterBand::DirectIO( GDALRWFlag eRWFlag,\n                               int nXOff, int nYOff, int nXSize, int nYSize,\n                               void * pData, int nBufXSize, int nBufYSize,\n                               GDALDataType eBufType,\n                               GSpacing nPixelSpace, GSpacing nLineSpace,\n                               GDALRasterIOExtraArg* psExtraArg )\n{\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read \u0026\u0026\n          poGDS-\u003enCompression == COMPRESSION_NONE \u0026\u0026\n          (poGDS-\u003enPhotometric == PHOTOMETRIC_MINISBLACK ||\n           poGDS-\u003enPhotometric == PHOTOMETRIC_RGB ||\n           poGDS-\u003enPhotometric == PHOTOMETRIC_PALETTE) \u0026\u0026\n          poGDS-\u003enBitsPerSample == nDTSizeBits \u0026\u0026\n          poGDS-\u003eSetDirectory() /* very important to make hTIFF uptodate! */) )\n    {\n        return -1;\n    }\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) \u0026\u0026\n        psExtraArg != nullptr \u0026\u0026\n        psExtraArg-\u003eeResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -\u003e %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( poGDS-\u003eGetAccess() == GA_Update )\n    {\n        poGDS-\u003eFlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS-\u003ehTIFF ) );\n    }\n\n    if( TIFFIsTiled( poGDS-\u003ehTIFF ) )\n    {\n        if( poGDS-\u003em_pTempBufferForCommonDirectIO == nullptr )\n        {\n            const int nDTSize = nDTSizeBits / 8;\n            poGDS-\u003em_nTempBufferForCommonDirectIOSize =\n                static_cast\u003csize_t\u003e(\n                    nBlockXSize * nBlockYSize * nDTSize *\n                    (poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG ?\n                     poGDS-\u003enBands : 1) );\n\n            poGDS-\u003em_pTempBufferForCommonDirectIO =\n                static_cast\u003cGByte *\u003e( VSI_MALLOC_VERBOSE(\n                    poGDS-\u003em_nTempBufferForCommonDirectIOSize ) );\n            if( poGDS-\u003em_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS-\u003ehTIFF ));\n        FetchBufferDirectIO oFetcher(fp, poGDS-\u003em_pTempBufferForCommonDirectIO,\n                                     poGDS-\u003em_nTempBufferForCommonDirectIOSize);\n\n        return poGDS-\u003eCommonDirectIO(\n            oFetcher,\n            nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize,\n            eBufType,\n            1, \u0026nBand,\n            nPixelSpace, nLineSpace,\n            0 );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_STRIPOFFSETS, \u0026panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    // TODO(schwehr): Make ppData be GByte**.\n    void** ppData = static_cast\u003cvoid **\u003e(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets = static_cast\u003cvsi_l_offset *\u003e(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes = static_cast\u003csize_t *\u003e(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands =\n        poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG ? poGDS-\u003enBands : 1;\n    int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n        eErr = CE_Failure;\n    else if( nXSize != nBufXSize || nYSize != nBufYSize ||\n             eBufType != eDataType ||\n             nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n             nContigBands \u003e 1 )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast\u003cdouble\u003e( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None \u0026\u0026 iLine \u003c nReqYSize; ++iLine )\n    {\n        if( pTmpBuffer == nullptr )\n            ppData[iLine] = static_cast\u003cGByte *\u003e(pData) + iLine * nLineSpace;\n        else\n            ppData[iLine] =\n                static_cast\u003cGByte *\u003e(pTmpBuffer) +\n                iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize \u003c nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast\u003cint\u003e((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n        if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            nBlockId += (nBand-1) * poGDS-\u003enBlocksPerBand;\n        }\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0 )  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS-\u003ehTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL( nReqYSize, ppData, panOffsets, panSizes, fp );\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None \u0026\u0026 TIFFIsByteSwapped(poGDS-\u003ehTIFF) )\n    {\n        for( int iLine = 0; iLine \u003c nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2 );\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize );\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast\u003cdouble\u003e( nBufXSize );\n    if( eErr == CE_None \u0026\u0026 pTmpBuffer != nullptr )\n    {\n        for( int iY=0; iY \u003c nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize \u003c= nYSize ?\n                iY : static_cast\u003cint\u003e((iY + 0.5) * dfSrcYInc);\n\n            GByte* pabySrcData =\n                static_cast\u003cGByte*\u003e(ppData[iSrcY]) +\n                (nContigBands \u003e 1 ? (nBand-1) : 0) * nDTSize;\n            GByte* pabyDstData =\n                static_cast\u003cGByte *\u003e(pData) + iY * nLineSpace;\n            if( nBufXSize == nXSize )\n            {\n                GDALCopyWords( pabySrcData,\n                               eDataType,\n                               nSrcPixelSize,\n                               pabyDstData,\n                               eBufType,\n                               static_cast\u003cint\u003e(nPixelSpace),\n                               nBufXSize );\n            }\n            else\n            {\n                if( eDataType == GDT_Byte \u0026\u0026 eBufType == GDT_Byte )\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX \u003c nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast\u003cint\u003e(dfSrcX);\n                        pabyDstData[iX * nPixelSpace] =\n                            pabySrcData[iSrcX * nSrcPixelSize];\n                    }\n                }\n                else\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX \u003c nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast\u003cint\u003e(dfSrcX);\n                        GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                       eDataType, 0,\n                                       pabyDstData + iX * nPixelSpace,\n                                       eBufType, 0, 1 );\n                    }\n                }\n            }\n        }\n    }\n\n    // Cleanup.\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           GetVirtualMemAuto()                        */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                                   int *pnPixelSpace,\n                                                   GIntBig *pnLineSpace,\n                                                   char **papszOptions )\n{\n    const char* pszImpl = CSLFetchNameValueDef(\n            papszOptions, \"USE_DEFAULT_IMPLEMENTATION\", \"AUTO\");\n    if( EQUAL(pszImpl, \"YES\") || EQUAL(pszImpl, \"ON\") ||\n        EQUAL(pszImpl, \"1\") || EQUAL(pszImpl, \"TRUE\") )\n    {\n        return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                                  pnLineSpace, papszOptions );\n    }\n\n    CPLVirtualMem *psRet =\n        GetVirtualMemAutoInternal( eRWFlag, pnPixelSpace, pnLineSpace,\n                                   papszOptions );\n    if( psRet != nullptr )\n    {\n        CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Using memory file mapping\");\n        return psRet;\n    }\n\n    if( EQUAL(pszImpl, \"NO\") || EQUAL(pszImpl, \"OFF\") ||\n        EQUAL(pszImpl, \"0\") || EQUAL(pszImpl, \"FALSE\") )\n    {\n        return nullptr;\n    }\n\n    CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Defaulting to base implementation\");\n    return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                              pnLineSpace, papszOptions );\n}\n\n\n/************************************************************************/\n/*                           GetDefaultRAT()                            */\n/************************************************************************/\n\nGDALRasterAttributeTable *GTiffRasterBand::GetDefaultRAT()\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultRAT();\n}\n\n/************************************************************************/\n/*                           GetHistogram()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetHistogram(\n    double dfMin, double dfMax,\n    int nBuckets, GUIntBig * panHistogram,\n    int bIncludeOutOfRange, int bApproxOK,\n    GDALProgressFunc pfnProgress, void *pProgressData )\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetHistogram( dfMin, dfMax,\n                                            nBuckets, panHistogram,\n                                            bIncludeOutOfRange, bApproxOK,\n                                            pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                       GetDefaultHistogram()                          */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                             int *pnBuckets,\n                                             GUIntBig ** ppanHistogram,\n                                             int bForce,\n                                             GDALProgressFunc pfnProgress,\n                                             void *pProgressData )\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultHistogram( pdfMin, pdfMax,\n                                                   pnBuckets, ppanHistogram,\n                                                   bForce,\n                                                   pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                     DropReferenceVirtualMem()                        */\n/************************************************************************/\n\nvoid GTiffRasterBand::DropReferenceVirtualMem( void* pUserData )\n{\n    // This function may also be called when the dataset and rasterband\n    // objects have been destroyed.\n    // If they are still alive, it updates the reference counter of the\n    // base mapping to invalidate the pointer to it if needed.\n\n    GTiffRasterBand** ppoSelf = static_cast\u003cGTiffRasterBand **\u003e( pUserData );\n    GTiffRasterBand* poSelf = *ppoSelf;\n\n    if( poSelf != nullptr )\n    {\n        if( --(poSelf-\u003epoGDS-\u003enRefBaseMapping) == 0 )\n        {\n            poSelf-\u003epoGDS-\u003epBaseMapping = nullptr;\n        }\n        poSelf-\u003eaSetPSelf.erase(ppoSelf);\n    }\n    CPLFree(pUserData);\n}\n\n/************************************************************************/\n/*                     GetVirtualMemAutoInternal()                      */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                                           int *pnPixelSpace,\n                                                           GIntBig *pnLineSpace,\n                                                           char **papszOptions )\n{\n    int nLineSize = nBlockXSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG )\n        nLineSize *= poGDS-\u003enBands;\n\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // In case of a pixel interleaved file, we save virtual memory space\n        // by reusing a base mapping that embraces the whole imagery.\n        if( poGDS-\u003epBaseMapping != nullptr )\n        {\n            // Offset between the base mapping and the requested mapping.\n            vsi_l_offset nOffset =\n                static_cast\u003cvsi_l_offset\u003e(nBand - 1) *\n                GDALGetDataTypeSizeBytes(eDataType);\n\n            GTiffRasterBand** ppoSelf =\n                static_cast\u003cGTiffRasterBand** \u003e(\n                    CPLCalloc(1, sizeof(GTiffRasterBand*)) );\n            *ppoSelf = this;\n\n            CPLVirtualMem* pVMem = CPLVirtualMemDerivedNew(\n                poGDS-\u003epBaseMapping,\n                nOffset,\n                CPLVirtualMemGetSize(poGDS-\u003epBaseMapping) - nOffset,\n                GTiffRasterBand::DropReferenceVirtualMem,\n                ppoSelf);\n            if( pVMem == nullptr )\n            {\n                CPLFree(ppoSelf);\n                return nullptr;\n            }\n\n            // Mechanism used so that the memory mapping object can be\n            // destroyed after the raster band.\n            aSetPSelf.insert(ppoSelf);\n            ++poGDS-\u003enRefBaseMapping;\n            *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n            if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG )\n                *pnPixelSpace *= poGDS-\u003enBands;\n            *pnLineSpace = nLineSize;\n            return pVMem;\n        }\n    }\n\n    if( !poGDS-\u003eSetDirectory() )  // Very important to make hTIFF up-to-date.\n        return nullptr;\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS-\u003ehTIFF ));\n\n    vsi_l_offset nLength = static_cast\u003cvsi_l_offset\u003e(nRasterYSize) * nLineSize;\n\n    if( !(CPLIsVirtualMemFileMapAvailable() \u0026\u0026\n          VSIFGetNativeFileDescriptorL(fp) != nullptr \u0026\u0026\n#if SIZEOF_VOIDP == 4\n          nLength == static_cast\u003csize_t\u003e(nLength) \u0026\u0026\n#endif\n          poGDS-\u003enCompression == COMPRESSION_NONE \u0026\u0026\n          (poGDS-\u003enPhotometric == PHOTOMETRIC_MINISBLACK ||\n           poGDS-\u003enPhotometric == PHOTOMETRIC_RGB ||\n           poGDS-\u003enPhotometric == PHOTOMETRIC_PALETTE) \u0026\u0026\n          poGDS-\u003enBitsPerSample == GDALGetDataTypeSizeBits(eDataType) \u0026\u0026\n          !TIFFIsTiled( poGDS-\u003ehTIFF ) \u0026\u0026 !TIFFIsByteSwapped(poGDS-\u003ehTIFF)) )\n    {\n        return nullptr;\n    }\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( poGDS-\u003eGetAccess() == GA_Update )\n    {\n        poGDS-\u003eFlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS-\u003ehTIFF ) );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_STRIPOFFSETS, \u0026panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return nullptr;\n    }\n\n    int nBlockSize =\n        nBlockXSize * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG )\n        nBlockSize *= poGDS-\u003enBands;\n\n    int nBlocks = poGDS-\u003enBlocksPerBand;\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlocks *= poGDS-\u003enBands;\n    int i = 0;  // Used after for.\n    for( ; i \u003c nBlocks; ++i )\n    {\n        if( panTIFFOffsets[i] != 0 )\n            break;\n    }\n    if( i == nBlocks )\n    {\n        // All zeroes.\n        if( poGDS-\u003eeAccess == GA_Update )\n        {\n            // Initialize the file with empty blocks so that the file has\n            // the appropriate size.\n\n            toff_t* panByteCounts = nullptr;\n            if( !TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                               \u0026panByteCounts ) ||\n                panByteCounts == nullptr )\n            {\n                return nullptr;\n            }\n            if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n                return nullptr;\n            vsi_l_offset nBaseOffset = VSIFTellL(fp);\n\n            // Just write one tile with libtiff to put it in appropriate state.\n            GByte* pabyData =\n                static_cast\u003cGByte*\u003e(VSI_CALLOC_VERBOSE(1, nBlockSize));\n            if( pabyData == nullptr )\n            {\n                return nullptr;\n            }\n            int ret =\n                static_cast\u003cint\u003e(\n                    TIFFWriteEncodedStrip( poGDS-\u003ehTIFF, 0, pabyData,\n                                           nBlockSize ) );\n            VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS-\u003ehTIFF ) );\n            VSIFree(pabyData);\n            if( ret != nBlockSize )\n            {\n                return nullptr;\n            }\n            CPLAssert(panTIFFOffsets[0] == nBaseOffset);\n            CPLAssert(panByteCounts[0] == static_cast\u003ctoff_t\u003e(nBlockSize));\n\n            // Now simulate the writing of other blocks.\n            const vsi_l_offset nDataSize =\n                static_cast\u003cvsi_l_offset\u003e(nBlockSize) * nBlocks;\n            if( VSIFTruncateL(fp, nBaseOffset + nDataSize) != 0 )\n                return nullptr;\n\n            for( i = 1; i \u003c nBlocks; ++i)\n            {\n                panTIFFOffsets[i] =\n                    nBaseOffset + i * static_cast\u003ctoff_t\u003e(nBlockSize);\n                panByteCounts[i] = nBlockSize;\n            }\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"Sparse files not supported in file mapping\" );\n            return nullptr;\n        }\n    }\n\n    GIntBig nBlockSpacing = 0;\n    bool bCompatibleSpacing = true;\n    toff_t nPrevOffset = 0;\n    for( i = 0; i \u003c poGDS-\u003enBlocksPerBand; ++i )\n    {\n        toff_t nCurOffset = 0;\n        if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n            nCurOffset =\n                panTIFFOffsets[poGDS-\u003enBlocksPerBand * (nBand - 1) + i];\n        else\n            nCurOffset = panTIFFOffsets[i];\n        if( nCurOffset == 0 )\n        {\n            bCompatibleSpacing = false;\n            break;\n        }\n        if( i \u003e 0 )\n        {\n            const GIntBig nCurSpacing = nCurOffset - nPrevOffset;\n            if( i == 1 )\n            {\n                if( nCurSpacing !=\n                    static_cast\u003cGIntBig\u003e(nBlockYSize) * nLineSize )\n                {\n                    bCompatibleSpacing = false;\n                    break;\n                }\n                nBlockSpacing = nCurSpacing;\n            }\n            else if( nBlockSpacing != nCurSpacing )\n            {\n                bCompatibleSpacing = false;\n                break;\n            }\n        }\n        nPrevOffset = nCurOffset;\n    }\n\n    if( !bCompatibleSpacing )\n    {\n        return nullptr;\n    }\n\n    vsi_l_offset nOffset = 0;\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        CPLAssert( poGDS-\u003epBaseMapping == nullptr );\n        nOffset = panTIFFOffsets[0];\n    }\n    else\n    {\n        nOffset = panTIFFOffsets[poGDS-\u003enBlocksPerBand * (nBand - 1)];\n    }\n    CPLVirtualMem* pVMem = CPLVirtualMemFileMapNew(\n        fp, nOffset, nLength,\n        eRWFlag == GF_Write ? VIRTUALMEM_READWRITE : VIRTUALMEM_READONLY,\n        nullptr, nullptr);\n    if( pVMem == nullptr )\n    {\n        return nullptr;\n    }\n\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // TODO(schwehr): Revisit this block.\n        poGDS-\u003epBaseMapping = pVMem;\n        pVMem = GetVirtualMemAutoInternal( eRWFlag,\n                                           pnPixelSpace,\n                                           pnLineSpace,\n                                           papszOptions );\n        // Drop ref on base mapping.\n        CPLVirtualMemFree(poGDS-\u003epBaseMapping);\n        if( pVMem == nullptr )\n            poGDS-\u003epBaseMapping = nullptr;\n    }\n    else\n    {\n        *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n        if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG )\n            *pnPixelSpace *= poGDS-\u003enBands;\n        *pnLineSpace = nLineSize;\n    }\n    return pVMem;\n}\n\n/************************************************************************/\n/*                     HasOptimizedReadMultiRange()                     */\n/************************************************************************/\n\nint GTiffDataset::HasOptimizedReadMultiRange()\n{\n    if( m_nHasOptimizedReadMultiRange \u003e= 0 )\n        return m_nHasOptimizedReadMultiRange;\n    m_nHasOptimizedReadMultiRange =\n        VSIHasOptimizedReadMultiRange(osFilename);\n    return m_nHasOptimizedReadMultiRange;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffDataset::IRasterIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize \u003c nXSize \u0026\u0026 nBufYSize \u003c nYSize )\n    {\n        int bTried = FALSE;\n        ++nJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nBandCount, panBandMap,\n                                 nPixelSpace, nLineSpace,\n                                 nBandSpace,\n                                 psExtraArg,\n                                 \u0026bTried );\n        --nJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( eVirtualMemIOUsage != VIRTUAL_MEM_IO_NO )\n    {\n        const int nErr = VirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr \u003e= 0 )\n            return static_cast\u003cCPLErr\u003e(nErr);\n    }\n    if( bDirectIO )\n    {\n        const int nErr = DirectIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr \u003e= 0 )\n            return static_cast\u003cCPLErr\u003e(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( eAccess == GA_ReadOnly \u0026\u0026\n        eRWFlag == GF_Read \u0026\u0026\n        nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        HasOptimizedReadMultiRange() )\n    {\n        pBufferedData = cpl::down_cast\u003cGTiffRasterBand *\u003e(\n            GetRasterBand(1))-\u003eCacheMultiRange(nXOff, nYOff,\n                                               nXSize, nYSize,\n                                               nBufXSize, nBufYSize,\n                                               psExtraArg);\n    }\n\n    ++nJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamDataset::IRasterIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg);\n    nJPEGOverviewVisibilityCounter--;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( hTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        FetchBufferVirtualMemIO                       */\n/************************************************************************/\n\nclass FetchBufferVirtualMemIO final\n{\n    const GByte* pabySrcData;\n    size_t       nMappingSize;\n    GByte       *pTempBuffer;\n\npublic:\n            FetchBufferVirtualMemIO( const GByte* pabySrcDataIn,\n                                     size_t nMappingSizeIn,\n                                     GByte* pTempBufferIn ) :\n                pabySrcData(pabySrcDataIn),\n                nMappingSize(nMappingSizeIn),\n                pTempBuffer(pTempBufferIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize \u003e nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return nullptr;\n        }\n        if( !bIsByteSwapped )\n            return pabySrcData + nOffset;\n        memcpy(pTempBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsComplex )\n            GDALSwapWords( pTempBuffer, nDTSize / 2, 2 * nPixels, nDTSize / 2);\n        else\n            GDALSwapWords( pTempBuffer, nDTSize, nPixels, nDTSize);\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize \u003e nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n        memcpy(pabyDstBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2);\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = false;\n};\n\n/************************************************************************/\n/*                         VirtualMemIO()                               */\n/************************************************************************/\n\nint GTiffDataset::VirtualMemIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n{\n    if( eAccess == GA_Update || eRWFlag == GF_Write || bStreamingIn )\n        return -1;\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) \u0026\u0026\n        psExtraArg != nullptr \u0026\u0026\n        psExtraArg-\u003eeResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    const GDALDataType eDataType = GetRasterBand(1)-\u003eGetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(nCompression == COMPRESSION_NONE \u0026\u0026\n        (nPhotometric == PHOTOMETRIC_MINISBLACK ||\n        nPhotometric == PHOTOMETRIC_RGB ||\n        nPhotometric == PHOTOMETRIC_PALETTE) \u0026\u0026\n        nBitsPerSample == nDTSizeBits) )\n    {\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n        return -1;\n    }\n\n    size_t nMappingSize = 0;\n    GByte* pabySrcData = nullptr;\n    if( STARTS_WITH(osFilename, \"/vsimem/\") )\n    {\n        vsi_l_offset nDataLength = 0;\n        pabySrcData =\n            VSIGetMemFileBuffer(osFilename, \u0026nDataLength, FALSE);\n        nMappingSize = static_cast\u003csize_t\u003e(nDataLength);\n        if( pabySrcData == nullptr )\n            return -1;\n    }\n    else if( psVirtualMemIOMapping == nullptr )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n        if( !CPLIsVirtualMemFileMapAvailable() ||\n            VSIFGetNativeFileDescriptorL(fp) == nullptr )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        const vsi_l_offset nLength = VSIFTellL(fp);\n        if( static_cast\u003csize_t\u003e(nLength) != nLength )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        if( eVirtualMemIOUsage == VIRTUAL_MEM_IO_IF_ENOUGH_RAM )\n        {\n            GIntBig nRAM = CPLGetUsablePhysicalRAM();\n            if( static_cast\u003cGIntBig\u003e(nLength) \u003e nRAM )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Not enough RAM to map whole file into memory.\" );\n                eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n                return -1;\n            }\n        }\n        psVirtualMemIOMapping = CPLVirtualMemFileMapNew(\n            fp, 0, nLength, VIRTUALMEM_READONLY, nullptr, nullptr);\n        if( psVirtualMemIOMapping == nullptr )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_YES;\n    }\n\n    if( psVirtualMemIOMapping )\n    {\n#ifdef DEBUG\n        CPLDebug(\"GTiff\", \"Using VirtualMemIO\");\n#endif\n        nMappingSize = CPLVirtualMemGetSize(psVirtualMemIOMapping);\n        pabySrcData = static_cast\u003cGByte *\u003e(\n            CPLVirtualMemGetAddr(psVirtualMemIOMapping) );\n    }\n\n    if( TIFFIsByteSwapped(hTIFF) \u0026\u0026 m_pTempBufferForCommonDirectIO == nullptr )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        m_nTempBufferForCommonDirectIOSize =\n            static_cast\u003csize_t\u003e(nBlockXSize * nDTSize *\n                (nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1));\n        if( TIFFIsTiled(hTIFF) )\n            m_nTempBufferForCommonDirectIOSize *= nBlockYSize;\n\n        m_pTempBufferForCommonDirectIO =\n            static_cast\u003cGByte *\u003e(\n                VSI_MALLOC_VERBOSE(m_nTempBufferForCommonDirectIOSize) );\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n            return CE_Failure;\n    }\n    FetchBufferVirtualMemIO oFetcher( pabySrcData, nMappingSize,\n                                      m_pTempBufferForCommonDirectIO );\n\n    return CommonDirectIO( oFetcher,\n                           nXOff, nYOff, nXSize, nYSize,\n                           pData, nBufXSize, nBufYSize,\n                           eBufType,\n                           nBandCount, panBandMap,\n                           nPixelSpace, nLineSpace,\n                           nBandSpace );\n}\n\n/************************************************************************/\n/*                   CopyContigByteMultiBand()                          */\n/************************************************************************/\n\nstatic inline void CopyContigByteMultiBand(\n    const GByte* CPL_RESTRICT pabySrc, int nSrcStride,\n    GByte* CPL_RESTRICT pabyDest, int nDestStride,\n    int nIters, int nBandCount )\n{\n    if( nBandCount == 3 )\n    {\n        if( nSrcStride == 3 \u0026\u0026 nDestStride == 4 )\n        {\n            while( nIters \u003e= 8 )\n            {\n                pabyDest[4*0+0] = pabySrc[3*0+0];\n                pabyDest[4*0+1] = pabySrc[3*0+1];\n                pabyDest[4*0+2] = pabySrc[3*0+2];\n                pabyDest[4*1+0] = pabySrc[3*1+0];\n                pabyDest[4*1+1] = pabySrc[3*1+1];\n                pabyDest[4*1+2] = pabySrc[3*1+2];\n                pabyDest[4*2+0] = pabySrc[3*2+0];\n                pabyDest[4*2+1] = pabySrc[3*2+1];\n                pabyDest[4*2+2] = pabySrc[3*2+2];\n                pabyDest[4*3+0] = pabySrc[3*3+0];\n                pabyDest[4*3+1] = pabySrc[3*3+1];\n                pabyDest[4*3+2] = pabySrc[3*3+2];\n                pabyDest[4*4+0] = pabySrc[3*4+0];\n                pabyDest[4*4+1] = pabySrc[3*4+1];\n                pabyDest[4*4+2] = pabySrc[3*4+2];\n                pabyDest[4*5+0] = pabySrc[3*5+0];\n                pabyDest[4*5+1] = pabySrc[3*5+1];\n                pabyDest[4*5+2] = pabySrc[3*5+2];\n                pabyDest[4*6+0] = pabySrc[3*6+0];\n                pabyDest[4*6+1] = pabySrc[3*6+1];\n                pabyDest[4*6+2] = pabySrc[3*6+2];\n                pabyDest[4*7+0] = pabySrc[3*7+0];\n                pabyDest[4*7+1] = pabySrc[3*7+1];\n                pabyDest[4*7+2] = pabySrc[3*7+2];\n                pabySrc += 3 * 8;\n                pabyDest += 4 * 8;\n                nIters -= 8;\n            }\n            while( nIters-- \u003e 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += 3;\n                pabyDest += 4;\n            }\n        }\n        else\n        {\n            while( nIters-- \u003e 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += nSrcStride;\n                pabyDest += nDestStride;\n            }\n        }\n    }\n    else\n    {\n        while( nIters-- \u003e 0 )\n        {\n            for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                pabyDest[iBand] = pabySrc[iBand];\n            pabySrc += nSrcStride;\n            pabyDest += nDestStride;\n        }\n    }\n}\n\n/************************************************************************/\n/*                         CommonDirectIO()                             */\n/************************************************************************/\n\n// #define DEBUG_REACHED_VIRTUAL_MEM_IO\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\nstatic int anReachedVirtualMemIO[52] = { 0 };\n#define REACHED(x) anReachedVirtualMemIO[x] = 1\n#else\n#define REACHED(x)\n#endif\n\ntemplate\u003cclass FetchBuffer\u003e CPLErr GTiffDataset::CommonDirectIO(\n    FetchBuffer\u0026 oFetcher,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace )\n{\n    const GDALDataType eDataType = GetRasterBand(1)-\u003eGetRasterDataType();\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    const bool bIsComplex = CPL_TO_BOOL(GDALDataTypeIsComplex(eDataType));\n    const int nBufDTSize = GDALGetDataTypeSizeBytes(eBufType);\n\n    // Get strip offsets.\n    toff_t *panOffsets = nullptr;\n    if( !TIFFGetField( hTIFF, (TIFFIsTiled( hTIFF )) ?\n                       TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                       \u0026panOffsets ) ||\n        panOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    bool bUseContigImplementation =\n        nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        nBandCount \u003e 1 \u0026\u0026\n        nBandSpace == nBufDTSize;\n    if( bUseContigImplementation )\n    {\n        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n        {\n            const int nBand = panBandMap[iBand];\n            if( nBand != iBand + 1 )\n            {\n                bUseContigImplementation = false;\n                break;\n            }\n        }\n    }\n\n    const int nBandsPerBlock =\n        nPlanarConfig == PLANARCONFIG_SEPARATE ? 1 : nBands;\n    const int nBandsPerBlockDTSize = nBandsPerBlock * nDTSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    const bool bNoTypeChange = (eDataType == eBufType);\n    const bool bNoXResampling = (nXSize == nBufXSize );\n    const bool bNoXResamplingNoTypeChange = (bNoTypeChange \u0026\u0026 bNoXResampling);\n    const bool bByteOnly = (bNoTypeChange \u0026\u0026 nDTSize == 1 );\n    const bool bByteNoXResampling = ( bByteOnly \u0026\u0026 bNoXResamplingNoTypeChange );\n    const bool bIsByteSwapped = CPL_TO_BOOL(TIFFIsByteSwapped(hTIFF));\n    const double dfSrcXInc = nXSize / static_cast\u003cdouble\u003e( nBufXSize );\n    const double dfSrcYInc = nYSize / static_cast\u003cdouble\u003e( nBufYSize );\n\n    int bNoDataSetIn = FALSE;\n    double dfNoData = GetRasterBand(1)-\u003eGetNoDataValue( \u0026bNoDataSetIn );\n    GByte abyNoData = 0;\n    if( !bNoDataSetIn )\n        dfNoData = 0;\n    else if( dfNoData \u003e= 0 \u0026\u0026 dfNoData \u003c= 255 )\n        abyNoData = static_cast\u003cGByte\u003e(dfNoData + 0.5);\n\n    if( FetchBuffer::bMinimizeIO \u0026\u0026\n             TIFFIsTiled( hTIFF ) \u0026\u0026 bNoXResampling \u0026\u0026 (nYSize == nBufYSize ) \u0026\u0026\n             nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 nBandCount \u003e 1 )\n    {\n        GByte* pabyData = static_cast\u003cGByte *\u003e(pData);\n        for( int y = 0; y \u003c nBufYSize; )\n        {\n            const int nSrcLine = nYOff + y;\n            const int nBlockYOff = nSrcLine / nBlockYSize;\n            const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n            const int nUsedBlockHeight =\n                std::min( nBufYSize - y,\n                          nBlockYSize - nYOffsetInBlock );\n\n            int nBlockXOff = nXOff / nBlockXSize;\n            int nXOffsetInBlock = nXOff % nBlockXSize;\n            int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n            int x = 0;\n            while( x \u003c nBufXSize )\n            {\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                const int nUsedBlockWidth =\n                    std::min( nBlockXSize - nXOffsetInBlock,\n                              nBufXSize - x );\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(30);\n                    for( int k = 0; k \u003c nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                        {\n                            GByte* pabyLocalDataBand =\n                                pabyLocalData + iBand * nBandSpace;\n\n                            GDALCopyWords(\n                                \u0026dfNoData, GDT_Float64, 0,\n                                pabyLocalDataBand, eBufType,\n                                static_cast\u003cint\u003e(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                }\n                else\n                {\n                    const int nByteOffsetInBlock =\n                        nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                    const GByte* pabyLocalSrcDataK0 = oFetcher.FetchBytes(\n                            nCurOffset + nByteOffsetInBlock,\n                            nBlockXSize *\n                            nUsedBlockHeight * nBandsPerBlock,\n                            nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                    if( pabyLocalSrcDataK0 == nullptr )\n                        return CE_Failure;\n\n                    for( int k = 0; k \u003c nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        const GByte* pabyLocalSrcData =\n                            pabyLocalSrcDataK0 +\n                            (k * nBlockXSize + nXOffsetInBlock) *\n                            nBandsPerBlockDTSize;\n\n                        if( bUseContigImplementation \u0026\u0026 nBands == nBandCount \u0026\u0026\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(31);\n                            GDALCopyWords( pabyLocalSrcData,\n                                           eDataType, nDTSize,\n                                           pabyLocalData,\n                                           eBufType, nBufDTSize,\n                                           nUsedBlockWidth * nBands );\n                        }\n                        else\n                        {\n                            REACHED(32);\n                            for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords(\n                                    pabyLocalSrcDataBand,\n                                    eDataType, nBandsPerBlockDTSize,\n                                    pabyLocalDataBand,\n                                    eBufType, static_cast\u003cint\u003e(nPixelSpace),\n                                    nUsedBlockWidth );\n                            }\n                        }\n                    }\n                }\n\n                nXOffsetInBlock = 0;\n                ++nBlockXOff;\n                ++nBlockId;\n                x += nUsedBlockWidth;\n            }\n\n            y += nUsedBlockHeight;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO \u0026\u0026\n             TIFFIsTiled( hTIFF ) \u0026\u0026 bNoXResampling \u0026\u0026\n             (nYSize == nBufYSize ) )\n             // \u0026\u0026 (nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast\u003cGByte *\u003e(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            for( int y = 0; y \u003c nBufYSize; )\n            {\n                const int nSrcLine = nYOff + y;\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nUsedBlockHeight =\n                    std::min( nBufYSize - y,\n                              nBlockYSize - nYOffsetInBlock);\n\n                int nBlockXOff = nXOff / nBlockXSize;\n                int nXOffsetInBlock = nXOff % nBlockXSize;\n                int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                {\n                    REACHED(33);\n                    nBlockId += nBlocksPerBand * (nBand - 1);\n                }\n                else\n                {\n                    REACHED(34);\n                }\n\n                int x = 0;\n                while( x \u003c nBufXSize )\n                {\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    const int nUsedBlockWidth =\n                        std::min(\n                            nBlockXSize - nXOffsetInBlock,\n                            nBufXSize - x);\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(35);\n                        for( int k = 0; k \u003c nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords(\n                                \u0026dfNoData, GDT_Float64, 0,\n                                pabyLocalData, eBufType,\n                                static_cast\u003cint\u003e(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                    else\n                    {\n                        const int nByteOffsetInBlock =\n                            nYOffsetInBlock * nBlockXSize *\n                            nBandsPerBlockDTSize;\n                        const GByte* pabyLocalSrcDataK0 =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nByteOffsetInBlock,\n                                nBlockXSize *\n                                nUsedBlockHeight * nBandsPerBlock,\n                                nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataK0 == nullptr )\n                            return CE_Failure;\n\n                        if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                        {\n                            REACHED(36);\n                            pabyLocalSrcDataK0 += (nBand - 1) * nDTSize;\n                        }\n                        else\n                        {\n                            REACHED(37);\n                        }\n\n                        for( int k = 0; k \u003c nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace +\n                                x * nPixelSpace;\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (k * nBlockXSize + nXOffsetInBlock) *\n                                nBandsPerBlockDTSize;\n\n                            GDALCopyWords(\n                                pabyLocalSrcData,\n                                eDataType, nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                eBufType, static_cast\u003cint\u003e(nPixelSpace),\n                                nUsedBlockWidth);\n                        }\n                    }\n\n                    nXOffsetInBlock = 0;\n                    ++nBlockXOff;\n                    ++nBlockId;\n                    x += nUsedBlockWidth;\n                }\n\n                y += nUsedBlockHeight;\n            }\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO \u0026\u0026\n             TIFFIsTiled( hTIFF ) \u0026\u0026\n             nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 nBandCount \u003e 1 )\n    {\n        GByte* pabyData = static_cast\u003cGByte *\u003e(pData);\n        int anSrcYOffset[256] = { 0 };\n        for( int y = 0; y \u003c nBufYSize; )\n        {\n            const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n            const int nSrcLine = static_cast\u003cint\u003e(dfYOffStart);\n            const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n            const int nBlockYOff = nSrcLine / nBlockYSize;\n            const int nBaseByteOffsetInBlock =\n                nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n            int ychunk = 1;\n            int nLastSrcLineK = nSrcLine;\n            anSrcYOffset[0] = 0;\n            for( int k = 1; k \u003c nBufYSize - y; ++k )\n            {\n                int nSrcLineK =\n                    nYOff + static_cast\u003cint\u003e((y + k + 0.5) * dfSrcYInc);\n                const int nBlockYOffK = nSrcLineK / nBlockYSize;\n                if( k \u003c 256)\n                    anSrcYOffset[k] =\n                        ((nSrcLineK % nBlockYSize) - nYOffsetInBlock) *\n                        nBlockXSize * nBandsPerBlockDTSize;\n                if( nBlockYOffK != nBlockYOff )\n                {\n                    break;\n                }\n                ++ychunk;\n                nLastSrcLineK = nSrcLineK;\n            }\n            const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n            // CPLAssert(nUsedBlockHeight \u003c= nBlockYSize);\n\n            double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n            int nCurBlockXOff = 0;\n            int nNextBlockXOff = 0;\n            toff_t nCurOffset = 0;\n            const GByte* pabyLocalSrcDataStartLine = nullptr;\n            for( int x = 0; x \u003c nBufXSize; ++x, dfSrcX += dfSrcXInc)\n            {\n                const int nSrcPixel = static_cast\u003cint\u003e(dfSrcX);\n                if( nSrcPixel \u003e= nNextBlockXOff )\n                {\n                    const int nBlockXOff = nSrcPixel / nBlockXSize;\n                    nCurBlockXOff = nBlockXOff * nBlockXSize;\n                    nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                    const int nBlockId =\n                        nBlockXOff + nBlockYOff * nBlocksPerRow;\n                    nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset != 0 )\n                    {\n                        pabyLocalSrcDataStartLine =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                nBlockXSize *\n                                nBandsPerBlock * nUsedBlockHeight,\n                                nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataStartLine == nullptr )\n                            return CE_Failure;\n                    }\n                }\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(38);\n\n                    for( int k = 0; k \u003c ychunk; ++k )\n                    {\n                        GByte* const pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                        {\n                            GDALCopyWords(\n                                \u0026dfNoData, GDT_Float64, 0,\n                                pabyLocalData + nBandSpace * iBand, eBufType, 0,\n                                1);\n                        }\n                    }\n                }\n                else\n                {\n                    const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                    double dfYOff = dfYOffStart;\n                    const GByte* const pabyLocalSrcDataK0 =\n                        pabyLocalSrcDataStartLine +\n                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                    GByte* pabyLocalData =\n                        pabyData + y * nLineSpace + x * nPixelSpace;\n                    for( int k = 0;\n                         k \u003c ychunk;\n                         ++k, pabyLocalData += nLineSpace )\n                    {\n                        const GByte* pabyLocalSrcData = nullptr;\n                        if( ychunk \u003c= 256 )\n                        {\n                            REACHED(39);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 + anSrcYOffset[k];\n                        }\n                        else\n                        {\n                            REACHED(40);\n                            const int nYOffsetInBlockK =\n                                static_cast\u003cint\u003e(dfYOff) % nBlockYSize;\n                            // CPLAssert(\n                            //     nYOffsetInBlockK - nYOffsetInBlock \u003c=\n                            //     nUsedBlockHeight);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (nYOffsetInBlockK - nYOffsetInBlock) *\n                                nBlockXSize * nBandsPerBlockDTSize;\n                            dfYOff += dfSrcYInc;\n                        }\n\n                        if( bByteOnly )\n                        {\n                            REACHED(41);\n                            for( int iBand=0; iBand \u003c nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData + (panBandMap[iBand]-1);\n                                *pabyLocalDataBand = *pabyLocalSrcDataBand;\n                            }\n                        }\n                        else\n                        {\n                            REACHED(42);\n                            for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords( pabyLocalSrcDataBand,\n                                               eDataType, 0,\n                                               pabyLocalDataBand,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n            }\n\n            y += ychunk;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO \u0026\u0026\n             TIFFIsTiled( hTIFF ) )\n             // \u0026\u0026 (nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast\u003cGByte*\u003e(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            int anSrcYOffset[256] = { 0 };\n            for( int y = 0; y \u003c nBufYSize; )\n            {\n                const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n                const int nSrcLine = static_cast\u003cint\u003e(dfYOffStart);\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nBaseByteOffsetInBlock =\n                    nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                int ychunk = 1;\n                int nLastSrcLineK = nSrcLine;\n                anSrcYOffset[0] = 0;\n                for( int k = 1; k \u003c nBufYSize - y; ++k )\n                {\n                    const int nSrcLineK =\n                        nYOff + static_cast\u003cint\u003e((y + k + 0.5) * dfSrcYInc);\n                    const int nBlockYOffK = nSrcLineK / nBlockYSize;\n                    if( k \u003c 256)\n                        anSrcYOffset[k] =\n                            ((nSrcLineK % nBlockYSize) - nYOffsetInBlock) *\n                            nBlockXSize * nBandsPerBlockDTSize;\n                    if( nBlockYOffK != nBlockYOff )\n                    {\n                        break;\n                    }\n                    ++ychunk;\n                    nLastSrcLineK = nSrcLineK;\n                }\n                const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n                // CPLAssert(nUsedBlockHeight \u003c= nBlockYSize);\n\n                double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                int nCurBlockXOff = 0;\n                int nNextBlockXOff = 0;\n                toff_t nCurOffset = 0;\n                const GByte* pabyLocalSrcDataStartLine = nullptr;\n                for( int x = 0; x \u003c nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                {\n                    int nSrcPixel = static_cast\u003cint\u003e(dfSrcX);\n                    if( nSrcPixel \u003e= nNextBlockXOff )\n                    {\n                        const int nBlockXOff = nSrcPixel / nBlockXSize;\n                        nCurBlockXOff = nBlockXOff * nBlockXSize;\n                        nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(43);\n                            nBlockId += nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(44);\n                        }\n                        nCurOffset = panOffsets[nBlockId];\n                        if( nCurOffset != 0 )\n                        {\n                            pabyLocalSrcDataStartLine =\n                                oFetcher.FetchBytes(\n                                    nCurOffset + nBaseByteOffsetInBlock,\n                                    nBlockXSize *\n                                    nBandsPerBlock * nUsedBlockHeight,\n                                    nDTSize,\n                                    bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcDataStartLine == nullptr )\n                                return CE_Failure;\n\n                            if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                            {\n                                REACHED(45);\n                                pabyLocalSrcDataStartLine +=\n                                    (nBand - 1) * nDTSize;\n                            }\n                            else\n                            {\n                                REACHED(46);\n                            }\n                        }\n                    }\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(47);\n\n                        for( int k = 0; k \u003c ychunk; ++k )\n                        {\n                            GByte* const pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords( \u0026dfNoData, GDT_Float64, 0,\n                                           pabyLocalData, eBufType, 0,\n                                           1 );\n                        }\n                    }\n                    else\n                    {\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                        double dfYOff = dfYOffStart;\n                        const GByte* const pabyLocalSrcDataK0 =\n                            pabyLocalSrcDataStartLine +\n                            nXOffsetInBlock * nBandsPerBlockDTSize;\n                        GByte* pabyLocalData =\n                            pabyData + y * nLineSpace + x * nPixelSpace;\n                        for( int k = 0;\n                             k \u003c ychunk;\n                             ++k, pabyLocalData += nLineSpace )\n                        {\n                            const GByte* pabyLocalSrcData = nullptr;\n                            if( ychunk \u003c= 256 )\n                            {\n                                REACHED(48);\n                                pabyLocalSrcData =\n                                    pabyLocalSrcDataK0 + anSrcYOffset[k];\n                            }\n                            else\n                            {\n                                REACHED(49);\n                                const int nYOffsetInBlockK =\n                                    static_cast\u003cint\u003e(dfYOff) % nBlockYSize;\n                                // CPLAssert(\n                                //     nYOffsetInBlockK - nYOffsetInBlock \u003c=\n                                //     nUsedBlockHeight);\n                                pabyLocalSrcData = pabyLocalSrcDataK0 +\n                                    (nYOffsetInBlockK - nYOffsetInBlock) *\n                                    nBlockXSize * nBandsPerBlockDTSize;\n                                dfYOff += dfSrcYInc;\n                            }\n\n                            if( bByteOnly )\n                            {\n                                REACHED(50);\n\n                                *pabyLocalData = *pabyLocalSrcData;\n                            }\n                            else\n                            {\n                                REACHED(51);\n\n                                GDALCopyWords( pabyLocalSrcData,\n                                               eDataType, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n\n                y += ychunk;\n            }\n        }\n    }\n    else if( bUseContigImplementation )\n    {\n        if( !FetchBuffer::bMinimizeIO \u0026\u0026 TIFFIsTiled( hTIFF ) )\n        {\n            GByte* pabyData = static_cast\u003cGByte *\u003e(pData);\n            for( int y = 0; y \u003c nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast\u003cint\u003e((y + 0.5) * dfSrcYInc);\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBaseByteOffsetInBlock =\n                    nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n\n                if( bNoXResampling )\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    int nBlockXOff = nXOff / nBlockXSize;\n                    int nXOffsetInBlock = nXOff % nBlockXSize;\n                    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n                    int x = 0;\n                    while( x \u003c nBufXSize )\n                    {\n                        const int nByteOffsetInBlock = nBaseByteOffsetInBlock +\n                                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                        const toff_t nCurOffset = panOffsets[nBlockId];\n                        const int nUsedBlockWidth =\n                            std::min(\n                                nBlockXSize - nXOffsetInBlock,\n                                nBufXSize - x);\n\n                        int nIters = nUsedBlockWidth;\n                        if( nCurOffset == 0 )\n                        {\n                            if( bByteNoXResampling )\n                            {\n                                REACHED(0);\n                                while( nIters-- \u003e 0 )\n                                {\n                                    for( int iBand = 0;\n                                         iBand \u003c nBandCount;\n                                         ++iBand )\n                                    {\n                                        pabyLocalData[iBand] = abyNoData;\n                                    }\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                            else\n                            {\n                                REACHED(1);\n                                while( nIters-- \u003e 0 )\n                                {\n                                    GDALCopyWords(\n                                        \u0026dfNoData, GDT_Float64, 0,\n                                        pabyLocalData, eBufType,\n                                        static_cast\u003cint\u003e(nBandSpace),\n                                        nBandCount);\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if( bNoTypeChange \u0026\u0026 nBands == nBandCount \u0026\u0026\n                                nPixelSpace == nBandsPerBlockDTSize )\n                            {\n                                REACHED(2);\n                                if( !oFetcher.FetchBytes(\n                                        pabyLocalData,\n                                        nCurOffset + nByteOffsetInBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId) )\n                                {\n                                    return CE_Failure;\n                                }\n                                pabyLocalData +=\n                                    nIters * nBandsPerBlock * nDTSize;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nByteOffsetInBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcData == nullptr )\n                                    return CE_Failure;\n                                if( bByteNoXResampling )\n                                {\n                                    REACHED(3);\n                                    CopyContigByteMultiBand(\n                                        pabyLocalSrcData,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData,\n                                        static_cast\u003cint\u003e(nPixelSpace),\n                                        nIters,\n                                        nBandCount);\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    REACHED(4);\n                                    while( nIters-- \u003e 0 )\n                                    {\n                                        GDALCopyWords(\n                                            pabyLocalSrcData,\n                                            eDataType, nDTSize,\n                                            pabyLocalData,\n                                            eBufType,\n                                            static_cast\u003cint\u003e(nBandSpace),\n                                            nBandCount);\n                                        pabyLocalSrcData +=\n                                            nBandsPerBlockDTSize;\n                                        pabyLocalData += nPixelSpace;\n                                    }\n                                }\n                            }\n                        }\n\n                        nXOffsetInBlock = 0;\n                        ++nBlockXOff;\n                        ++nBlockId;\n                        x += nUsedBlockWidth;\n                    }\n                }\n                else  // Contig, tiled, potential resampling \u0026 data type change.\n                {\n                    const GByte* pabyLocalSrcDataStartLine = nullptr;\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                    int nCurBlockXOff = 0;\n                    int nNextBlockXOff = 0;\n                    toff_t nCurOffset = 0;\n                    for( int x = 0; x \u003c nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                    {\n                        int nSrcPixel = static_cast\u003cint\u003e(dfSrcX);\n                        if( nSrcPixel \u003e= nNextBlockXOff )\n                        {\n                            const int nBlockXOff = nSrcPixel / nBlockXSize;\n                            nCurBlockXOff = nBlockXOff * nBlockXSize;\n                            nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                            const int nBlockId =\n                                nBlockXOff + nBlockYOff * nBlocksPerRow;\n                            nCurOffset = panOffsets[nBlockId];\n                            if( nCurOffset != 0 )\n                            {\n                                pabyLocalSrcDataStartLine =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nBaseByteOffsetInBlock,\n                                        nBlockXSize *\n                                        nBandsPerBlock,\n                                        nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcDataStartLine == nullptr )\n                                    return CE_Failure;\n                            }\n                        }\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n\n                        if( nCurOffset == 0 )\n                        {\n                            REACHED(5);\n                            GDALCopyWords(\n                                \u0026dfNoData, GDT_Float64, 0,\n                                pabyLocalData,\n                                eBufType,\n                                static_cast\u003cint\u003e(nBandSpace),\n                                nBandCount );\n                            pabyLocalData += nPixelSpace;\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataStartLine +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                            REACHED(6);\n                            if( bByteOnly )\n                            {\n                                for( int iBand = 0; iBand \u003c nBands; ++iBand )\n                                    pabyLocalData[iBand] =\n                                        pabyLocalSrcData[iBand];\n                            }\n                            else\n                            {\n                                GDALCopyWords(\n                                    pabyLocalSrcData,\n                                    eDataType, nDTSize,\n                                    pabyLocalData,\n                                    eBufType,\n                                    static_cast\u003cint\u003e(nBandSpace),\n                                    nBandCount );\n                            }\n                            pabyLocalData += nPixelSpace;\n                        }\n                    }\n                }\n            }\n        }\n        else  // Contig, stripped organized.\n        {\n            GByte* pabyData = static_cast\u003cGByte*\u003e(pData);\n            for( int y = 0; y \u003c nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast\u003cint\u003e((y + 0.5) * dfSrcYInc);\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBlockId = nBlockYOff;\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                if( nCurOffset == 0 )\n                {\n                    REACHED(7);\n                    for( int x = 0; x \u003c nBufXSize; ++x )\n                    {\n                        GDALCopyWords(\n                            \u0026dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace + x * nPixelSpace,\n                            eBufType, static_cast\u003cint\u003e(nBandSpace),\n                            nBandCount);\n                    }\n                }\n                else\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    const int nBaseByteOffsetInBlock =\n                        (nYOffsetInBlock * nBlockXSize + nXOff) *\n                        nBandsPerBlockDTSize;\n\n                    if( bNoXResamplingNoTypeChange \u0026\u0026 nBands == nBandCount \u0026\u0026\n                        nPixelSpace == nBandsPerBlockDTSize )\n                    {\n                        REACHED(8);\n                        if( !oFetcher.FetchBytes(\n                               pabyLocalData,\n                               nCurOffset + nBaseByteOffsetInBlock,\n                               nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                               bIsComplex, nBlockId) )\n                        {\n                            return CE_Failure;\n                        }\n                    }\n                    else\n                    {\n                        const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                            nCurOffset + nBaseByteOffsetInBlock,\n                            nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                            bIsComplex, nBlockId);\n                        if( pabyLocalSrcData == nullptr )\n                            return CE_Failure;\n\n                        if( bByteNoXResampling )\n                        {\n                            REACHED(9);\n                            CopyContigByteMultiBand(\n                                pabyLocalSrcData,\n                                nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                static_cast\u003cint\u003e(nPixelSpace),\n                                nBufXSize,\n                                nBandCount);\n                        }\n                        else if( bByteOnly )\n                        {\n                            REACHED(10);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x \u003c nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                const int nSrcPixelMinusXOff =\n                                    static_cast\u003cint\u003e(dfSrcX);\n                                for( int iBand = 0;\n                                     iBand \u003c nBandCount;\n                                     ++iBand )\n                                {\n                                    pabyLocalData[x * nPixelSpace + iBand] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize +\n                                                         iBand];\n                                }\n                            }\n                        }\n                        else\n                        {\n                            REACHED(11);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x \u003c nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                int nSrcPixelMinusXOff =\n                                    static_cast\u003cint\u003e(dfSrcX);\n                                GDALCopyWords(\n                                    pabyLocalSrcData +\n                                    nSrcPixelMinusXOff * nBandsPerBlockDTSize,\n                                    eDataType, nDTSize,\n                                    pabyLocalData + x * nPixelSpace,\n                                    eBufType,\n                                    static_cast\u003cint\u003e(nBandSpace),\n                                    nBandCount );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else  // Non-contig reading case.\n    {\n        if( !FetchBuffer::bMinimizeIO \u0026\u0026 TIFFIsTiled( hTIFF ) )\n        {\n            for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* const pabyData =\n                    static_cast\u003cGByte*\u003e(pData) + iBand * nBandSpace;\n                for( int y = 0; y \u003c nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast\u003cint\u003e((y + 0.5) * dfSrcYInc);\n                    const int nBlockYOff = nSrcLine / nBlockYSize;\n                    const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n\n                    int nBaseByteOffsetInBlock =\n                        nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                    if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                    {\n                        REACHED(12);\n                        nBaseByteOffsetInBlock += (nBand - 1) * nDTSize;\n                    }\n                    else\n                    {\n                        REACHED(13);\n                    }\n\n                    if( bNoXResampling )\n                    {\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        int nBlockXOff = nXOff / nBlockXSize;\n                        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(14);\n                            nBlockId += nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(15);\n                        }\n                        int nXOffsetInBlock = nXOff % nBlockXSize;\n\n                        int x = 0;\n                        while( x \u003c nBufXSize )\n                        {\n                            const int nByteOffsetInBlock =\n                                nBaseByteOffsetInBlock +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n                            const toff_t nCurOffset = panOffsets[nBlockId];\n                            const int nUsedBlockWidth =\n                                std::min(\n                                    nBlockXSize - nXOffsetInBlock,\n                                    nBufXSize - x );\n                            int nIters = nUsedBlockWidth;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(16);\n                                GDALCopyWords(\n                                    \u0026dfNoData, GDT_Float64, 0,\n                                    pabyLocalData, eBufType,\n                                    static_cast\u003cint\u003e(nPixelSpace),\n                                    nIters);\n                                pabyLocalData += nIters * nPixelSpace;\n                            }\n                            else\n                            {\n                                if( bNoTypeChange \u0026\u0026\n                                    nPixelSpace == nBandsPerBlockDTSize )\n                                {\n                                    REACHED(17);\n                                    if( !oFetcher.FetchBytes(\n                                           pabyLocalData,\n                                           nCurOffset + nByteOffsetInBlock,\n                                           (nIters - 1) * nBandsPerBlock + 1,\n                                           nDTSize,\n                                           bIsByteSwapped, bIsComplex,\n                                           nBlockId) )\n                                    {\n                                        return CE_Failure;\n                                    }\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    const GByte* pabyLocalSrcData =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nByteOffsetInBlock,\n                                            (nIters - 1) * nBandsPerBlock + 1,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId );\n                                    if( pabyLocalSrcData == nullptr )\n                                        return CE_Failure;\n\n                                    REACHED(18);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData, eDataType,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData, eBufType,\n                                        static_cast\u003cint\u003e(nPixelSpace),\n                                        nIters );\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                            }\n\n                            nXOffsetInBlock = 0;\n                            ++nBlockXOff;\n                            ++nBlockId;\n                            x += nUsedBlockWidth;\n                        }\n                    }\n                    else\n                    {\n                        // Non-contig reading, tiled, potential resampling and\n                        // data type change.\n\n                        const GByte* pabyLocalSrcDataStartLine = nullptr;\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                        int nCurBlockXOff = 0;\n                        int nNextBlockXOff = 0;\n                        toff_t nCurOffset = 0;\n                        for( int x = 0; x \u003c nBufXSize; ++x, dfSrcX += dfSrcXInc)\n                        {\n                            const int nSrcPixel = static_cast\u003cint\u003e(dfSrcX);\n                            if( nSrcPixel \u003e= nNextBlockXOff )\n                            {\n                                const int nBlockXOff = nSrcPixel / nBlockXSize;\n                                nCurBlockXOff = nBlockXOff * nBlockXSize;\n                                nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                                int nBlockId =\n                                    nBlockXOff + nBlockYOff * nBlocksPerRow;\n                                if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                                {\n                                    REACHED(19);\n                                    nBlockId += nBlocksPerBand * (nBand - 1);\n                                }\n                                else\n                                {\n                                    REACHED(20);\n                                }\n                                nCurOffset = panOffsets[nBlockId];\n                                if( nCurOffset != 0 )\n                                {\n                                    pabyLocalSrcDataStartLine =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nBaseByteOffsetInBlock,\n                                            nBlockXSize * nBandsPerBlock,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId);\n                                    if( pabyLocalSrcDataStartLine == nullptr )\n                                        return CE_Failure;\n                                }\n                            }\n                            const int nXOffsetInBlock =\n                                nSrcPixel - nCurBlockXOff;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(21);\n                                GDALCopyWords( \u0026dfNoData, GDT_Float64, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                                pabyLocalData += nPixelSpace;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    pabyLocalSrcDataStartLine +\n                                    nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                                REACHED(22);\n                                if( bByteOnly )\n                                {\n                                    *pabyLocalData = *pabyLocalSrcData;\n                                }\n                                else\n                                {\n                                    GDALCopyWords(pabyLocalSrcData,\n                                                eDataType, 0,\n                                                pabyLocalData,\n                                                eBufType, 0,\n                                                1);\n                                }\n                                pabyLocalData += nPixelSpace;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else  // Non-contig reading, stripped.\n        {\n            for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* pabyData =\n                    static_cast\u003cGByte *\u003e(pData) + iBand * nBandSpace;\n                for( int y = 0; y \u003c nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast\u003cint\u003e((y + 0.5) * dfSrcYInc);\n                    const int nBlockYOff = nSrcLine / nBlockYSize;\n                    const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                    int nBlockId = nBlockYOff;\n                    if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    {\n                        REACHED(23);\n                        nBlockId += nBlocksPerBand * (nBand - 1);\n                    }\n                    else\n                    {\n                        REACHED(24);\n                    }\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(25);\n                        GDALCopyWords(\n                            \u0026dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace,\n                            eBufType,\n                            static_cast\u003cint\u003e(nPixelSpace),\n                            nBufXSize);\n                    }\n                    else\n                    {\n                        int nBaseByteOffsetInBlock =\n                            (nYOffsetInBlock * nBlockXSize + nXOff) *\n                            nBandsPerBlockDTSize;\n                        if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                            nBaseByteOffsetInBlock += (nBand - 1) * nDTSize;\n\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        if( bNoXResamplingNoTypeChange \u0026\u0026\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(26);\n                            if( !oFetcher.FetchBytes(\n                                pabyLocalData,\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId) )\n                            {\n                                return CE_Failure;\n                            }\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcData == nullptr )\n                                return CE_Failure;\n\n                            if( bNoXResamplingNoTypeChange )\n                            {\n                                REACHED(27);\n                                GDALCopyWords(pabyLocalSrcData,\n                                              eDataType, nBandsPerBlockDTSize,\n                                              pabyLocalData, eBufType,\n                                              static_cast\u003cint\u003e(nPixelSpace),\n                                              nBufXSize);\n                            }\n                            else if( bByteOnly )\n                            {\n                                REACHED(28);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x \u003c nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast\u003cint\u003e(dfSrcX);\n                                    pabyLocalData[x * nPixelSpace] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize];\n                                }\n                            }\n                            else\n                            {\n                                REACHED(29);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x \u003c nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast\u003cint\u003e(dfSrcX);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData +\n                                        nSrcPixelMinusXOff *\n                                        nBandsPerBlockDTSize,\n                                        eDataType, 0,\n                                        pabyLocalData + x * nPixelSpace,\n                                        eBufType, 0,\n                                        1 );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffDataset::DirectIO( GDALRWFlag eRWFlag,\n                            int nXOff, int nYOff, int nXSize, int nYSize,\n                            void * pData, int nBufXSize, int nBufYSize,\n                            GDALDataType eBufType,\n                            int nBandCount, int *panBandMap,\n                            GSpacing nPixelSpace, GSpacing nLineSpace,\n                            GSpacing nBandSpace,\n                            GDALRasterIOExtraArg* psExtraArg )\n{\n    const GDALDataType eDataType = GetRasterBand(1)-\u003eGetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read \u0026\u0026\n          nCompression == COMPRESSION_NONE \u0026\u0026\n          (nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           nPhotometric == PHOTOMETRIC_RGB ||\n           nPhotometric == PHOTOMETRIC_PALETTE) \u0026\u0026\n          nBitsPerSample == nDTSizeBits \u0026\u0026\n          SetDirectory() /* Very important to make hTIFF uptodate! */ ) )\n    {\n        return -1;\n    }\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) \u0026\u0026\n        psExtraArg != nullptr \u0026\u0026\n        psExtraArg-\u003eeResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    // If the file is band interleave or only one band is requested, then\n    // fallback to band DirectIO.\n    bool bUseBandRasterIO = false;\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1 )\n    {\n        bUseBandRasterIO = true;\n    }\n    else\n    {\n        // For simplicity, only deals with \"naturally ordered\" bands.\n        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n        {\n            if( panBandMap[iBand] != iBand + 1)\n            {\n                bUseBandRasterIO = true;\n                break;\n            }\n        }\n    }\n    if( bUseBandRasterIO )\n    {\n        CPLErr eErr = CE_None;\n        for( int iBand = 0; eErr == CE_None \u0026\u0026 iBand \u003c nBandCount; ++iBand )\n        {\n            eErr = GetRasterBand(panBandMap[iBand])-\u003eRasterIO(\n                eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                static_cast\u003cGByte *\u003e(pData) + iBand * nBandSpace,\n                nBufXSize, nBufYSize,\n                eBufType,\n                nPixelSpace, nLineSpace,\n                psExtraArg );\n        }\n        return eErr;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -\u003e %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // No need to look if overviews can satisfy the request as it has already */\n    // been done in GTiffDataset::IRasterIO().\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( GetAccess() == GA_Update )\n    {\n        FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( hTIFF ) );\n    }\n\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            const int nDTSize = nDTSizeBits / 8;\n            m_nTempBufferForCommonDirectIOSize =\n                static_cast\u003csize_t\u003e(nBlockXSize * nBlockYSize * nDTSize *\n                ((nPlanarConfig == PLANARCONFIG_CONTIG) ? nBands : 1));\n\n            m_pTempBufferForCommonDirectIO =\n                static_cast\u003cGByte *\u003e(\n                    VSI_MALLOC_VERBOSE(m_nTempBufferForCommonDirectIOSize) );\n            if( m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_pTempBufferForCommonDirectIO,\n                                     m_nTempBufferForCommonDirectIOSize);\n\n        return CommonDirectIO( oFetcher,\n                               nXOff, nYOff, nXSize, nYSize,\n                               pData, nBufXSize, nBufYSize,\n                               eBufType,\n                               nBandCount, panBandMap,\n                               nPixelSpace, nLineSpace,\n                              nBandSpace );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, \u0026panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    void** ppData =\n        static_cast\u003cvoid **\u003e( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets =\n        static_cast\u003cvsi_l_offset *\u003e(\n            VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes =\n        static_cast\u003csize_t *\u003e( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands = nBands;\n    const int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n    {\n        eErr = CE_Failure;\n    }\n    // For now we always allocate a temp buffer as it is easier.\n    else\n        // if( nXSize != nBufXSize || nYSize != nBufYSize ||\n        //   eBufType != eDataType ||\n        //   nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n        //   check if the user buffer is large enough )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast\u003cdouble\u003e( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None \u0026\u0026 iLine \u003c nReqYSize; ++iLine )\n    {\n        ppData[iLine] =\n            static_cast\u003cGByte *\u003e(pTmpBuffer) +\n            iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize \u003c nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast\u003cint\u003e((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0)  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL(nReqYSize, ppData, panOffsets, panSizes, fp);\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None \u0026\u0026 TIFFIsByteSwapped(hTIFF) )\n    {\n        for( int iLine = 0; iLine \u003c nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2);\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize);\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast\u003cdouble\u003e( nBufXSize );\n    if( eErr == CE_None \u0026\u0026 pTmpBuffer != nullptr )\n    {\n        for( int iY = 0; iY \u003c nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize \u003c= nYSize ?\n                iY : static_cast\u003cint\u003e((iY + 0.5) * dfSrcYInc);\n            // Optimization: no resampling, no data type change, number of\n            // bands requested == number of bands and buffer is packed\n            // pixel-interleaved.\n            if( nBufXSize == nXSize \u0026\u0026 nContigBands == nBandCount \u0026\u0026\n                eDataType == eBufType \u0026\u0026\n                nBandSpace == nDTSize \u0026\u0026\n                nPixelSpace == nBandCount * nBandSpace )\n            {\n                memcpy(\n                    static_cast\u003cGByte *\u003e(pData) + iY * nLineSpace,\n                    ppData[iSrcY],\n                    static_cast\u003csize_t\u003e(nReqXSize * nPixelSpace) );\n            }\n            // Other optimization: no resampling, no data type change,\n            // data type is Byte.\n            else if( nBufXSize == nXSize \u0026\u0026\n                     eDataType == eBufType \u0026\u0026 eDataType == GDT_Byte )\n            {\n                GByte* pabySrcData = static_cast\u003cGByte *\u003e(ppData[iSrcY]);\n                GByte* pabyDstData =\n                    static_cast\u003cGByte *\u003e(pData) + iY * nLineSpace;\n                if( nBandSpace == 1 \u0026\u0026 nPixelSpace \u003e nBandCount )\n                {\n                    // Buffer is pixel-interleaved (with some stridding\n                    // between pixels).\n                    CopyContigByteMultiBand( pabySrcData, nSrcPixelSize,\n                                             pabyDstData,\n                                             static_cast\u003cint\u003e(nPixelSpace),\n                                             nBufXSize, nBandCount );\n                }\n                else\n                {\n                    for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                    {\n                        GDALCopyWords(\n                            pabySrcData + iBand, GDT_Byte, nSrcPixelSize,\n                            pabyDstData + iBand * nBandSpace,\n                            GDT_Byte, static_cast\u003cint\u003e(nPixelSpace),\n                            nBufXSize );\n                    }\n                }\n            }\n            else  // General case.\n            {\n                for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                {\n                    GByte* pabySrcData =\n                        static_cast\u003cGByte *\u003e(ppData[iSrcY]) + iBand * nDTSize;\n                    GByte* pabyDstData =\n                        static_cast\u003cGByte *\u003e(pData) +\n                        iBand * nBandSpace + iY * nLineSpace;\n                    if( eDataType == GDT_Byte \u0026\u0026 eBufType == GDT_Byte )\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX \u003c nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast\u003cint\u003e(dfSrcX);\n                            pabyDstData[iX * nPixelSpace] =\n                                pabySrcData[iSrcX * nSrcPixelSize];\n                        }\n                    }\n                    else\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX \u003c nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast\u003cint\u003e(dfSrcX);\n                            GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                        eDataType, 0,\n                                        pabyDstData + iX * nPixelSpace,\n                                        eBufType, 0, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                         CacheMultiRange()                            */\n/************************************************************************/\n\nvoid* GTiffRasterBand::CacheMultiRange( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nBufXSize, int nBufYSize,\n                                        GDALRasterIOExtraArg* psExtraArg )\n{\n    void* pBufferedData = nullptr;\n    // Same logic as in GDALRasterBand::IRasterIO()\n    double dfXOff = nXOff;\n    double dfYOff = nYOff;\n    double dfXSize = nXSize;\n    double dfYSize = nYSize;\n    if( psExtraArg-\u003ebFloatingPointWindowValidity )\n    {\n        dfXOff = psExtraArg-\u003edfXOff;\n        dfYOff = psExtraArg-\u003edfYOff;\n        dfXSize = psExtraArg-\u003edfXSize;\n        dfYSize = psExtraArg-\u003edfYSize;\n    }\n    const double dfSrcXInc = dfXSize / static_cast\u003cdouble\u003e( nBufXSize );\n    const double dfSrcYInc = dfYSize / static_cast\u003cdouble\u003e( nBufYSize );\n    const double EPS = 1e-10;\n    const int nBlockX1 = static_cast\u003cint\u003e(std::max(0.0, (0+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY1 = static_cast\u003cint\u003e(std::max(0.0, (0+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n    const int nBlockX2 = static_cast\u003cint\u003e(std::min(static_cast\u003cdouble\u003e(nRasterXSize - 1), (nBufXSize-1+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY2 = static_cast\u003cint\u003e(std::min(static_cast\u003cdouble\u003e(nRasterYSize - 1), (nBufYSize-1+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n\n    thandle_t th = TIFFClientdata( poGDS-\u003ehTIFF );\n    if( poGDS-\u003eSetDirectory() \u0026\u0026 !VSI_TIFFHasCachedRanges(th) )\n    {\n        std::vector\u003c std::pair\u003cvsi_l_offset, size_t\u003e \u003e aOffsetSize;\n        size_t nTotalSize = 0;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        const unsigned int nMaxRawBlockCacheSize =\n            atoi(CPLGetConfigOption(\"GDAL_MAX_RAW_BLOCK_CACHE_SIZE\",\n                                    \"10485760\"));\n        for( int iY = nBlockY1; iY \u003c= nBlockY2; iY ++)\n        {\n            for( int iX = nBlockX1; iX \u003c= nBlockX2; iX ++)\n            {\n                GDALRasterBlock* poBlock = TryGetLockedBlockRef(iX, iY);\n                if( poBlock != nullptr )\n                {\n                    poBlock-\u003eDropLock();\n                    continue;\n                }\n                int nBlockId = iX + iY * nBlocksPerRow;\n                if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n                    nBlockId += (nBand - 1) * poGDS-\u003enBlocksPerBand;\n                vsi_l_offset nOffset = 0;\n                vsi_l_offset nSize = 0;\n                if( poGDS-\u003eIsBlockAvailable(nBlockId, \u0026nOffset, \u0026nSize) )\n                {\n                    if( nTotalSize + nSize \u003c nMaxRawBlockCacheSize )\n                    {\n#ifdef DEBUG_VERBOSE\n                        CPLDebug(\"GTiff\",\n                                 \"Precaching for block (%d, %d), \"\n                                 CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB,\n                                 iX, iY,\n                                 nOffset,\n                                 nOffset + static_cast\u003csize_t\u003e(nSize) - 1);\n#endif\n                        aOffsetSize.push_back(\n                            std::pair\u003cvsi_l_offset, size_t\u003e\n                                (nOffset, static_cast\u003csize_t\u003e(nSize)) );\n                        nTotalSize += static_cast\u003csize_t\u003e(nSize);\n                    }\n                }\n            }\n        }\n\n        std::sort(aOffsetSize.begin(), aOffsetSize.end());\n\n        if( nTotalSize \u003e 0 )\n        {\n            pBufferedData = VSI_MALLOC_VERBOSE(nTotalSize);\n            if( pBufferedData )\n            {\n                std::vector\u003cvsi_l_offset\u003e anOffsets;\n                std::vector\u003csize_t\u003e anSizes;\n                std::vector\u003cvoid*\u003e apData;\n                size_t nAccOffset = 0;\n                for( size_t i = 0; i \u003c aOffsetSize.size(); i++ )\n                {\n                    anOffsets.push_back(aOffsetSize[i].first);\n                    anSizes.push_back(aOffsetSize[i].second);\n                    apData.push_back(static_cast\u003cGByte*\u003e(pBufferedData) + nAccOffset);\n                    nAccOffset += aOffsetSize[i].second;\n                }\n                VSILFILE* fp = VSI_TIFFGetVSILFile(th);\n                if( VSIFReadMultiRangeL(\n                                    static_cast\u003cint\u003e(aOffsetSize.size()),\n                                    \u0026apData[0],\n                                    \u0026anOffsets[0],\n                                    \u0026anSizes[0],\n                                    fp ) == 0 )\n                {\n                    VSI_TIFFSetCachedRanges( th,\n                                             static_cast\u003cint\u003e(aOffsetSize.size()),\n                                             \u0026apData[0],\n                                             \u0026anOffsets[0],\n                                             \u0026anSizes[0] );\n                }\n            }\n        }\n    }\n    return pBufferedData;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IRasterIO( GDALRWFlag eRWFlag,\n                                   int nXOff, int nYOff, int nXSize, int nYSize,\n                                   void * pData, int nBufXSize, int nBufYSize,\n                                   GDALDataType eBufType,\n                                   GSpacing nPixelSpace, GSpacing nLineSpace,\n                                   GDALRasterIOExtraArg* psExtraArg )\n{\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"RasterIO(%d, %d, %d, %d, %d, %d)\",\n              nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize );\n#endif\n\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize \u003c nXSize \u0026\u0026 nBufYSize \u003c nYSize )\n    {\n        int bTried = FALSE;\n        ++poGDS-\u003enJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nPixelSpace, nLineSpace,\n                                 psExtraArg,\n                                 \u0026bTried );\n        --poGDS-\u003enJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( poGDS-\u003eeVirtualMemIOUsage != VIRTUAL_MEM_IO_NO )\n    {\n        const int nErr = poGDS-\u003eVirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            1, \u0026nBand, nPixelSpace, nLineSpace, 0, psExtraArg);\n        if( nErr \u003e= 0 )\n            return static_cast\u003cCPLErr\u003e(nErr);\n    }\n    if( poGDS-\u003ebDirectIO )\n    {\n        int nErr = DirectIO(eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                            pData, nBufXSize, nBufYSize, eBufType,\n                            nPixelSpace, nLineSpace, psExtraArg);\n        if( nErr \u003e= 0 )\n            return static_cast\u003cCPLErr\u003e(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( poGDS-\u003eeAccess == GA_ReadOnly \u0026\u0026\n        eRWFlag == GF_Read \u0026\u0026\n        poGDS-\u003eHasOptimizedReadMultiRange() )\n    {\n        pBufferedData = CacheMultiRange(nXOff, nYOff, nXSize, nYSize,\n                                        nBufXSize, nBufYSize,\n                                        psExtraArg);\n    }\n\n    if( poGDS-\u003enBands != 1 \u0026\u0026\n        poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        eRWFlag == GF_Read \u0026\u0026\n        nXSize == nBufXSize \u0026\u0026 nYSize == nBufYSize )\n    {\n        const int nBlockX1 = nXOff / nBlockXSize;\n        const int nBlockY1 = nYOff / nBlockYSize;\n        const int nBlockX2 = (nXOff + nXSize - 1) / nBlockXSize;\n        const int nBlockY2 = (nYOff + nYSize - 1) / nBlockYSize;\n        const int nXBlocks = nBlockX2 - nBlockX1 + 1;\n        const int nYBlocks = nBlockY2 - nBlockY1 + 1;\n        const GIntBig nRequiredMem =\n            static_cast\u003cGIntBig\u003e(poGDS-\u003enBands) * nXBlocks * nYBlocks *\n            nBlockXSize * nBlockYSize *\n            GDALGetDataTypeSizeBytes(eDataType);\n        if( nRequiredMem \u003e GDALGetCacheMax64() )\n        {\n            if( !poGDS-\u003ebHasWarnedDisableAggressiveBandCaching )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Disable aggressive band caching. \"\n                          \"Cache not big enough. \"\n                          \"At least \" CPL_FRMT_GIB \" bytes necessary\",\n                          nRequiredMem );\n                poGDS-\u003ebHasWarnedDisableAggressiveBandCaching = true;\n            }\n            poGDS-\u003ebLoadingOtherBands = true;\n        }\n    }\n\n    ++poGDS-\u003enJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamRasterBand::IRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                      pData, nBufXSize, nBufYSize, eBufType,\n                                      nPixelSpace, nLineSpace, psExtraArg );\n    --poGDS-\u003enJPEGOverviewVisibilityCounter;\n\n    poGDS-\u003ebLoadingOtherBands = false;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( poGDS-\u003ehTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRasterBand::IGetDataCoverageStatus( int nXOff, int nYOff,\n                                             int nXSize, int nYSize,\n                                             int nMaskFlagStop,\n                                             double* pdfDataPct)\n{\n    if( eAccess == GA_Update )\n        poGDS-\u003eFlushCache();\n\n    if( !poGDS-\u003eSetDirectory() )\n    {\n        return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n               GDAL_DATA_COVERAGE_STATUS_DATA;\n    }\n\n    const int iXBlockStart = nXOff / nBlockXSize;\n    const int iXBlockEnd = (nXOff + nXSize - 1) / nBlockXSize;\n    const int iYBlockStart = nYOff / nBlockYSize;\n    const int iYBlockEnd = (nYOff + nYSize - 1) / nBlockYSize;\n    int nStatus = 0;\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS-\u003ehTIFF ));\n    GIntBig nPixelsData = 0;\n    // We need to compute this here as it might not have been computed\n    // previously (which sucks...)\n    nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    for( int iY = iYBlockStart; iY \u003c= iYBlockEnd; ++iY )\n    {\n        for( int iX = iXBlockStart; iX \u003c= iXBlockEnd; ++iX )\n        {\n            const int nBlockIdBand0 =\n                iX + iY * nBlocksPerRow;\n            int nBlockId = nBlockIdBand0;\n            if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n                nBlockId = nBlockIdBand0 + (nBand - 1) * poGDS-\u003enBlocksPerBand;\n            vsi_l_offset nOffset = 0;\n            vsi_l_offset nLength = 0;\n            bool bHasData = false;\n            if( !poGDS-\u003eIsBlockAvailable(nBlockId,\u0026nOffset,\u0026nLength) )\n            {\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n            }\n            else\n            {\n                if( poGDS-\u003enCompression == COMPRESSION_NONE \u0026\u0026\n                    poGDS-\u003eeAccess == GA_ReadOnly \u0026\u0026\n                    (!bNoDataSet || dfNoDataValue == 0.0) )\n                {\n                    VSIRangeStatus eStatus =\n                          VSIFGetRangeStatusL( fp, nOffset, nLength );\n                    if( eStatus == VSI_RANGE_STATUS_HOLE )\n                    {\n                        nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n                    }\n                    else\n                    {\n                        bHasData = true;\n                    }\n                }\n                else\n                {\n                    bHasData = true;\n                }\n            }\n            if( bHasData )\n            {\n                const int nXBlockRight =\n                    ( iX * nBlockXSize \u003e INT_MAX - nBlockXSize ) ? INT_MAX :\n                    (iX + 1) * nBlockXSize;\n                const int nYBlockBottom =\n                    ( iY * nBlockYSize \u003e INT_MAX - nBlockYSize ) ? INT_MAX :\n                    (iY + 1) * nBlockYSize;\n\n                nPixelsData +=\n                    (std::min( nXBlockRight, nXOff + nXSize ) -\n                     std::max( iX * nBlockXSize, nXOff )) *\n                    (std::min( nYBlockBottom, nYOff + nYSize ) -\n                     std::max( iY * nBlockYSize, nYOff ));\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_DATA;\n            }\n            if( nMaskFlagStop != 0 \u0026\u0026 (nMaskFlagStop \u0026 nStatus) != 0 )\n            {\n                if( pdfDataPct )\n                    *pdfDataPct = -1.0;\n                return nStatus;\n            }\n        }\n    }\n    if( pdfDataPct )\n        *pdfDataPct =\n          100.0 * nPixelsData /\n          (static_cast\u003cGIntBig\u003e(nXSize) * nYSize);\n    return nStatus;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    if( !poGDS-\u003eSetDirectory() )\n        return CE_Failure;\n\n    int nBlockBufSize = 0;\n    if( TIFFIsTiled(poGDS-\u003ehTIFF) )\n    {\n        nBlockBufSize = static_cast\u003cint\u003e(TIFFTileSize( poGDS-\u003ehTIFF ));\n    }\n    else\n    {\n        CPLAssert( nBlockXOff == 0 );\n        nBlockBufSize = static_cast\u003cint\u003e(TIFFStripSize( poGDS-\u003ehTIFF ));\n    }\n\n    CPLAssert(nBlocksPerRow != 0);\n    const int nBlockIdBand0 =\n        nBlockXOff + nBlockYOff * nBlocksPerRow;\n    int nBlockId = nBlockIdBand0;\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId = nBlockIdBand0 + (nBand - 1) * poGDS-\u003enBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    int nBlockReqSize = nBlockBufSize;\n\n    if( nBlockYOff * nBlockYSize \u003e nRasterYSize - nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize)\n            * (nBlockYSize - static_cast\u003cint\u003e(\n                (static_cast\u003cGIntBig\u003e(nBlockYOff + 1) * nBlockYSize)\n                    % nRasterYSize));\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip or tile that doesn't exist yet.      */\n/*      Just set to zeros and return.                                   */\n/* -------------------------------------------------------------------- */\n    vsi_l_offset nOffset = 0;\n    bool bErrOccurred = false;\n    if( nBlockId != poGDS-\u003enLoadedBlock \u0026\u0026\n        !poGDS-\u003eIsBlockAvailable(nBlockId, \u0026nOffset, nullptr, \u0026bErrOccurred) )\n    {\n        NullBlock( pImage );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    if( poGDS-\u003ebStreamingIn \u0026\u0026\n        !(poGDS-\u003enBands \u003e 1 \u0026\u0026\n          poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n          nBlockId == poGDS-\u003enLoadedBlock) )\n    {\n        if( nOffset \u003c VSIFTellL(poGDS-\u003efpL) )\n        {\n            CPLError( CE_Failure, CPLE_NotSupported,\n                      \"Trying to load block %d at offset \" CPL_FRMT_GUIB\n                      \" whereas current pos is \" CPL_FRMT_GUIB\n                      \" (backward read not supported)\",\n                      nBlockId, static_cast\u003cGUIntBig\u003e(nOffset),\n                      static_cast\u003cGUIntBig\u003e(VSIFTellL(poGDS-\u003efpL)) );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case (separate, onesampleperpixel)                */\n/* -------------------------------------------------------------------- */\n    if( poGDS-\u003enBands == 1\n        || poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        if( nBlockReqSize \u003c nBlockBufSize )\n            memset( pImage, 0, nBlockBufSize );\n\n        CPLErr eErr = CE_None;\n        if( TIFFIsTiled( poGDS-\u003ehTIFF ) )\n        {\n            if( TIFFReadEncodedTile( poGDS-\u003ehTIFF, nBlockId, pImage,\n                                     nBlockReqSize ) == -1\n                \u0026\u0026 !poGDS-\u003ebIgnoreReadErrors )\n            {\n                memset( pImage, 0, nBlockBufSize );\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadEncodedTile() failed.\" );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if( TIFFReadEncodedStrip( poGDS-\u003ehTIFF, nBlockId, pImage,\n                                      nBlockReqSize ) == -1\n                \u0026\u0026 !poGDS-\u003ebIgnoreReadErrors )\n            {\n                memset( pImage, 0, nBlockBufSize );\n                CPLError( CE_Failure, CPLE_AppDefined,\n                        \"TIFFReadEncodedStrip() failed.\" );\n\n                eErr = CE_Failure;\n            }\n        }\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load desired block                                              */\n/* -------------------------------------------------------------------- */\n    {\n        const CPLErr eErr = poGDS-\u003eLoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n        {\n            memset( pImage, 0,\n                    nBlockXSize * nBlockYSize\n                    * GDALGetDataTypeSizeBytes(eDataType) );\n            return eErr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for YCbCr subsampled data.                         */\n/* -------------------------------------------------------------------- */\n\n    // Removed \"Special case for YCbCr\" added in r9432; disabled in r9470\n\n    const int nWordBytes = poGDS-\u003enBitsPerSample / 8;\n    GByte* pabyImage = poGDS-\u003epabyBlockBuf + (nBand - 1) * nWordBytes;\n\n    GDALCopyWords(pabyImage, eDataType, poGDS-\u003enBands * nWordBytes,\n                  pImage, eDataType, nWordBytes,\n                  nBlockXSize * nBlockYSize);\n\n    const CPLErr eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       FillCacheForOtherBands()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::FillCacheForOtherBands( int nBlockXOff, int nBlockYOff )\n\n{\n/* -------------------------------------------------------------------- */\n/*      In the fairly common case of pixel interleaved 8bit data        */\n/*      that is multi-band, lets push the rest of the data into the     */\n/*      block cache too, to avoid (hopefully) having to redecode it.    */\n/*                                                                      */\n/*      Our following logic actually depends on the fact that the       */\n/*      this block is already loaded, so subsequent calls will end      */\n/*      up back in this method and pull from the loaded block.          */\n/*                                                                      */\n/*      Be careful not entering this portion of code from               */\n/*      the other bands, otherwise we'll get very deep nested calls     */\n/*      and O(nBands^2) performance !                                   */\n/*                                                                      */\n/*      If there are many bands and the block cache size is not big     */\n/*      enough to accommodate the size of all the blocks, don't enter   */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( poGDS-\u003enBands != 1 \u0026\u0026\n        poGDS-\u003enBands \u003c 128 \u0026\u0026 // avoid caching for datasets with too many bands\n        !poGDS-\u003ebLoadingOtherBands \u0026\u0026\n        nBlockXSize * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType) \u003c\n        GDALGetCacheMax64() / poGDS-\u003enBands )\n    {\n        poGDS-\u003ebLoadingOtherBands = true;\n\n        for( int iOtherBand = 1; iOtherBand \u003c= poGDS-\u003enBands; ++iOtherBand )\n        {\n            if( iOtherBand == nBand )\n                continue;\n\n            GDALRasterBlock *poBlock = poGDS-\u003eGetRasterBand(iOtherBand)-\u003e\n                GetLockedBlockRef(nBlockXOff,nBlockYOff);\n            if( poBlock == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n            poBlock-\u003eDropLock();\n        }\n\n        poGDS-\u003ebLoadingOtherBands = false;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    if( poGDS-\u003ebDebugDontWriteBlocks )\n        return CE_None;\n\n    if( poGDS-\u003ebWriteErrorInFlushBlockBuf )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        poGDS-\u003ebWriteErrorInFlushBlockBuf = false;\n        return CE_Failure;\n    }\n\n    if( !poGDS-\u003eSetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( poGDS != nullptr\n               \u0026\u0026 nBlockXOff \u003e= 0\n               \u0026\u0026 nBlockYOff \u003e= 0\n               \u0026\u0026 pImage != nullptr );\n    CPLAssert(nBlocksPerRow != 0);\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE\n        || poGDS-\u003enBands == 1 )\n    {\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow\n            + (nBand - 1) * poGDS-\u003enBlocksPerBand;\n\n        const CPLErr eErr =\n            poGDS-\u003eWriteEncodedTileOrStrip(nBlockId, pImage, true);\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n     // Why 10 ? Somewhat arbitrary\n    constexpr int MAX_BANDS_FOR_DIRTY_CHECK = 10;\n    GDALRasterBlock* apoBlocks[MAX_BANDS_FOR_DIRTY_CHECK] = {};\n    const int nBands = poGDS-\u003enBands;\n    bool bAllBlocksDirty = false;\n\n/* -------------------------------------------------------------------- */\n/*     If all blocks are cached and dirty then we do not need to reload */\n/*     the tile/strip from disk                                         */\n/* -------------------------------------------------------------------- */\n    if( nBands \u003c= MAX_BANDS_FOR_DIRTY_CHECK )\n    {\n        bAllBlocksDirty = true;\n        for( int iBand = 0; iBand \u003c nBands; ++iBand )\n        {\n            if( iBand + 1 != nBand )\n            {\n                apoBlocks[iBand] =\n                    cpl::down_cast\u003cGTiffRasterBand *\u003e(\n                        poGDS-\u003eGetRasterBand( iBand + 1 ))\n                            -\u003eTryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n                if( apoBlocks[iBand] == nullptr )\n                {\n                    bAllBlocksDirty = false;\n                }\n                else if( !apoBlocks[iBand]-\u003eGetDirty() )\n                {\n                    apoBlocks[iBand]-\u003eDropLock();\n                    apoBlocks[iBand] = nullptr;\n                    bAllBlocksDirty = false;\n                }\n            }\n            else\n                apoBlocks[iBand] = nullptr;\n        }\n#if DEBUG_VERBOSE\n        if( bAllBlocksDirty )\n            CPLDebug(\"GTIFF\", \"Saved reloading block %d\", nBlockId);\n        else\n            CPLDebug(\"GTIFF\", \"Must reload block %d\", nBlockId);\n#endif\n    }\n\n    {\n        const CPLErr eErr = poGDS-\u003eLoadBlockBuf( nBlockId, !bAllBlocksDirty );\n        if( eErr != CE_None )\n        {\n            if( nBands \u003c= MAX_BANDS_FOR_DIRTY_CHECK )\n            {\n                for( int iBand = 0; iBand \u003c nBands; ++iBand )\n                {\n                    if( apoBlocks[iBand] != nullptr )\n                        apoBlocks[iBand]-\u003eDropLock();\n                }\n            }\n            return eErr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    const int nWordBytes = poGDS-\u003enBitsPerSample / 8;\n\n    for( int iBand = 0; iBand \u003c nBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast\u003cGByte *\u003e( pImage );\n        }\n        else\n        {\n            if( nBands \u003c= MAX_BANDS_FOR_DIRTY_CHECK )\n                poBlock = apoBlocks[iBand];\n            else\n                poBlock = cpl::down_cast\u003cGTiffRasterBand *\u003e(\n                    poGDS-\u003eGetRasterBand( iBand + 1 ))\n                        -\u003eTryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock-\u003eGetDirty() )\n            {\n                poBlock-\u003eDropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast\u003cGByte *\u003e( poBlock-\u003eGetDataRef() );\n        }\n\n        GByte *pabyOut = poGDS-\u003epabyBlockBuf + iBand*nWordBytes;\n\n        GDALCopyWords(pabyThisImage, eDataType, nWordBytes,\n                      pabyOut, eDataType, nWordBytes * nBands,\n                      nBlockXSize * nBlockYSize);\n\n        if( poBlock != nullptr )\n        {\n            poBlock-\u003eMarkClean();\n            poBlock-\u003eDropLock();\n        }\n    }\n\n    if( bAllBlocksDirty )\n    {\n        // We can synchronously write the block now.\n        const CPLErr eErr =\n            poGDS-\u003eWriteEncodedTileOrStrip(nBlockId, poGDS-\u003epabyBlockBuf, true);\n        poGDS-\u003ebLoadedBlockDirty = false;\n        return eErr;\n    }\n\n    poGDS-\u003ebLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           SetDescription()                           */\n/************************************************************************/\n\nvoid GTiffRasterBand::SetDescription( const char *pszDescription )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( pszDescription == nullptr )\n        pszDescription = \"\";\n\n    if( osDescription != pszDescription )\n        poGDS-\u003ebMetadataChanged = true;\n\n    osDescription = pszDescription;\n}\n\n/************************************************************************/\n/*                           GetDescription()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetDescription() const\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    return osDescription;\n}\n\n/************************************************************************/\n/*                             GetOffset()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetOffset( int *pbSuccess )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = bHaveOffsetScale;\n    return dfOffset;\n}\n\n/************************************************************************/\n/*                             SetOffset()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetOffset( double dfNewValue )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( !bHaveOffsetScale || dfNewValue != dfOffset )\n        poGDS-\u003ebMetadataChanged = true;\n\n    bHaveOffsetScale = true;\n    dfOffset = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                              GetScale()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetScale( int *pbSuccess )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = bHaveOffsetScale;\n    return dfScale;\n}\n\n/************************************************************************/\n/*                              SetScale()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetScale( double dfNewValue )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( !bHaveOffsetScale || dfNewValue != dfScale )\n        poGDS-\u003ebMetadataChanged = true;\n\n    bHaveOffsetScale = true;\n    dfScale = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            GetUnitType()                             */\n/************************************************************************/\n\nconst char* GTiffRasterBand::GetUnitType()\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    if( osUnitType.empty() )\n    {\n        poGDS-\u003eLookForProjection();\n        return poGDS-\u003em_osVertUnit.c_str();\n    }\n\n    return osUnitType.c_str();\n}\n\n/************************************************************************/\n/*                           SetUnitType()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetUnitType( const char* pszNewValue )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    CPLString osNewValue(pszNewValue ? pszNewValue : \"\");\n    if( osNewValue.compare(osUnitType) != 0 )\n        poGDS-\u003ebMetadataChanged = true;\n\n    osUnitType = osNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadataDomainList()\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    return CSLDuplicate(oGTiffMDMD.GetDomainList());\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( poGDS-\u003ebStreamingOut \u0026\u0026 poGDS-\u003ebCrystalized )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        if( papszMD != nullptr || GetMetadata(pszDomain) != nullptr )\n        {\n            poGDS-\u003ebMetadataChanged = true;\n            // Cancel any existing metadata from PAM file.\n            if( eAccess == GA_Update \u0026\u0026\n                GDALPamRasterBand::GetMetadata(pszDomain) != nullptr )\n                GDALPamRasterBand::SetMetadata(nullptr, pszDomain);\n        }\n    }\n\n    return oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetMetadataItem( const char * pszName,\n                                              const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszName != nullptr \u0026\u0026 pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"TIFF\") )\n    {\n        int nBlockXOff = 0;\n        int nBlockYOff = 0;\n\n        if( EQUAL(pszName, \"JPEGTABLES\") )\n        {\n            if( !poGDS-\u003eSetDirectory() )\n                return nullptr;\n\n            uint32 nJPEGTableSize = 0;\n            void* pJPEGTable = nullptr;\n            if( TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_JPEGTABLES,\n                              \u0026nJPEGTableSize, \u0026pJPEGTable ) != 1 ||\n                pJPEGTable == nullptr || nJPEGTableSize \u003e INT_MAX )\n            {\n                return nullptr;\n            }\n            char* const pszHex =\n                CPLBinaryToHex( nJPEGTableSize, static_cast\u003cconst GByte*\u003e(pJPEGTable) );\n            const char* pszReturn = CPLSPrintf(\"%s\", pszHex);\n            CPLFree(pszHex);\n\n            return pszReturn;\n        }\n\n        if( EQUAL(pszName, \"IFD_OFFSET\") )\n        {\n            if( !poGDS-\u003eSetDirectory() )\n                return nullptr;\n\n            return CPLSPrintf( CPL_FRMT_GUIB,\n                               static_cast\u003cGUIntBig\u003e(poGDS-\u003enDirOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_OFFSET_%d_%d\",\n                         \u0026nBlockXOff, \u0026nBlockYOff ) == 2 )\n        {\n            if( !poGDS-\u003eSetDirectory() )\n                return nullptr;\n\n            nBlocksPerRow =\n                DIV_ROUND_UP(poGDS-\u003enRasterXSize, poGDS-\u003enBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(poGDS-\u003enRasterYSize, poGDS-\u003enBlockYSize);\n            if( nBlockXOff \u003c 0 || nBlockXOff \u003e= nBlocksPerRow ||\n                nBlockYOff \u003c 0 || nBlockYOff \u003e= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * poGDS-\u003enBlocksPerBand;\n            }\n\n            vsi_l_offset nOffset = 0;\n            if( !poGDS-\u003eIsBlockAvailable(nBlockId, \u0026nOffset) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf( CPL_FRMT_GUIB, static_cast\u003cGUIntBig\u003e(nOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_SIZE_%d_%d\",\n                    \u0026nBlockXOff, \u0026nBlockYOff ) == 2 )\n        {\n            if( !poGDS-\u003eSetDirectory() )\n                return nullptr;\n\n            nBlocksPerRow =\n                DIV_ROUND_UP(poGDS-\u003enRasterXSize, poGDS-\u003enBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(poGDS-\u003enRasterYSize, poGDS-\u003enBlockYSize);\n            if( nBlockXOff \u003c 0 || nBlockXOff \u003e= nBlocksPerRow ||\n                nBlockYOff \u003c 0 || nBlockYOff \u003e= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * poGDS-\u003enBlocksPerBand;\n            }\n\n            vsi_l_offset nByteCount = 0;\n            if( !poGDS-\u003eIsBlockAvailable(nBlockId, nullptr, \u0026nByteCount) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf(CPL_FRMT_GUIB, static_cast\u003cGUIntBig\u003e(nByteCount));\n        }\n    }\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadataItem( const char *pszName,\n                                         const char *pszValue,\n                                         const char *pszDomain )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( poGDS-\u003ebStreamingOut \u0026\u0026 poGDS-\u003ebCrystalized )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        poGDS-\u003ebMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update \u0026\u0026\n            GDALPamRasterBand::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamRasterBand::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    return oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRasterBand::GetColorInterpretation()\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    return eBandInterp;\n}\n\n/************************************************************************/\n/*                         GTiffGetAlphaValue()                         */\n/************************************************************************/\n\nuint16 GTiffGetAlphaValue(const char* pszValue, uint16 nDefault)\n{\n    if( pszValue == nullptr )\n        return nDefault;\n    if( EQUAL(pszValue, \"YES\") )\n        return DEFAULT_ALPHA_TYPE;\n    if( EQUAL(pszValue, \"PREMULTIPLIED\") )\n        return EXTRASAMPLE_ASSOCALPHA;\n    if( EQUAL(pszValue, \"NON-PREMULTIPLIED\") )\n        return EXTRASAMPLE_UNASSALPHA;\n    if( EQUAL(pszValue, \"NO\") ||\n        EQUAL(pszValue, \"UNSPECIFIED\") )\n        return EXTRASAMPLE_UNSPECIFIED;\n\n    return nDefault;\n}\n\n/************************************************************************/\n/*                       SetColorInterpretation()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorInterpretation( GDALColorInterp eInterp )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( eInterp == eBandInterp )\n        return CE_None;\n\n    eBandInterp = eInterp;\n\n    if( eAccess != GA_Update )\n    {\n        CPLDebug( \"GTIFF\", \"ColorInterpretation %s for band %d goes to PAM \"\n                  \"instead of TIFF tag\",\n                  GDALGetColorInterpretationName(eInterp), nBand );\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n    }\n\n    if( poGDS-\u003ebCrystalized )\n    {\n        if( !poGDS-\u003eSetDirectory() )\n            return CE_Failure;\n    }\n\n    poGDS-\u003ebNeedsRewrite = true;\n    poGDS-\u003ebMetadataChanged = true;\n\n    // Try to autoset TIFFTAG_PHOTOMETRIC = PHOTOMETRIC_RGB if possible.\n    if( poGDS-\u003enBands \u003e= 3 \u0026\u0026\n        poGDS-\u003enCompression != COMPRESSION_JPEG \u0026\u0026\n        poGDS-\u003enPhotometric != PHOTOMETRIC_RGB \u0026\u0026\n        CSLFetchNameValue( poGDS-\u003epapszCreationOptions,\n                           \"PHOTOMETRIC\" ) == nullptr \u0026\u0026\n        ((nBand == 1 \u0026\u0026 eInterp == GCI_RedBand) ||\n         (nBand == 2 \u0026\u0026 eInterp == GCI_GreenBand) ||\n         (nBand == 3 \u0026\u0026 eInterp == GCI_BlueBand)) )\n    {\n        if( poGDS-\u003eGetRasterBand(1)-\u003eGetColorInterpretation() == GCI_RedBand \u0026\u0026\n            poGDS-\u003eGetRasterBand(2)-\u003eGetColorInterpretation() == GCI_GreenBand \u0026\u0026\n            poGDS-\u003eGetRasterBand(3)-\u003eGetColorInterpretation() == GCI_BlueBand )\n        {\n            poGDS-\u003enPhotometric = PHOTOMETRIC_RGB;\n            TIFFSetField( poGDS-\u003ehTIFF, TIFFTAG_PHOTOMETRIC,\n                          poGDS-\u003enPhotometric );\n\n            // We need to update the number of extra samples.\n            uint16 *v = nullptr;\n            uint16 count = 0;\n            const uint16 nNewExtraSamplesCount =\n                static_cast\u003cuint16\u003e(poGDS-\u003enBands - 3);\n            if( poGDS-\u003enBands \u003e= 4 \u0026\u0026\n                TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_EXTRASAMPLES,\n                              \u0026count, \u0026v ) \u0026\u0026\n                count \u003e nNewExtraSamplesCount )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast\u003cuint16 *\u003e( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v + count - nNewExtraSamplesCount,\n                        nNewExtraSamplesCount * sizeof(uint16) );\n\n                TIFFSetField( poGDS-\u003ehTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n        return CE_None;\n    }\n\n    // On the contrary, cancel the above if needed\n    if( poGDS-\u003enCompression != COMPRESSION_JPEG \u0026\u0026\n        poGDS-\u003enPhotometric == PHOTOMETRIC_RGB \u0026\u0026\n        CSLFetchNameValue( poGDS-\u003epapszCreationOptions,\n                           \"PHOTOMETRIC\") == nullptr \u0026\u0026\n        ((nBand == 1 \u0026\u0026 eInterp != GCI_RedBand) ||\n         (nBand == 2 \u0026\u0026 eInterp != GCI_GreenBand) ||\n         (nBand == 3 \u0026\u0026 eInterp != GCI_BlueBand)) )\n    {\n        poGDS-\u003enPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(poGDS-\u003ehTIFF, TIFFTAG_PHOTOMETRIC, poGDS-\u003enPhotometric);\n\n        // We need to update the number of extra samples.\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        const uint16 nNewExtraSamplesCount =\n            static_cast\u003cuint16\u003e(poGDS-\u003enBands - 1);\n        if( poGDS-\u003enBands \u003e= 2 )\n        {\n            TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_EXTRASAMPLES, \u0026count, \u0026v );\n            if( nNewExtraSamplesCount \u003e count )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast\u003cuint16 *\u003e( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                for( int i = 0;\n                     i \u003c static_cast\u003cint\u003e(nNewExtraSamplesCount - count);\n                     ++i )\n                    pasNewExtraSamples[i] = EXTRASAMPLE_UNSPECIFIED;\n                if( count \u003e 0 )\n                {\n                    memcpy( pasNewExtraSamples + nNewExtraSamplesCount - count,\n                            v,\n                            count * sizeof(uint16) );\n                }\n\n                TIFFSetField( poGDS-\u003ehTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n    // Mark alpha band / undefined in extrasamples.\n    if( eInterp == GCI_AlphaBand || eInterp == GCI_Undefined )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_EXTRASAMPLES, \u0026count, \u0026v ) )\n        {\n            const int nBaseSamples = poGDS-\u003enSamplesPerPixel - count;\n\n            if( eInterp == GCI_AlphaBand )\n            {\n                for( int i = 1; i \u003c= poGDS-\u003enBands; ++i )\n                {\n                    if( i != nBand \u0026\u0026\n                        poGDS-\u003eGetRasterBand(i)-\u003eGetColorInterpretation() ==\n                        GCI_AlphaBand )\n                    {\n                        if( i == nBaseSamples + 1 \u0026\u0026\n                            CSLFetchNameValue( poGDS-\u003epapszCreationOptions,\n                                            \"ALPHA\" ) != nullptr )\n                        {\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too. \"\n                                \"Presumably ALPHA creation option is not needed\",\n                                i, nBand );\n                        }\n                        else\n                        {\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too\",\n                                i, nBand );\n                        }\n                    }\n                }\n            }\n\n            if( nBand \u003e nBaseSamples \u0026\u0026 nBand - nBaseSamples - 1 \u003c count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast\u003cuint16 *\u003e(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                if( eInterp == GCI_AlphaBand )\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        GTiffGetAlphaValue(CPLGetConfigOption(\"GTIFF_ALPHA\", nullptr),\n                                            DEFAULT_ALPHA_TYPE);\n                }\n                else\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        EXTRASAMPLE_UNSPECIFIED;\n                }\n\n                TIFFSetField( poGDS-\u003ehTIFF, TIFFTAG_EXTRASAMPLES,\n                              count, pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n\n                return CE_None;\n            }\n        }\n    }\n\n    if( poGDS-\u003enPhotometric != PHOTOMETRIC_MINISBLACK \u0026\u0026\n        CSLFetchNameValue( poGDS-\u003epapszCreationOptions, \"PHOTOMETRIC\") == nullptr )\n    {\n        poGDS-\u003enPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(poGDS-\u003ehTIFF, TIFFTAG_PHOTOMETRIC, poGDS-\u003enPhotometric);\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffRasterBand::GetColorTable()\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( nBand == 1 )\n        return poGDS-\u003epoColorTable;\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           SetColorTable()                            */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorTable( GDALColorTable * poCT )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n/* -------------------------------------------------------------------- */\n/*      Check if this is even a candidate for applying a PCT.           */\n/* -------------------------------------------------------------------- */\n    if( nBand != 1)\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() can only be called on band 1.\" );\n        return CE_Failure;\n    }\n\n    if( poGDS-\u003enSamplesPerPixel != 1 \u0026\u0026 poGDS-\u003enSamplesPerPixel != 2)\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() not supported for multi-sample TIFF \"\n                  \"files.\" );\n        return CE_Failure;\n    }\n\n    if( eDataType != GDT_Byte \u0026\u0026 eDataType != GDT_UInt16 )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() only supported for Byte or UInt16 bands \"\n                  \"in TIFF format.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We are careful about calling SetDirectory() to avoid            */\n/*      prematurely crystallizing the directory.  (#2820)               */\n/* -------------------------------------------------------------------- */\n    if( poGDS-\u003ebCrystalized )\n    {\n        if( !poGDS-\u003eSetDirectory() )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Is this really a request to clear the color table?              */\n/* -------------------------------------------------------------------- */\n    if( poCT == nullptr || poCT-\u003eGetColorEntryCount() == 0 )\n    {\n        TIFFSetField( poGDS-\u003ehTIFF, TIFFTAG_PHOTOMETRIC,\n                      PHOTOMETRIC_MINISBLACK );\n\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( poGDS-\u003ehTIFF, TIFFTAG_COLORMAP );\n#else\n        CPLDebug(\n            \"GTiff\",\n            \"TIFFUnsetField() not supported, colormap may not be cleared.\" );\n#endif\n\n        if( poGDS-\u003epoColorTable )\n        {\n            delete poGDS-\u003epoColorTable;\n            poGDS-\u003epoColorTable = nullptr;\n        }\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the colortable, and update the configuration.         */\n/* -------------------------------------------------------------------- */\n    int nColors = 65536;\n\n    if( eDataType == GDT_Byte )\n        nColors = 256;\n\n    unsigned short *panTRed = static_cast\u003cunsigned short *\u003e(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTGreen = static_cast\u003cunsigned short *\u003e(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTBlue = static_cast\u003cunsigned short *\u003e(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n\n    for( int iColor = 0; iColor \u003c nColors; ++iColor )\n    {\n        if( iColor \u003c poCT-\u003eGetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n            poCT-\u003eGetColorEntryAsRGB( iColor, \u0026sRGB );\n\n            panTRed[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c1);\n            panTGreen[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c2);\n            panTBlue[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c3);\n        }\n        else\n        {\n            panTRed[iColor] = 0;\n            panTGreen[iColor] = 0;\n            panTBlue[iColor] = 0;\n        }\n    }\n\n    TIFFSetField( poGDS-\u003ehTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n    TIFFSetField( poGDS-\u003ehTIFF, TIFFTAG_COLORMAP,\n                  panTRed, panTGreen, panTBlue );\n\n    CPLFree( panTRed );\n    CPLFree( panTGreen );\n    CPLFree( panTBlue );\n\n    if( poGDS-\u003epoColorTable )\n        delete poGDS-\u003epoColorTable;\n\n    // libtiff 3.X needs setting this in all cases (creation or update)\n    // whereas libtiff 4.X would just need it if there\n    // was no color table before.\n    poGDS-\u003ebNeedsRewrite = true;\n\n    poGDS-\u003epoColorTable = poCT-\u003eClone();\n    eBandInterp = GCI_PaletteIndex;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetNoDataValue()                           */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetNoDataValue( int * pbSuccess )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return dfNoDataValue;\n    }\n\n    if( poGDS-\u003ebNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return poGDS-\u003edfNoDataValue;\n    }\n\n    return GDALPamRasterBand::GetNoDataValue( pbSuccess );\n}\n\n/************************************************************************/\n/*                           SetNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetNoDataValue( double dfNoData )\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( poGDS-\u003ebNoDataSet \u0026\u0026 poGDS-\u003edfNoDataValue == dfNoData )\n    {\n        bNoDataSet = true;\n        dfNoDataValue = dfNoData;\n        return CE_None;\n    }\n\n    if( poGDS-\u003enBands \u003e 1 \u0026\u0026 poGDS-\u003eosProfile == szPROFILE_GDALGeoTIFF )\n    {\n        int bOtherBandHasNoData = FALSE;\n        const int nOtherBand = nBand \u003e 1 ? 1 : 2;\n        double dfOtherNoData = poGDS-\u003eGetRasterBand(nOtherBand)-\u003e\n                                    GetNoDataValue(\u0026bOtherBandHasNoData);\n        if( bOtherBandHasNoData \u0026\u0026 dfOtherNoData != dfNoData )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                 \"Setting nodata to %.18g on band %d, but band %d has nodata \"\n                 \"at %.18g. The TIFFTAG_GDAL_NODATA only support one value \"\n                 \"per dataset. This value of %.18g will be used for all bands \"\n                 \"on re-opening\",\n                 dfNoData, nBand, nOtherBand, dfOtherNoData, dfNoData);\n        }\n    }\n\n    if( poGDS-\u003ebStreamingOut \u0026\u0026 poGDS-\u003ebCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    poGDS-\u003ebNoDataSet = true;\n    poGDS-\u003edfNoDataValue = dfNoData;\n\n    poGDS-\u003ebNoDataChanged = true;\n\n    bNoDataSet = true;\n    dfNoDataValue = dfNoData;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                        DeleteNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::DeleteNoDataValue()\n\n{\n    poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( !poGDS-\u003ebNoDataSet )\n        return CE_None;\n\n    if( poGDS-\u003ebStreamingOut \u0026\u0026 poGDS-\u003ebCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    poGDS-\u003ebNoDataSet = false;\n    poGDS-\u003edfNoDataValue = -9999.0;\n\n    poGDS-\u003ebNoDataChanged = true;\n\n    bNoDataSet = false;\n    dfNoDataValue = -9999.0;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             NullBlock()                              */\n/*                                                                      */\n/*      Set the block data to the null value if it is set, or zero      */\n/*      if there is no null data value.                                 */\n/************************************************************************/\n\nvoid GTiffRasterBand::NullBlock( void *pData )\n\n{\n    const int nWords = nBlockXSize * nBlockYSize;\n    const int nChunkSize = std::max(1, GDALGetDataTypeSizeBytes(eDataType));\n\n    int bNoDataSetIn = FALSE;\n    const double dfNoData = GetNoDataValue( \u0026bNoDataSetIn );\n    if( !bNoDataSetIn )\n    {\n#ifdef ESRI_BUILD\n        if( poGDS-\u003enBitsPerSample \u003e= 2 )\n            memset( pData, 0, nWords * nChunkSize );\n        else\n            memset( pData, 1, nWords * nChunkSize );\n#else\n        memset( pData, 0, nWords * nChunkSize );\n#endif\n    }\n    else\n    {\n        // Will convert nodata value to the right type and copy efficiently.\n        GDALCopyWords( \u0026dfNoData, GDT_Float64, 0,\n                       pData, eDataType, nChunkSize, nWords);\n    }\n}\n\n/************************************************************************/\n/*                          GetOverviewCount()                          */\n/************************************************************************/\n\nint GTiffRasterBand::GetOverviewCount()\n\n{\n    poGDS-\u003eScanDirectories();\n\n    if( poGDS-\u003enOverviewCount \u003e 0 )\n    {\n        return poGDS-\u003enOverviewCount;\n    }\n\n    const int nOverviewCount = GDALRasterBand::GetOverviewCount();\n    if( nOverviewCount \u003e 0 )\n        return nOverviewCount;\n\n    // Implicit JPEG overviews are normally hidden, except when doing\n    // IRasterIO() operations.\n    if( poGDS-\u003enJPEGOverviewVisibilityCounter )\n        return poGDS-\u003eGetJPEGOverviewCount();\n\n    return 0;\n}\n\n/************************************************************************/\n/*                            GetOverview()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetOverview( int i )\n\n{\n    poGDS-\u003eScanDirectories();\n\n    if( poGDS-\u003enOverviewCount \u003e 0 )\n    {\n        // Do we have internal overviews?\n        if( i \u003c 0 || i \u003e= poGDS-\u003enOverviewCount )\n            return nullptr;\n\n        return poGDS-\u003epapoOverviewDS[i]-\u003eGetRasterBand(nBand);\n    }\n\n    GDALRasterBand* const poOvrBand = GDALRasterBand::GetOverview( i );\n    if( poOvrBand != nullptr )\n        return poOvrBand;\n\n    // For consistency with GetOverviewCount(), we should also test\n    // nJPEGOverviewVisibilityCounter, but it is also convenient to be able\n    // to query them for testing purposes.\n    if( i \u003e= 0 \u0026\u0026 i \u003c poGDS-\u003eGetJPEGOverviewCount() )\n        return poGDS-\u003epapoJPEGOverviewDS[i]-\u003eGetRasterBand(nBand);\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           GetMaskFlags()                             */\n/************************************************************************/\n\nint GTiffRasterBand::GetMaskFlags()\n{\n    poGDS-\u003eScanDirectories();\n\n    if( poGDS-\u003epoMaskDS != nullptr )\n    {\n        if( poGDS-\u003epoMaskDS-\u003eGetRasterCount() == 1)\n        {\n            return GMF_PER_DATASET;\n        }\n\n        return 0;\n    }\n\n    if( poGDS-\u003ebIsOverview_ )\n    {\n        return poGDS-\u003epoBaseDS-\u003eGetRasterBand(nBand)-\u003eGetMaskFlags();\n    }\n\n    return GDALPamRasterBand::GetMaskFlags();\n}\n\n/************************************************************************/\n/*                            GetMaskBand()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetMaskBand()\n{\n    poGDS-\u003eScanDirectories();\n\n    if( poGDS-\u003epoMaskDS != nullptr )\n    {\n        if( poGDS-\u003epoMaskDS-\u003eGetRasterCount() == 1 )\n            return poGDS-\u003epoMaskDS-\u003eGetRasterBand(1);\n\n        return poGDS-\u003epoMaskDS-\u003eGetRasterBand(nBand);\n    }\n\n    if( poGDS-\u003ebIsOverview_ )\n    {\n        GDALRasterBand* poBaseMask =\n            poGDS-\u003epoBaseDS-\u003eGetRasterBand(nBand)-\u003eGetMaskBand();\n        if( poBaseMask )\n        {\n            const int nOverviews = poBaseMask-\u003eGetOverviewCount();\n            for( int i = 0; i \u003c nOverviews; i++ )\n            {\n                GDALRasterBand* poOvr = poBaseMask-\u003eGetOverview(i);\n                if( poOvr \u0026\u0026\n                    poOvr-\u003eGetXSize() == GetXSize() \u0026\u0026\n                    poOvr-\u003eGetYSize() == GetYSize() )\n                {\n                    return poOvr;\n                }\n            }\n        }\n    }\n\n    return GDALPamRasterBand::GetMaskBand();\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffSplitBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n             GTiffSplitBand( GTiffDataset *, int );\n    virtual ~GTiffSplitBand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffSplitBand()                           */\n/************************************************************************/\n\nGTiffSplitBand::GTiffSplitBand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    nBlockXSize = poDS-\u003eGetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                   void * pImage )\n\n{\n    // Optimization when reading the same line in a contig multi-band TIFF.\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 poGDS-\u003enBands \u003e 1 \u0026\u0026\n        poGDS-\u003enLastLineRead == nBlockYOff )\n    {\n        goto extract_band_data;\n    }\n\n    if( !poGDS-\u003eSetDirectory() )\n        return CE_Failure;\n\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        poGDS-\u003enBands \u003e 1 )\n    {\n        if( poGDS-\u003epabyBlockBuf == nullptr )\n        {\n            poGDS-\u003epabyBlockBuf =\n                static_cast\u003cGByte *\u003e(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(poGDS-\u003ehTIFF)) );\n            if( poGDS-\u003epabyBlockBuf == nullptr )\n            {\n                return CE_Failure;\n            }\n        }\n    }\n    else\n    {\n        CPLAssert(TIFFScanlineSize(poGDS-\u003ehTIFF) == nBlockXSize);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS-\u003enLastLineRead \u003e= nBlockYOff )\n        poGDS-\u003enLastLineRead = -1;\n\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE \u0026\u0026 poGDS-\u003enBands \u003e 1 )\n    {\n        // If we change of band, we must start reading the\n        // new strip from its beginning.\n        if( poGDS-\u003enLastBandRead != nBand )\n            poGDS-\u003enLastLineRead = -1;\n        poGDS-\u003enLastBandRead = nBand;\n    }\n\n    while( poGDS-\u003enLastLineRead \u003c nBlockYOff )\n    {\n        ++poGDS-\u003enLastLineRead;\n        if( TIFFReadScanline(\n                poGDS-\u003ehTIFF,\n                poGDS-\u003epabyBlockBuf ? poGDS-\u003epabyBlockBuf : pImage,\n                poGDS-\u003enLastLineRead,\n                (poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE) ?\n                 static_cast\u003cuint16\u003e(nBand - 1) : 0 ) == -1\n            \u0026\u0026 !poGDS-\u003ebIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            poGDS-\u003enLastLineRead = -1;\n            return CE_Failure;\n        }\n    }\n\nextract_band_data:\n/* -------------------------------------------------------------------- */\n/*      Extract band data from contig buffer.                           */\n/* -------------------------------------------------------------------- */\n    if( poGDS-\u003epabyBlockBuf != nullptr )\n    {\n        for( int iPixel = 0, iSrcOffset= nBand - 1, iDstOffset = 0;\n             iPixel \u003c nBlockXSize;\n             ++iPixel, iSrcOffset += poGDS-\u003enBands, ++iDstOffset )\n        {\n            static_cast\u003cGByte *\u003e(pImage)[iDstOffset] =\n                poGDS-\u003epabyBlockBuf[iSrcOffset];\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IWriteBlock( int /* nBlockXOff */, int /* nBlockYOff */,\n                                    void * /* pImage */ )\n\n{\n    CPLError( CE_Failure, CPLE_AppDefined,\n              \"Split bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffRGBABand                            */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRGBABand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n                   GTiffRGBABand( GTiffDataset *, int );\n    virtual ~GTiffRGBABand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n};\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock( int, int, void * )\n\n{\n    CPLError( CE_Failure, CPLE_AppDefined,\n              \"RGBA interpreted raster bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                  void * pImage )\n\n{\n    if( !poGDS-\u003eSetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( nBlocksPerRow != 0 );\n    const int nBlockBufSize = 4 * nBlockXSize * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n#ifdef INTERNAL_LIBTIFF\n    if( poGDS-\u003enCompression == COMPRESSION_OJPEG )\n    {\n        // Need to fetch all offsets for Old-JPEG compression\n        if( poGDS-\u003epabyBlockBuf == nullptr )\n        {\n            toff_t *panByteCounts = nullptr;\n            toff_t *panOffsets = nullptr;\n            const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(poGDS-\u003ehTIFF) );\n\n            if( bIsTiled )\n            {\n                TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_TILEBYTECOUNTS, \u0026panByteCounts );\n                TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_TILEOFFSETS, \u0026panOffsets );\n            }\n            else\n            {\n                TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_STRIPBYTECOUNTS, \u0026panByteCounts );\n                TIFFGetField( poGDS-\u003ehTIFF, TIFFTAG_STRIPOFFSETS, \u0026panOffsets );\n            }\n        }\n    }\n#endif\n\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        for( int iBand = 0; iBand \u003c poGDS-\u003enSamplesPerPixel; iBand ++ )\n        {\n            int nBlockIdBand = nBlockId + iBand * poGDS-\u003enBlocksPerBand;\n            if( !poGDS-\u003eIsBlockAvailable(nBlockIdBand) )\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if( !poGDS-\u003eIsBlockAvailable(nBlockId) )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( poGDS-\u003epabyBlockBuf == nullptr )\n    {\n        poGDS-\u003epabyBlockBuf =\n            static_cast\u003cGByte *\u003e(\n                VSI_MALLOC3_VERBOSE( 4, nBlockXSize, nBlockYSize ) );\n        if( poGDS-\u003epabyBlockBuf == nullptr )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if( poGDS-\u003enLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( poGDS-\u003ehTIFF ) )\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION \u003e 20161119\n            if( TIFFReadRGBATileExt(\n                   poGDS-\u003ehTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast\u003cuint32 *\u003e(poGDS-\u003epabyBlockBuf),\n                   !poGDS-\u003ebIgnoreReadErrors) == 0\n                \u0026\u0026 !poGDS-\u003ebIgnoreReadErrors )\n#else\n            if( TIFFReadRGBATile(\n                   poGDS-\u003ehTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast\u003cuint32 *\u003e(poGDS-\u003epabyBlockBuf)) == 0\n                \u0026\u0026 !poGDS-\u003ebIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n\n                memset( poGDS-\u003epabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION \u003e 20161119\n            if( TIFFReadRGBAStripExt(\n                   poGDS-\u003ehTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast\u003cuint32 *\u003e(poGDS-\u003epabyBlockBuf),\n                   !poGDS-\u003ebIgnoreReadErrors) == 0\n                \u0026\u0026 !poGDS-\u003ebIgnoreReadErrors )\n#else\n            if( TIFFReadRGBAStrip(\n                   poGDS-\u003ehTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast\u003cuint32 *\u003e(poGDS-\u003epabyBlockBuf)) == 0\n                \u0026\u0026 !poGDS-\u003ebIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n\n                memset( poGDS-\u003epabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    poGDS-\u003enLoadedBlock = nBlockId;\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if( nBlockYOff * nBlockYSize \u003e GetYSize() - nBlockYSize\n        \u0026\u0026 !TIFFIsTiled( poGDS-\u003ehTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for( int iDestLine = 0; iDestLine \u003c nThisBlockYSize; ++iDestLine )\n    {\n        const int nSrcOffset =\n            (nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords(\n            poGDS-\u003epabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n            static_cast\u003cGByte *\u003e(pImage)+iDestLine*nBlockXSize, GDT_Byte, 1,\n            nBlockXSize );\n    }\n\n    if( eErr == CE_None )\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if( nBand == 1 )\n        return GCI_RedBand;\n    if( nBand == 2 )\n        return GCI_GreenBand;\n    if( nBand == 3 )\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffOddBitsBand                         */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffOddBitsBand : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n  public:\n\n                   GTiffOddBitsBand( GTiffDataset *, int );\n    virtual ~GTiffOddBitsBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffOddBitsBand()                         */\n/************************************************************************/\n\nGTiffOddBitsBand::GTiffOddBitsBand( GTiffDataset *poGDSIn, int nBandIn )\n        : GTiffRasterBand( poGDSIn, nBandIn )\n\n{\n    eDataType = GDT_Unknown;\n    if( (poGDS-\u003enBitsPerSample == 16 || poGDS-\u003enBitsPerSample == 24) \u0026\u0026\n        poGDS-\u003enSampleFormat == SAMPLEFORMAT_IEEEFP )\n        eDataType = GDT_Float32;\n    // FIXME ? in autotest we currently open gcore/data/int24.tif\n    // which is declared as signed, but we consider it as unsigned\n    else if( (poGDS-\u003enSampleFormat == SAMPLEFORMAT_UINT ||\n              poGDS-\u003enSampleFormat == SAMPLEFORMAT_INT) \u0026\u0026\n             poGDS-\u003enBitsPerSample \u003c 8 )\n        eDataType = GDT_Byte;\n    else if( (poGDS-\u003enSampleFormat == SAMPLEFORMAT_UINT ||\n              poGDS-\u003enSampleFormat == SAMPLEFORMAT_INT) \u0026\u0026\n             poGDS-\u003enBitsPerSample \u003e 8 \u0026\u0026 poGDS-\u003enBitsPerSample \u003c 16 )\n        eDataType = GDT_UInt16;\n    else if( (poGDS-\u003enSampleFormat == SAMPLEFORMAT_UINT ||\n              poGDS-\u003enSampleFormat == SAMPLEFORMAT_INT) \u0026\u0026\n             poGDS-\u003enBitsPerSample \u003e 16 \u0026\u0026 poGDS-\u003enBitsPerSample \u003c 32 )\n        eDataType = GDT_UInt32;\n}\n\n/************************************************************************/\n/*                            FloatToHalf()                             */\n/************************************************************************/\n\nstatic GUInt16 FloatToHalf( GUInt32 iFloat32, bool\u0026 bHasWarned )\n{\n    GUInt32 iSign =     (iFloat32 \u003e\u003e 31) \u0026 0x00000001;\n    GUInt32 iExponent = (iFloat32 \u003e\u003e 23) \u0026 0x000000ff;\n    GUInt32 iMantissa = iFloat32         \u0026 0x007fffff;\n\n    if (iExponent == 255)\n    {\n        if (iMantissa == 0)\n        {\n/* -------------------------------------------------------------------- */\n/*       Positive or negative infinity.                                 */\n/* -------------------------------------------------------------------- */\n\n            return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) | 0x7C00);\n        }\n        else\n        {\n/* -------------------------------------------------------------------- */\n/*       NaN -- preserve sign and significand bits.                     */\n/* -------------------------------------------------------------------- */\n            if( iMantissa \u003e\u003e 13 )\n                return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) | 0x7C00 |\n                                                            (iMantissa \u003e\u003e 13));\n\n            return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) | 0x7E00);\n        }\n    }\n\n    if( iExponent \u003c= 127 - 15 )\n    {\n        // Zero, float32 denormalized number or float32 too small normalized\n        // number\n        if( 13 + 1 + 127 - 15 - iExponent \u003e= 32 )\n            return static_cast\u003cGUInt16\u003e(iSign \u003c\u003c 15);\n\n        // Return a denormalized number\n        return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) |\n                ((iMantissa | 0x00800000) \u003e\u003e (13 + 1 + 127 - 15 - iExponent)));\n    }\n    if( iExponent - (127 - 15) \u003e= 31 )\n    {\n        if( !bHasWarned )\n        {\n            bHasWarned = true;\n            float fVal = 0.0f;\n            memcpy(\u0026fVal, \u0026iFloat32, 4);\n            CPLError(\n                CE_Failure, CPLE_AppDefined,\n                \"Value %.8g is beyond range of float16. Converted to %sinf\",\n                fVal, (fVal \u003e 0) ? \"+\" : \"-\");\n        }\n        return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) | 0x7C00);  // Infinity\n    }\n\n/* -------------------------------------------------------------------- */\n/*       Normalized number.                                             */\n/* -------------------------------------------------------------------- */\n\n    iExponent = iExponent - (127 - 15);\n    iMantissa = iMantissa \u003e\u003e 13;\n\n/* -------------------------------------------------------------------- */\n/*       Assemble sign, exponent and mantissa.                          */\n/* -------------------------------------------------------------------- */\n\n    // coverity[overflow_sink]\n    return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) | (iExponent \u003c\u003c 10) | iMantissa);\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffOddBitsBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                      void *pImage )\n\n{\n    if( poGDS-\u003ebWriteErrorInFlushBlockBuf )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        poGDS-\u003ebWriteErrorInFlushBlockBuf = false;\n        return CE_Failure;\n    }\n\n    if( !poGDS-\u003eSetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( poGDS != nullptr\n               \u0026\u0026 nBlockXOff \u003e= 0\n               \u0026\u0026 nBlockYOff \u003e= 0\n               \u0026\u0026 pImage != nullptr );\n\n    if( eDataType == GDT_Float32 \u0026\u0026 poGDS-\u003enBitsPerSample != 16 )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Writing float data with nBitsPerSample = %d is unsupported\",\n                 poGDS-\u003enBitsPerSample);\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * poGDS-\u003enBlocksPerBand;\n\n    // Only read content from disk in the CONTIG case.\n    {\n        const CPLErr eErr =\n            poGDS-\u003eLoadBlockBuf( nBlockId,\n                                 poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n                                 poGDS-\u003enBands \u003e 1 );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    const GUInt32 nMaxVal = (1U \u003c\u003c poGDS-\u003enBitsPerSample) - 1;\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images or single band images where    */\n/*      no interleaving with other data is required.                    */\n/* -------------------------------------------------------------------- */\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE\n        || poGDS-\u003enBands == 1 )\n    {\n        // TODO(schwehr): Create a CplNumBits8Aligned.\n        // Bits per line rounds up to next byte boundary.\n        int nBitsPerLine = nBlockXSize * poGDS-\u003enBitsPerSample;\n        if( (nBitsPerLine \u0026 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) \u0026 (~7);\n\n        int iPixel = 0;\n\n        // Small optimization in 1 bit case.\n        if( poGDS-\u003enBitsPerSample == 1 )\n        {\n            for( int iY = 0; iY \u003c nBlockYSize; ++iY, iPixel += nBlockXSize )\n            {\n                int iBitOffset = iY * nBitsPerLine;\n\n                const GByte* pabySrc =\n                    static_cast\u003cconst GByte*\u003e(pImage) + iPixel;\n                int iByteOffset = iBitOffset / 8;\n                int iX = 0;  // Used after for.\n                for( ; iX + 7 \u003c nBlockXSize; iX += 8, iByteOffset++ )\n                {\n                    int nRes = (!(!pabySrc[iX+0])) \u003c\u003c 7;\n                    nRes |= (!(!pabySrc[iX+1])) \u003c\u003c 6;\n                    nRes |= (!(!pabySrc[iX+2])) \u003c\u003c 5;\n                    nRes |= (!(!pabySrc[iX+3])) \u003c\u003c 4;\n                    nRes |= (!(!pabySrc[iX+4])) \u003c\u003c 3;\n                    nRes |= (!(!pabySrc[iX+5])) \u003c\u003c 2;\n                    nRes |= (!(!pabySrc[iX+6])) \u003c\u003c 1;\n                    nRes |= (!(!pabySrc[iX+7])) \u003c\u003c 0;\n                    poGDS-\u003epabyBlockBuf[iByteOffset] = static_cast\u003cGByte\u003e(nRes);\n                }\n                iBitOffset = iByteOffset * 8;\n                if( iX \u003c nBlockXSize )\n                {\n                    int nRes = 0;\n                    for( ; iX \u003c nBlockXSize; ++iX )\n                    {\n                        if( pabySrc[iX] )\n                            nRes |= (0x80 \u003e\u003e(iBitOffset \u0026 7) );\n                        ++iBitOffset;\n                    }\n                    poGDS-\u003epabyBlockBuf[iBitOffset\u003e\u003e3] =\n                        static_cast\u003cGByte\u003e(nRes);\n                }\n            }\n\n            poGDS-\u003ebLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        if( eDataType == GDT_Float32 \u0026\u0026 poGDS-\u003enBitsPerSample == 16 )\n        {\n            for( ; iPixel \u003c nBlockYSize * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = static_cast\u003cGUInt32 *\u003e(pImage)[iPixel];\n                GUInt16 nHalf = FloatToHalf(nInWord, poGDS-\u003ebClipWarn);\n                reinterpret_cast\u003cGUInt16*\u003e(poGDS-\u003epabyBlockBuf)[iPixel] = nHalf;\n            }\n\n            poGDS-\u003ebLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        // Initialize to zero as we set the buffer with binary or operations.\n        if( poGDS-\u003enBitsPerSample != 24 )\n            memset(poGDS-\u003epabyBlockBuf, 0, (nBitsPerLine / 8) * nBlockYSize);\n\n        for( int iY = 0; iY \u003c nBlockYSize; ++iY )\n        {\n            int iBitOffset = iY * nBitsPerLine;\n\n            if( poGDS-\u003enBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord = static_cast\u003cGUInt16 *\u003e(pImage)[iPixel++];\n                    if( nInWord \u003e nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !poGDS-\u003ebClipWarn )\n                        {\n                            poGDS-\u003ebClipWarn = true;\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", poGDS-\u003enBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        poGDS-\u003epabyBlockBuf[iBitOffset\u003e\u003e3] =\n                            static_cast\u003cGByte\u003e(nInWord \u003e\u003e 4);\n                        // Let 4 lower bits to zero as they're going to be\n                        // overridden by the next word.\n                        poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3)+1] =\n                            static_cast\u003cGByte\u003e((nInWord \u0026 0xf) \u003c\u003c 4);\n                    }\n                    else\n                    {\n                        // Must or to preserve the 4 upper bits written\n                        // for the previous word.\n                        poGDS-\u003epabyBlockBuf[iBitOffset\u003e\u003e3] |=\n                            static_cast\u003cGByte\u003e(nInWord \u003e\u003e 8);\n                        poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3)+1] =\n                            static_cast\u003cGByte\u003e(nInWord \u0026 0xff);\n                    }\n\n                    iBitOffset += poGDS-\u003enBitsPerSample;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord = static_cast\u003cGByte *\u003e(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = static_cast\u003cGUInt16 *\u003e(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = static_cast\u003cGUInt32 *\u003e(pImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord \u003e nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !poGDS-\u003ebClipWarn )\n                    {\n                        poGDS-\u003ebClipWarn = true;\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            poGDS-\u003enBitsPerSample );\n                    }\n                }\n\n                if( poGDS-\u003enBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 0] =\n                        static_cast\u003cGByte\u003e( nInWord );\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 1] =\n                        static_cast\u003cGByte\u003e( nInWord \u003e\u003e 8 );\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 2] =\n                        static_cast\u003cGByte\u003e( nInWord \u003e\u003e 16 );\n#else\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 0] =\n                        static_cast\u003cGByte\u003e( nInWord \u003e\u003e 16 );\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 1] =\n                        static_cast\u003cGByte\u003e( nInWord \u003e\u003e 8 );\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 2] =\n                        static_cast\u003cGByte\u003e( nInWord );\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit \u003c poGDS-\u003enBitsPerSample; ++iBit )\n                    {\n                        if( nInWord \u0026\n                            (1 \u003c\u003c (poGDS-\u003enBitsPerSample - 1 - iBit)) )\n                            poGDS-\u003epabyBlockBuf[iBitOffset\u003e\u003e3] |=\n                                ( 0x80 \u003e\u003e (iBitOffset \u0026 7) );\n                        ++iBitOffset;\n                    }\n                }\n            }\n        }\n\n        poGDS-\u003ebLoadedBlockDirty = true;\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand \u003c poGDS-\u003enBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast\u003cGByte *\u003e( pImage );\n        }\n        else\n        {\n            poBlock =\n                cpl::down_cast\u003cGTiffOddBitsBand *\u003e(\n                    poGDS-\u003eGetRasterBand( iBand + 1 ))\n                        -\u003eTryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock-\u003eGetDirty() )\n            {\n                poBlock-\u003eDropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast\u003cGByte *\u003e(poBlock-\u003eGetDataRef());\n        }\n\n        const int iPixelBitSkip = poGDS-\u003enBitsPerSample * poGDS-\u003enBands;\n        const int iBandBitOffset = iBand * poGDS-\u003enBitsPerSample;\n\n        // Bits per line rounds up to next byte boundary.\n        int nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine \u0026 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) \u0026 (~7);\n\n        int iPixel = 0;\n\n        if( eDataType == GDT_Float32 \u0026\u0026 poGDS-\u003enBitsPerSample == 16 )\n        {\n            for( ; iPixel \u003c nBlockYSize * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = reinterpret_cast\u003cconst GUInt32 *\u003e(\n                                                        pabyThisImage)[iPixel];\n                GUInt16 nHalf = FloatToHalf(nInWord, poGDS-\u003ebClipWarn);\n                reinterpret_cast\u003cGUInt16*\u003e(poGDS-\u003epabyBlockBuf)[\n                                    iPixel * poGDS-\u003enBands + iBand] = nHalf;\n            }\n\n            if( poBlock != nullptr )\n            {\n                poBlock-\u003eMarkClean();\n                poBlock-\u003eDropLock();\n            }\n            continue;\n        }\n\n        for( int iY = 0; iY \u003c nBlockYSize; ++iY )\n        {\n            int iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            if( poGDS-\u003enBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord =\n                        reinterpret_cast\u003cconst GUInt16 *\u003e(\n                            pabyThisImage)[iPixel++];\n                    if( nInWord \u003e nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !poGDS-\u003ebClipWarn )\n                        {\n                            poGDS-\u003ebClipWarn = true;\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", poGDS-\u003enBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        poGDS-\u003epabyBlockBuf[iBitOffset\u003e\u003e3] =\n                            static_cast\u003cGByte\u003e( nInWord \u003e\u003e 4 );\n                        poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3)+1] =\n                            static_cast\u003cGByte\u003e(\n                                ((nInWord \u0026 0xf) \u003c\u003c 4) |\n                                (poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3)+1] \u0026\n                                 0xf) );\n                    }\n                    else\n                    {\n                        poGDS-\u003epabyBlockBuf[iBitOffset\u003e\u003e3] =\n                            static_cast\u003cGByte\u003e(\n                                (poGDS-\u003epabyBlockBuf[iBitOffset\u003e\u003e3] \u0026\n                                 0xf0) |\n                                (nInWord \u003e\u003e 8));\n                        poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3)+1] =\n                            static_cast\u003cGByte\u003e(nInWord \u0026 0xff);\n                    }\n\n                    iBitOffset += iPixelBitSkip;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord =\n                        static_cast\u003cconst GByte *\u003e(pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = reinterpret_cast\u003cconst GUInt16 *\u003e(\n                        pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = reinterpret_cast\u003cconst GUInt32 *\u003e(\n                        pabyThisImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord \u003e nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !poGDS-\u003ebClipWarn )\n                    {\n                        poGDS-\u003ebClipWarn = true;\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            poGDS-\u003enBitsPerSample );\n                    }\n                }\n\n                if( poGDS-\u003enBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 0] =\n                        static_cast\u003cGByte\u003e(nInWord);\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 1] =\n                        static_cast\u003cGByte\u003e(nInWord \u003e\u003e 8);\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 2] =\n                        static_cast\u003cGByte\u003e(nInWord \u003e\u003e 16);\n#else\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 0] =\n                        static_cast\u003cGByte\u003e(nInWord \u003e\u003e 16);\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 1] =\n                        static_cast\u003cGByte\u003e(nInWord \u003e\u003e 8);\n                    poGDS-\u003epabyBlockBuf[(iBitOffset\u003e\u003e3) + 2] =\n                        static_cast\u003cGByte\u003e(nInWord);\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit \u003c poGDS-\u003enBitsPerSample; ++iBit )\n                    {\n                        // TODO(schwehr): Revisit this block.\n                        if( nInWord \u0026\n                            (1 \u003c\u003c (poGDS-\u003enBitsPerSample - 1 - iBit)) )\n                        {\n                            poGDS-\u003epabyBlockBuf[iBitOffset\u003e\u003e3] |=\n                                ( 0x80 \u003e\u003e (iBitOffset \u0026 7) );\n                        }\n                        else\n                        {\n                            // We must explicitly unset the bit as we\n                            // may update an existing block.\n                            poGDS-\u003epabyBlockBuf[iBitOffset\u003e\u003e3] \u0026=\n                                ~(0x80 \u003e\u003e(iBitOffset \u0026 7));\n                        }\n\n                        ++iBitOffset;\n                    }\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - poGDS-\u003enBitsPerSample;\n            }\n        }\n\n        if( poBlock != nullptr )\n        {\n            poBlock-\u003eMarkClean();\n            poBlock-\u003eDropLock();\n        }\n    }\n\n    poGDS-\u003ebLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nstatic void ExpandPacked8ToByte1( const GByte * const CPL_RESTRICT pabySrc,\n                                  GByte* const CPL_RESTRICT pabyDest,\n                                  int nBytes )\n{\n    for( int i = 0, j = 0; i \u003c nBytes; i++, j+= 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = (byVal \u003e\u003e 7) \u0026 0x1;\n        pabyDest[j+1] = (byVal \u003e\u003e 6) \u0026 0x1;\n        pabyDest[j+2] = (byVal \u003e\u003e 5) \u0026 0x1;\n        pabyDest[j+3] = (byVal \u003e\u003e 4) \u0026 0x1;\n        pabyDest[j+4] = (byVal \u003e\u003e 3) \u0026 0x1;\n        pabyDest[j+5] = (byVal \u003e\u003e 2) \u0026 0x1;\n        pabyDest[j+6] = (byVal \u003e\u003e 1) \u0026 0x1;\n        pabyDest[j+7] = (byVal \u003e\u003e 0) \u0026 0x1;\n    }\n}\n\n#if defined(__GNUC__) || defined(_MSC_VER)\n// Signedness of char implementation dependent, so be explicit.\n// Assumes 2-complement integer types and sign extension of right shifting\n// GCC guarantees such:\n// https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html#Integers-implementation\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return\n        static_cast\u003cGByte\u003e(static_cast\u003csigned char\u003e(byVal \u003c\u003c (7 - nBit)) \u003e\u003e 7);\n}\n#else\n// Portable way\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return (byVal \u0026 (1 \u003c\u003c nBit)) ? 255 : 0;\n}\n#endif\n\nstatic void ExpandPacked8ToByte255( const GByte * const CPL_RESTRICT pabySrc,\n                                    GByte* const CPL_RESTRICT pabyDest,\n                                    int nBytes )\n{\n    for( int i = 0, j = 0; i \u003c nBytes; i++, j += 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = ExtractBitAndConvertTo255(byVal, 7);\n        pabyDest[j+1] = ExtractBitAndConvertTo255(byVal, 6);\n        pabyDest[j+2] = ExtractBitAndConvertTo255(byVal, 5);\n        pabyDest[j+3] = ExtractBitAndConvertTo255(byVal, 4);\n        pabyDest[j+4] = ExtractBitAndConvertTo255(byVal, 3);\n        pabyDest[j+5] = ExtractBitAndConvertTo255(byVal, 2);\n        pabyDest[j+6] = ExtractBitAndConvertTo255(byVal, 1);\n        pabyDest[j+7] = ExtractBitAndConvertTo255(byVal, 0);\n    }\n}\n\nCPLErr GTiffOddBitsBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    if( !poGDS-\u003eSetDirectory() )\n        return CE_Failure;\n\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * poGDS-\u003enBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip in a writable file that doesn't      */\n/*      exist yet, but that we want to read.  Just set to zeros and     */\n/*      return.                                                         */\n/* -------------------------------------------------------------------- */\n    if( nBlockId != poGDS-\u003enLoadedBlock )\n    {\n        bool bErrOccurred = false;\n        if( !poGDS-\u003eIsBlockAvailable(nBlockId, nullptr, nullptr, \u0026bErrOccurred) )\n        {\n            NullBlock( pImage );\n            if( bErrOccurred )\n                return CE_Failure;\n            return CE_None;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    {\n        const CPLErr eErr = poGDS-\u003eLoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    if( poGDS-\u003enBitsPerSample == 1 \u0026\u0026\n        (poGDS-\u003enBands == 1 || poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE ) )\n    {\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n        int iDstOffset = 0;\n        const GByte * const CPL_RESTRICT pabyBlockBuf = poGDS-\u003epabyBlockBuf;\n        GByte* CPL_RESTRICT pabyDest = static_cast\u003cGByte *\u003e(pImage);\n\n        for( int iLine = 0; iLine \u003c nBlockYSize; ++iLine )\n        {\n            int iSrcOffsetByte = ((nBlockXSize + 7) \u003e\u003e 3) * iLine;\n\n            if( !poGDS-\u003ebPromoteTo8Bits )\n            {\n                ExpandPacked8ToByte1( pabyBlockBuf + iSrcOffsetByte,\n                                      pabyDest + iDstOffset,\n                                      nBlockXSize / 8 );\n            }\n            else\n            {\n                ExpandPacked8ToByte255( pabyBlockBuf + iSrcOffsetByte,\n                                        pabyDest + iDstOffset,\n                                        nBlockXSize / 8 );\n            }\n            int iSrcOffsetBit = (iSrcOffsetByte + nBlockXSize / 8) * 8;\n            iDstOffset += nBlockXSize \u0026 ~0x7;\n            const GByte bSetVal = poGDS-\u003ebPromoteTo8Bits ? 255 : 1;\n            for( int iPixel = nBlockXSize \u0026 ~0x7 ;\n                 iPixel \u003c nBlockXSize;\n                 ++iPixel, ++iSrcOffsetBit )\n            {\n                if( pabyBlockBuf[iSrcOffsetBit \u003e\u003e3] \u0026\n                    (0x80 \u003e\u003e (iSrcOffsetBit \u0026 0x7)) )\n                    static_cast\u003cGByte *\u003e(pImage)[iDstOffset++] = bSetVal;\n                else\n                    static_cast\u003cGByte *\u003e(pImage)[iDstOffset++] = 0;\n            }\n        }\n    }\n/* -------------------------------------------------------------------- */\n/*      Handle the case of 16- and 24-bit floating point data as per    */\n/*      TIFF Technical Note 3.                                          */\n/* -------------------------------------------------------------------- */\n    else if( eDataType == GDT_Float32 )\n    {\n        const int nWordBytes = poGDS-\u003enBitsPerSample / 8;\n        const GByte *pabyImage = poGDS-\u003epabyBlockBuf +\n            ( ( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE ) ? 0 :\n              (nBand - 1) * nWordBytes );\n        const int iSkipBytes =\n            ( poGDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE ) ?\n            nWordBytes : poGDS-\u003enBands * nWordBytes;\n\n        const int nBlockPixels = nBlockXSize * nBlockYSize;\n        if( poGDS-\u003enBitsPerSample == 16 )\n        {\n            for( int i = 0; i \u003c nBlockPixels; ++i )\n            {\n                static_cast\u003cGUInt32 *\u003e(pImage)[i] =\n                    HalfToFloat( *reinterpret_cast\u003cconst GUInt16 *\u003e(pabyImage) );\n                pabyImage += iSkipBytes;\n            }\n        }\n        else if( poGDS-\u003enBitsPerSample == 24 )\n        {\n            for( int i = 0; i \u003c nBlockPixels; ++i )\n            {\n#ifdef CPL_MSB\n                static_cast\u003cGUInt32 *\u003e(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast\u003cGUInt32\u003e(*(pabyImage + 0)) \u003c\u003c 16)\n                        | (static_cast\u003cGUInt32\u003e(*(pabyImage + 1)) \u003c\u003c 8)\n                        | static_cast\u003cGUInt32\u003e(*(pabyImage + 2)) );\n#else\n                static_cast\u003cGUInt32 *\u003e(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast\u003cGUInt32\u003e(*(pabyImage + 2)) \u003c\u003c 16)\n                        | (static_cast\u003cGUInt32\u003e(*(pabyImage + 1)) \u003c\u003c 8)\n                        | static_cast\u003cGUInt32\u003e(*pabyImage) );\n#endif\n                pabyImage += iSkipBytes;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for moving 12bit data somewhat more efficiently.   */\n/* -------------------------------------------------------------------- */\n    else if( poGDS-\u003enBitsPerSample == 12 )\n    {\n        int iPixelBitSkip = 0;\n        int iBandBitOffset = 0;\n\n        if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = poGDS-\u003enBands * poGDS-\u003enBitsPerSample;\n            iBandBitOffset = (nBand - 1) * poGDS-\u003enBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = poGDS-\u003enBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        int nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine \u0026 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) \u0026 (~7);\n\n        int iPixel = 0;\n        for( int iY = 0; iY \u003c nBlockYSize; ++iY )\n        {\n            int iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n            {\n                const int iByte = iBitOffset \u003e\u003e 3;\n\n                if( (iBitOffset \u0026 0x7) == 0 )\n                {\n                    // Starting on byte boundary.\n\n                    static_cast\u003cGUInt16 *\u003e(pImage)[iPixel++] =\n                        (poGDS-\u003epabyBlockBuf[iByte] \u003c\u003c 4)\n                        | (poGDS-\u003epabyBlockBuf[iByte+1] \u003e\u003e 4);\n                }\n                else\n                {\n                    // Starting off byte boundary.\n\n                    static_cast\u003cGUInt16 *\u003e(pImage)[iPixel++] =\n                        ((poGDS-\u003epabyBlockBuf[iByte] \u0026 0xf) \u003c\u003c 8)\n                        | (poGDS-\u003epabyBlockBuf[iByte+1]);\n                }\n                iBitOffset += iPixelBitSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n    else if( poGDS-\u003enBitsPerSample == 24 )\n    {\n        int iPixelByteSkip = 0;\n        int iBandByteOffset = 0;\n\n        if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelByteSkip = (poGDS-\u003enBands * poGDS-\u003enBitsPerSample) / 8;\n            iBandByteOffset = ((nBand - 1) * poGDS-\u003enBitsPerSample) / 8;\n        }\n        else\n        {\n            iPixelByteSkip = poGDS-\u003enBitsPerSample / 8;\n        }\n\n        const int nBytesPerLine = nBlockXSize * iPixelByteSkip;\n\n        int iPixel = 0;\n        for( int iY = 0; iY \u003c nBlockYSize; ++iY )\n        {\n            GByte *pabyImage =\n                poGDS-\u003epabyBlockBuf + iBandByteOffset + iY * nBytesPerLine;\n\n            for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n            {\n#ifdef CPL_MSB\n                static_cast\u003cGUInt32 *\u003e(pImage)[iPixel++] =\n                    ( static_cast\u003cGUInt32\u003e(*(pabyImage + 2)) \u003c\u003c 16)\n                    | (static_cast\u003cGUInt32\u003e(*(pabyImage + 1)) \u003c\u003c 8)\n                    | static_cast\u003cGUInt32\u003e(*(pabyImage + 0));\n#else\n                static_cast\u003cGUInt32 *\u003e(pImage)[iPixel++] =\n                    ( static_cast\u003cGUInt32\u003e(*(pabyImage + 0)) \u003c\u003c 16)\n                    | (static_cast\u003cGUInt32\u003e(*(pabyImage + 1)) \u003c\u003c 8)\n                    | static_cast\u003cGUInt32\u003e(*(pabyImage + 2));\n#endif\n                pabyImage += iPixelByteSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle 1-32 bit integer data.                                   */\n/* -------------------------------------------------------------------- */\n    else\n    {\n        unsigned iPixelBitSkip = 0;\n        unsigned iBandBitOffset = 0;\n\n        if( poGDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = poGDS-\u003enBands * poGDS-\u003enBitsPerSample;\n            iBandBitOffset = (nBand - 1) * poGDS-\u003enBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = poGDS-\u003enBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        GUIntBig nBitsPerLine = static_cast\u003cGUIntBig\u003e(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine \u0026 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) \u0026 (~7);\n\n        const GByte * const pabyBlockBuf = poGDS-\u003epabyBlockBuf;\n        const unsigned nBitsPerSample = poGDS-\u003enBitsPerSample;\n        unsigned iPixel = 0;\n\n        if( nBitsPerSample == 1 \u0026\u0026 eDataType == GDT_Byte )\n        {\n          for( unsigned iY = 0; iY \u003c static_cast\u003cunsigned\u003e(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX \u003c static_cast\u003cunsigned\u003e(nBlockXSize); ++iX )\n            {\n                if( pabyBlockBuf[iBitOffset\u003e\u003e3] \u0026 (0x80 \u003e\u003e(iBitOffset \u0026 7)) )\n                    static_cast\u003cGByte *\u003e(pImage)[iPixel] = 1;\n                else\n                    static_cast\u003cGByte *\u003e(pImage)[iPixel] = 0;\n                iBitOffset += iPixelBitSkip;\n                iPixel++;\n            }\n          }\n        }\n        else\n        {\n          for( unsigned iY = 0; iY \u003c static_cast\u003cunsigned\u003e(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX \u003c static_cast\u003cunsigned\u003e(nBlockXSize); ++iX )\n            {\n                unsigned nOutWord = 0;\n\n                for( unsigned iBit = 0; iBit \u003c nBitsPerSample; ++iBit )\n                {\n                    if( pabyBlockBuf[iBitOffset\u003e\u003e3]\n                        \u0026 (0x80 \u003e\u003e(iBitOffset \u0026 7)) )\n                        nOutWord |= (1 \u003c\u003c (nBitsPerSample - 1 - iBit));\n                    ++iBitOffset;\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - nBitsPerSample;\n\n                if( eDataType == GDT_Byte )\n                {\n                    static_cast\u003cGByte *\u003e(pImage)[iPixel++] =\n                        static_cast\u003cGByte\u003e(nOutWord);\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                  static_cast\u003cGUInt16 *\u003e(pImage)[iPixel++] =\n                      static_cast\u003cGUInt16\u003e(nOutWord);\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                  static_cast\u003cGUInt32 *\u003e(pImage)[iPixel++] = nOutWord;\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n            }\n          }\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffBitmapBand                          */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand : public GTiffOddBitsBand\n{\n    friend class GTiffDataset;\n\n    GDALColorTable *poColorTable = nullptr;\n\n    CPL_DISALLOW_COPY_ASSIGN(GTiffBitmapBand)\n\n  public:\n\n                   GTiffBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffBitmapBand();\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n    virtual GDALColorTable *GetColorTable() override;\n};\n\n/************************************************************************/\n/*                           GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::GTiffBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffOddBitsBand( poDSIn, nBandIn )\n\n{\n    eDataType = GDT_Byte;\n\n    if( poDSIn-\u003epoColorTable != nullptr )\n    {\n        poColorTable = poDSIn-\u003epoColorTable-\u003eClone();\n    }\n    else\n    {\n#ifdef ESRI_BUILD\n        poColorTable = nullptr;\n#else\n        const GDALColorEntry oWhite = { 255, 255, 255, 255 };\n        const GDALColorEntry oBlack = { 0, 0, 0, 255 };\n\n        poColorTable = new GDALColorTable();\n\n        if( poDSIn-\u003enPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            poColorTable-\u003eSetColorEntry( 0, \u0026oWhite );\n            poColorTable-\u003eSetColorEntry( 1, \u0026oBlack );\n        }\n        else\n        {\n            poColorTable-\u003eSetColorEntry( 0, \u0026oBlack );\n            poColorTable-\u003eSetColorEntry( 1, \u0026oWhite );\n        }\n#endif  // not defined ESRI_BUILD.\n    }\n}\n\n/************************************************************************/\n/*                          ~GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::~GTiffBitmapBand()\n\n{\n    delete poColorTable;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffBitmapBand::GetColorInterpretation()\n\n{\n    if( poGDS-\u003ebPromoteTo8Bits )\n        return GCI_Undefined;\n\n    return GCI_PaletteIndex;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffBitmapBand::GetColorTable()\n\n{\n    if( poGDS-\u003ebPromoteTo8Bits )\n        return nullptr;\n\n    return poColorTable;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffSplitBitmapBand                        */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBitmapBand final : public GTiffBitmapBand\n{\n    friend class GTiffDataset;\n    int nLastLineValid;\n\n  public:\n\n                   GTiffSplitBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffSplitBitmapBand();\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                       GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::GTiffSplitBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffBitmapBand( poDSIn, nBandIn )\n        , nLastLineValid( -1 )\n\n{\n    nBlockXSize = poDS-\u003eGetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                      ~GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::~GTiffSplitBitmapBand() {}\n\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBitmapBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            GTIFFErrorHandler()                       */\n/************************************************************************/\n\nnamespace {\nclass GTIFFErrorStruct final\n{\n  public:\n    CPLErr type;\n    CPLErrorNum no;\n    CPLString msg{};\n\n    GTIFFErrorStruct() : type(CE_None), no(CPLE_None) {}\n    GTIFFErrorStruct(CPLErr eErrIn, CPLErrorNum noIn, const char* msgIn) :\n        type(eErrIn), no(noIn), msg(msgIn) {}\n};\n}\n\nstatic void CPL_STDCALL GTIFFErrorHandler( CPLErr eErr, CPLErrorNum no,\n                                           const char* msg )\n{\n    std::vector\u003cGTIFFErrorStruct\u003e* paoErrors =\n        static_cast\u003cstd::vector\u003cGTIFFErrorStruct\u003e *\u003e(\n            CPLGetErrorHandlerUserData());\n    paoErrors-\u003epush_back(GTIFFErrorStruct(eErr, no, msg));\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                         void * pImage )\n\n{\n    if( nLastLineValid \u003e= 0 \u0026\u0026 nBlockYOff \u003e nLastLineValid )\n        return CE_Failure;\n\n    if( !poGDS-\u003eSetDirectory() )\n        return CE_Failure;\n\n    if( poGDS-\u003epabyBlockBuf == nullptr )\n    {\n        poGDS-\u003epabyBlockBuf =\n            static_cast\u003cGByte *\u003e(\n                VSI_MALLOC_VERBOSE(TIFFScanlineSize(poGDS-\u003ehTIFF)) );\n        if( poGDS-\u003epabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS-\u003enLastLineRead \u003e= nBlockYOff )\n        poGDS-\u003enLastLineRead = -1;\n\n    while( poGDS-\u003enLastLineRead \u003c nBlockYOff )\n    {\n        ++poGDS-\u003enLastLineRead;\n\n        std::vector\u003cGTIFFErrorStruct\u003e aoErrors;\n        CPLPushErrorHandlerEx(GTIFFErrorHandler, \u0026aoErrors);\n        int nRet = TIFFReadScanline( poGDS-\u003ehTIFF, poGDS-\u003epabyBlockBuf,\n                                     poGDS-\u003enLastLineRead, 0 );\n        CPLPopErrorHandler();\n\n        for( size_t iError = 0; iError \u003c aoErrors.size(); ++iError )\n        {\n            CPLError( aoErrors[iError].type,\n                      aoErrors[iError].no,\n                      \"%s\",\n                      aoErrors[iError].msg.c_str() );\n            // FAX decoding only handles EOF condition as a warning, so\n            // catch it so as to turn on error when attempting to read\n            // following lines, to avoid performance issues.\n            if(  !poGDS-\u003ebIgnoreReadErrors \u0026\u0026\n                    aoErrors[iError].msg.find(\"Premature EOF\") !=\n                                                    std::string::npos )\n            {\n                nLastLineValid = nBlockYOff;\n                nRet = -1;\n            }\n        }\n\n        if( nRet == -1\n            \u0026\u0026 !poGDS-\u003ebIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            poGDS-\u003enLastLineRead = -1;\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n    int iSrcOffset = 0;\n    int iDstOffset = 0;\n\n    for( int iPixel = 0; iPixel \u003c nBlockXSize; ++iPixel, ++iSrcOffset )\n    {\n        if( poGDS-\u003epabyBlockBuf[iSrcOffset \u003e\u003e3] \u0026 (0x80 \u003e\u003e (iSrcOffset \u0026 0x7)) )\n            static_cast\u003cGByte *\u003e(pImage)[iDstOffset++] = 1;\n        else\n            static_cast\u003cGByte *\u003e(pImage)[iDstOffset++] = 0;\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IWriteBlock( int /* nBlockXOff */,\n                                          int /* nBlockYOff */,\n                                          void * /* pImage */ )\n\n{\n    CPLError( CE_Failure, CPLE_AppDefined,\n              \"Split bitmap bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffDataset                              */\n/* ==================================================================== */\n/************************************************************************/\n\n/************************************************************************/\n/*                            GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::GTiffDataset() :\n    hTIFF(nullptr),\n    fpL(nullptr),\n#if defined(INTERNAL_LIBTIFF) \u0026\u0026 defined(DEFER_STRILE_LOAD)\n    nStripArrayAlloc(0),\n    m_nFileSize(0),\n#endif\n    bStreamingIn(false),\n    bStreamingOut(false),\n    fpToWrite(nullptr),\n    nLastWrittenBlockId(-1),\n    ppoActiveDSRef(nullptr),\n    poActiveDS(nullptr),\n    bScanDeferred(true),\n    nDirOffset(0),\n    bBase(true),\n    bCloseTIFFHandle(false),\n    nPlanarConfig(0),\n    nSamplesPerPixel(0),\n    nBitsPerSample(0),\n    nRowsPerStrip(0),\n    nPhotometric(0),\n    nSampleFormat(0),\n    nCompression(0),\n    nBlocksPerBand(0),\n    nBlockXSize(0),\n    nBlockYSize(0),\n    nLoadedBlock(-1),\n    bLoadedBlockDirty(false),\n    pabyBlockBuf(nullptr),\n    bWriteErrorInFlushBlockBuf(false),\n    pszProjection(CPLStrdup(\"\")),\n    bLookedForProjection(false),\n    bLookedForMDAreaOrPoint(false),\n    bGeoTransformValid(false),\n    bTreatAsRGBA(false),\n    bCrystalized(true),\n    poColorTable(nullptr),\n    nOverviewCount(0),\n    papoOverviewDS(nullptr),\n    nJPEGOverviewVisibilityCounter(0),\n    nJPEGOverviewCount(-1),\n    nJPEGOverviewCountOri(0),\n    papoJPEGOverviewDS(nullptr),\n    nGCPCount(0),\n    pasGCPList(nullptr),\n    bGeoTIFFInfoChanged(false),\n    bForceUnsetGTOrGCPs(false),\n    bForceUnsetProjection(false),\n    bNoDataChanged(false),\n    bNoDataSet(false),\n    dfNoDataValue(-9999.0),\n    bMetadataChanged(false),\n    bColorProfileMetadataChanged(false),\n    bNeedsRewrite(false),\n    osProfile(szPROFILE_GDALGeoTIFF),\n    papszCreationOptions(nullptr),\n    bLoadingOtherBands(false),\n    pabyTempWriteBuffer(nullptr),\n    nTempWriteBufferSize(0),\n    poMaskDS(nullptr),\n    poBaseDS(nullptr),\n    bWriteEmptyTiles(true),\n    bFillEmptyTilesAtClosing(false),\n    nLastLineRead(-1),\n    nLastBandRead(-1),\n    bTreatAsSplit(false),\n    bTreatAsSplitBitmap(false),\n    bClipWarn(false),\n    bIMDRPCMetadataLoaded(false),\n    papszMetadataFiles(nullptr),\n    bEXIFMetadataLoaded(false),\n    bICCMetadataLoaded(false),\n    bHasWarnedDisableAggressiveBandCaching(false),\n    bDontReloadFirstBlock(false),\n    nZLevel(-1),\n    nLZMAPreset(-1),\n    nZSTDLevel(-1),\n    nWebPLevel(-1),\n    bWebPLossless(false),\n    nJpegQuality(-1),\n    nJpegTablesMode(-1),\n    bPromoteTo8Bits(false),\n    bDebugDontWriteBlocks(false),\n    bIsFinalized(false),\n    bIgnoreReadErrors(false),\n    bDirectIO(false),\n    eVirtualMemIOUsage(VIRTUAL_MEM_IO_NO),\n    psVirtualMemIOMapping(nullptr),\n    eGeoTIFFKeysFlavor(GEOTIFF_KEYS_STANDARD),\n    pBaseMapping(nullptr),\n    nRefBaseMapping(0),\n    bHasDiscardedLsb(false),\n    poCompressThreadPool(nullptr),\n    hCompressThreadPoolMutex(nullptr),\n    m_pTempBufferForCommonDirectIO(nullptr),\n    m_nTempBufferForCommonDirectIOSize(0),\n    m_bReadGeoTransform(false),\n    m_bLoadPam(false),\n    m_bHasGotSiblingFiles(false),\n    m_bHasIdentifiedAuthorizedGeoreferencingSources(false),\n    m_nPAMGeorefSrcIndex(-1),\n    m_nINTERNALGeorefSrcIndex(-1),\n    m_nTABFILEGeorefSrcIndex(-1),\n    m_nWORLDFILEGeorefSrcIndex(-1),\n    m_nGeoTransformGeorefSrcIndex(-1)\n{\n    adfGeoTransform[0] = 0.0;\n    adfGeoTransform[1] = 1.0;\n    adfGeoTransform[2] = 0.0;\n    adfGeoTransform[3] = 0.0;\n    adfGeoTransform[4] = 0.0;\n    adfGeoTransform[5] = 1.0;\n\n    bDebugDontWriteBlocks =\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_DONT_WRITE_BLOCKS\", \"NO\"));\n\n    bIgnoreReadErrors =\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_IGNORE_READ_ERRORS\", \"NO\"));\n\n    bDirectIO = CPLTestBool(CPLGetConfigOption(\"GTIFF_DIRECT_IO\", \"NO\"));\n\n    const char* pszVirtualMemIO =\n        CPLGetConfigOption(\"GTIFF_VIRTUAL_MEM_IO\", \"NO\");\n    if( EQUAL(pszVirtualMemIO, \"IF_ENOUGH_RAM\") )\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_IF_ENOUGH_RAM;\n    else if( CPLTestBool(pszVirtualMemIO) )\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_YES;\n}\n\n/************************************************************************/\n/*                           ~GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::~GTiffDataset()\n\n{\n    Finalize();\n    if( !osTmpFilename.empty() )\n        VSIUnlink(osTmpFilename);\n}\n\n/************************************************************************/\n/*                             Finalize()                               */\n/************************************************************************/\n\nint GTiffDataset::Finalize()\n{\n    if( bIsFinalized )\n        return FALSE;\n\n    bool bHasDroppedRef = false;\n\n    Crystalize();\n\n    if( bColorProfileMetadataChanged )\n    {\n        SaveICCProfile(this, nullptr, nullptr, 0);\n        bColorProfileMetadataChanged = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = GTiffDataset::GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            GDALPamDataset::SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n    if( psVirtualMemIOMapping )\n        CPLVirtualMemFree( psVirtualMemIOMapping );\n    psVirtualMemIOMapping = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Fill in missing blocks with empty data.                         */\n/* -------------------------------------------------------------------- */\n    if( bFillEmptyTilesAtClosing )\n    {\n/* -------------------------------------------------------------------- */\n/*  Ensure any blocks write cached by GDAL gets pushed through libtiff. */\n/* -------------------------------------------------------------------- */\n        FlushCacheInternal( false /* do not call FlushDirectory */ );\n\n        FillEmptyTiles();\n        bFillEmptyTilesAtClosing = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Force a complete flush, including either rewriting(moving)      */\n/*      of writing in place the current directory.                      */\n/* -------------------------------------------------------------------- */\n    FlushCacheInternal( true );\n\n    // Destroy compression pool.\n    if( poCompressThreadPool )\n    {\n        poCompressThreadPool-\u003eWaitCompletion();\n\n        // Save thread pool for later reuse.\n        {\n            std::lock_guard\u003cstd::mutex\u003e oLock(gMutexThreadPool);\n            delete gpoCompressThreadPool;\n            gpoCompressThreadPool = poCompressThreadPool;\n            poCompressThreadPool = nullptr;\n        }\n\n        for( int i = 0; i \u003c static_cast\u003cint\u003e(asCompressionJobs.size()); ++i )\n        {\n            CPLFree(asCompressionJobs[i].pabyBuffer);\n            if( asCompressionJobs[i].pszTmpFilename )\n            {\n                VSIUnlink(asCompressionJobs[i].pszTmpFilename);\n                CPLFree(asCompressionJobs[i].pszTmpFilename);\n            }\n        }\n        CPLDestroyMutex(hCompressThreadPoolMutex);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there is still changed metadata, then presumably we want     */\n/*      to push it into PAM.                                            */\n/* -------------------------------------------------------------------- */\n    if( bMetadataChanged )\n    {\n        PushMetadataToPam();\n        bMetadataChanged = false;\n        GDALPamDataset::FlushCache();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews.                                              */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        for( int i = 0; i \u003c nOverviewCount; ++i )\n        {\n            delete papoOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        nOverviewCount = 0;\n\n        for( int i = 0; i \u003c nJPEGOverviewCountOri; ++i )\n        {\n            delete papoJPEGOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        nJPEGOverviewCount = 0;\n        nJPEGOverviewCountOri = 0;\n        CPLFree( papoJPEGOverviewDS );\n        papoJPEGOverviewDS = nullptr;\n    }\n\n    // If we are a mask dataset, we can have overviews, but we don't\n    // own them. We can only free the array, not the overviews themselves.\n    CPLFree( papoOverviewDS );\n    papoOverviewDS = nullptr;\n\n    // poMaskDS is owned by the main image and the overviews\n    // so because of the latter case, we can delete it even if\n    // we are not the base image.\n    if( poMaskDS )\n    {\n        delete poMaskDS;\n        poMaskDS = nullptr;\n        bHasDroppedRef = true;\n    }\n\n    if( poColorTable != nullptr )\n        delete poColorTable;\n    poColorTable = nullptr;\n\n    if( bBase || bCloseTIFFHandle )\n    {\n        XTIFFClose( hTIFF );\n        hTIFF = nullptr;\n        if( fpL != nullptr )\n        {\n            if( VSIFCloseL( fpL ) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO, \"I/O error\");\n            }\n            fpL = nullptr;\n        }\n    }\n\n    if( fpToWrite != nullptr )\n    {\n        if( VSIFCloseL( fpToWrite ) != 0 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO, \"I/O error\");\n        }\n        fpToWrite = nullptr;\n    }\n\n    if( nGCPCount \u003e 0 )\n    {\n        GDALDeinitGCPs( nGCPCount, pasGCPList );\n        CPLFree( pasGCPList );\n        pasGCPList = nullptr;\n        nGCPCount = 0;\n    }\n\n    CPLFree( pszProjection );\n    pszProjection = nullptr;\n\n    CSLDestroy( papszCreationOptions );\n    papszCreationOptions = nullptr;\n\n    CPLFree(pabyTempWriteBuffer);\n    pabyTempWriteBuffer = nullptr;\n\n    if( ppoActiveDSRef != nullptr \u0026\u0026 *ppoActiveDSRef == this )\n        *ppoActiveDSRef = nullptr;\n    ppoActiveDSRef = nullptr;\n\n    bIMDRPCMetadataLoaded = false;\n    CSLDestroy(papszMetadataFiles);\n    papszMetadataFiles = nullptr;\n\n    VSIFree(m_pTempBufferForCommonDirectIO);\n    m_pTempBufferForCommonDirectIO = nullptr;\n\n    bIsFinalized = true;\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        CloseDependentDatasets()                      */\n/************************************************************************/\n\nint GTiffDataset::CloseDependentDatasets()\n{\n    if( !bBase )\n        return FALSE;\n\n    int bHasDroppedRef = GDALPamDataset::CloseDependentDatasets();\n\n    bHasDroppedRef |= Finalize();\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        GetJPEGOverviewCount()                        */\n/************************************************************************/\n\nint GTiffDataset::GetJPEGOverviewCount()\n{\n    if( nJPEGOverviewCount \u003e= 0 )\n        return nJPEGOverviewCount;\n\n    nJPEGOverviewCount = 0;\n    if( !bBase || eAccess != GA_ReadOnly || nCompression != COMPRESSION_JPEG ||\n        (nRasterXSize \u003c 256 \u0026\u0026 nRasterYSize \u003c 256) ||\n        !CPLTestBool(CPLGetConfigOption(\"GTIFF_IMPLICIT_JPEG_OVR\", \"YES\")) ||\n        GDALGetDriverByName(\"JPEG\") == nullptr )\n    {\n        return 0;\n    }\n    const char* pszSourceColorSpace =\n        oGTiffMDMD.GetMetadataItem( \"SOURCE_COLOR_SPACE\", \"IMAGE_STRUCTURE\" );\n    if( pszSourceColorSpace != nullptr \u0026\u0026 EQUAL(pszSourceColorSpace, \"CMYK\") )\n    {\n        // We cannot handle implicit overviews on JPEG CMYK datasets converted\n        // to RGBA This would imply doing the conversion in\n        // GTiffJPEGOverviewBand.\n        return 0;\n    }\n\n    // libjpeg-6b only supports 2, 4 and 8 scale denominators.\n    // TODO: Later versions support more.\n    for( int i = 2; i \u003e= 0; i-- )\n    {\n        if( nRasterXSize \u003e= (256 \u003c\u003c i) || nRasterYSize \u003e= (256 \u003c\u003c i) )\n        {\n            nJPEGOverviewCount = i + 1;\n            break;\n        }\n    }\n    if( nJPEGOverviewCount == 0 )\n        return 0;\n\n    if( !SetDirectory() )\n    {\n        nJPEGOverviewCount = 0;\n        return 0;\n    }\n\n    // Get JPEG tables.\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    GByte abyFFD8[] = { 0xFF, 0xD8 };\n    if( TIFFGetField(hTIFF, TIFFTAG_JPEGTABLES, \u0026nJPEGTableSize, \u0026pJPEGTable) )\n    {\n        if( pJPEGTable == nullptr ||\n            nJPEGTableSize \u003e INT_MAX ||\n            static_cast\u003cGByte*\u003e(pJPEGTable)[nJPEGTableSize-1] != 0xD9 )\n        {\n            nJPEGOverviewCount = 0;\n            return 0;\n        }\n        nJPEGTableSize--;  // Remove final 0xD9.\n    }\n    else\n    {\n        pJPEGTable = abyFFD8;\n        nJPEGTableSize = 2;\n    }\n\n    papoJPEGOverviewDS =\n        static_cast\u003cGTiffJPEGOverviewDS **\u003e(\n            CPLMalloc( sizeof(GTiffJPEGOverviewDS*) * nJPEGOverviewCount ) );\n    for( int i = 0; i \u003c nJPEGOverviewCount; ++i )\n    {\n        papoJPEGOverviewDS[i] =\n            new GTiffJPEGOverviewDS(\n                this, i + 1,\n                pJPEGTable, static_cast\u003cint\u003e(nJPEGTableSize) );\n    }\n\n    nJPEGOverviewCountOri = nJPEGOverviewCount;\n\n    return nJPEGOverviewCount;\n}\n\n/************************************************************************/\n/*                           FillEmptyTiles()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FillEmptyTiles()\n\n{\n    if( !SetDirectory() )\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    const int nBlockCount =\n        nPlanarConfig == PLANARCONFIG_SEPARATE ?\n        nBlocksPerBand * nBands :\n        nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    toff_t *panByteCounts = nullptr;\n\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, \u0026panByteCounts );\n    else\n        TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, \u0026panByteCounts );\n\n    if( panByteCounts == nullptr )\n    {\n        // Got here with libtiff 3.9.3 and tiff_write_8 test.\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"FillEmptyTiles() failed because panByteCounts == NULL\" );\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    const int nBlockBytes =\n        TIFFIsTiled( hTIFF ) ?\n        static_cast\u003cint\u003e(TIFFTileSize(hTIFF)) :\n        static_cast\u003cint\u003e(TIFFStripSize(hTIFF));\n\n    GByte *pabyData =\n        static_cast\u003cGByte *\u003e( VSI_CALLOC_VERBOSE(nBlockBytes, 1) );\n    if( pabyData == nullptr )\n    {\n        return;\n    }\n\n    // Force tiles completely filled with the nodata value to be written.\n    bWriteEmptyTiles = true;\n\n/* -------------------------------------------------------------------- */\n/*      If set, fill data buffer with no data value.                    */\n/* -------------------------------------------------------------------- */\n    if( bNoDataSet \u0026\u0026 dfNoDataValue != 0.0 )\n    {\n        const GDALDataType eDataType = GetRasterBand( 1 )-\u003eGetRasterDataType();\n        const int nDataTypeSize = GDALGetDataTypeSizeBytes( eDataType );\n        if( nDataTypeSize \u0026\u0026\n            nDataTypeSize * 8 == static_cast\u003cint\u003e(nBitsPerSample) )\n        {\n            GDALCopyWords( \u0026dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockBytes / nDataTypeSize );\n        }\n        else if( nDataTypeSize )\n        {\n            // Handle non power-of-two depths.\n            // Ideally make a packed buffer, but that is a bit tedious,\n            // so use the normal I/O interfaces.\n\n            CPLFree( pabyData );\n\n            pabyData = static_cast\u003cGByte *\u003e(\n                VSI_MALLOC3_VERBOSE(nBlockXSize, nBlockYSize, nDataTypeSize) );\n            if( pabyData == nullptr )\n                return;\n            GDALCopyWords( \u0026dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockXSize * nBlockYSize );\n            const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n            for( int iBlock = 0; iBlock \u003c nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    if( nPlanarConfig == PLANARCONFIG_SEPARATE || nBands == 1 )\n                    {\n                        CPL_IGNORE_RET_VAL( GetRasterBand(\n                            1 + iBlock / nBlocksPerBand )-\u003eWriteBlock(\n                                (iBlock % nBlocksPerBand) % nBlocksPerRow,\n                                (iBlock % nBlocksPerBand) / nBlocksPerRow,\n                                pabyData ) );\n                    }\n                    else\n                    {\n                        // In contig case, don't directly call WriteBlock(), as\n                        // it could cause useless decompression-recompression.\n                        const int nXOff =\n                            (iBlock % nBlocksPerRow) * nBlockXSize;\n                        const int nYOff =\n                            (iBlock / nBlocksPerRow) * nBlockYSize;\n                        const int nXSize =\n                            (nXOff + nBlockXSize \u003c= nRasterXSize) ?\n                            nBlockXSize : nRasterXSize - nXOff;\n                        const int nYSize =\n                            (nYOff + nBlockYSize \u003c= nRasterYSize) ?\n                            nBlockYSize : nRasterYSize - nYOff;\n                        for( int iBand = 1; iBand \u003c= nBands; ++iBand )\n                        {\n                            CPL_IGNORE_RET_VAL( GetRasterBand( iBand )-\u003e\n                                RasterIO(\n                                    GF_Write, nXOff, nYOff, nXSize, nYSize,\n                                    pabyData, nXSize, nYSize,\n                                    eDataType, 0, 0, nullptr ) );\n                        }\n                    }\n                }\n            }\n            CPLFree( pabyData );\n            return;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      When we must fill with zeroes, try to create non-sparse file    */\n/*      w.r.t TIFF spec ... as a sparse file w.r.t filesystem, ie by    */\n/*      seeking to end of file instead of writing zero blocks.          */\n/* -------------------------------------------------------------------- */\n    else if( nCompression == COMPRESSION_NONE \u0026\u0026 (nBitsPerSample % 8) == 0 )\n    {\n        // Only use libtiff to write the first sparse block to ensure that it\n        // will serialize offset and count arrays back to disk.\n        int nCountBlocksToZero = 0;\n        for( int iBlock = 0; iBlock \u003c nBlockCount; ++iBlock )\n        {\n            if( panByteCounts[iBlock] == 0 )\n            {\n                if( nCountBlocksToZero == 0 )\n                {\n                    const bool bWriteEmptyTilesBak = bWriteEmptyTiles;\n                    bWriteEmptyTiles = true;\n                    const bool bOK =\n                        WriteEncodedTileOrStrip( iBlock, pabyData,\n                                                 FALSE ) == CE_None;\n                    bWriteEmptyTiles = bWriteEmptyTilesBak;\n                    if( !bOK )\n                        break;\n                }\n                nCountBlocksToZero++;\n            }\n        }\n        CPLFree( pabyData );\n\n        --nCountBlocksToZero;\n\n        // And then seek to end of file for other ones.\n        if( nCountBlocksToZero \u003e 0 )\n        {\n            toff_t *panByteOffsets = nullptr;\n\n            if( TIFFIsTiled( hTIFF ) )\n                TIFFGetField( hTIFF, TIFFTAG_TILEOFFSETS, \u0026panByteOffsets );\n            else\n                TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, \u0026panByteOffsets );\n\n            if( panByteOffsets == nullptr )\n            {\n                CPLError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"FillEmptyTiles() failed because panByteOffsets == NULL\");\n                return;\n            }\n\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            VSIFSeekL( fpTIF, 0, SEEK_END );\n            const vsi_l_offset nOffset = VSIFTellL(fpTIF);\n\n            vsi_l_offset iBlockToZero = 0;\n            for( int iBlock = 0; iBlock \u003c nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    panByteOffsets[iBlock] = static_cast\u003ctoff_t\u003e(\n                                        nOffset + iBlockToZero * nBlockBytes);\n                    panByteCounts[iBlock] = nBlockBytes;\n                    iBlockToZero++;\n                }\n            }\n            CPLAssert( iBlockToZero ==\n                       static_cast\u003cvsi_l_offset\u003e(nCountBlocksToZero) );\n\n            if( VSIFTruncateL( fpTIF,\n                               nOffset + iBlockToZero * nBlockBytes ) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO,\n                         \"Cannot initialize empty blocks\");\n            }\n        }\n\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n\n    GByte* pabyRaw = nullptr;\n    vsi_l_offset nRawSize = 0;\n    for( int iBlock = 0; iBlock \u003c nBlockCount; ++iBlock )\n    {\n        if( panByteCounts[iBlock] == 0 )\n        {\n            if( pabyRaw == nullptr )\n            {\n                if( WriteEncodedTileOrStrip( iBlock, pabyData, FALSE\n                                                                ) != CE_None )\n                    break;\n\n                vsi_l_offset nOffset = 0;\n                bool b = IsBlockAvailable( iBlock, \u0026nOffset, \u0026nRawSize);\n#ifdef DEBUG\n                CPLAssert(b);\n#else\n                CPL_IGNORE_RET_VAL(b);\n#endif\n                // When using compression, get back the compressed block\n                // so we can use the raw API to write it faster.\n                if( nCompression != COMPRESSION_NONE )\n                {\n                    pabyRaw = static_cast\u003cGByte*\u003e(\n                            VSI_MALLOC_VERBOSE(static_cast\u003cint\u003e(nRawSize)));\n                    if( pabyRaw )\n                    {\n                        VSILFILE* fp = VSI_TIFFGetVSILFile(\n                                                    TIFFClientdata( hTIFF ));\n                        const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                        VSIFSeekL(fp, nOffset, SEEK_SET);\n                        VSIFReadL(pabyRaw, 1, static_cast\u003cint\u003e(nRawSize), fp);\n                        VSIFSeekL(fp, nCurOffset, SEEK_SET);\n                    }\n                }\n            }\n            else\n            {\n                WriteRawStripOrTile( iBlock, pabyRaw,\n                                     static_cast\u003cint\u003e(nRawSize) );\n            }\n        }\n    }\n\n    CPLFree( pabyData );\n    VSIFree( pabyRaw );\n}\n\n/************************************************************************/\n/*                         HasOnlyNoData()                              */\n/************************************************************************/\n\ntemplate\u003cclass T\u003e\nstatic inline bool IsEqualToNoData( T value, T noDataValue )\n{\n    return value == noDataValue;\n}\n\ntemplate\u003c\u003e bool IsEqualToNoData\u003cfloat\u003e( float value, float noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate\u003c\u003e bool IsEqualToNoData\u003cdouble\u003e( double value, double noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate\u003cclass T\u003e\nbool GTiffDataset::HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                   int nLineStride, int nComponents ) const\n{\n    const T noDataValue = static_cast\u003cT\u003e((bNoDataSet) ? dfNoDataValue : 0.0);\n    // Fast test: check the 4 corners and the middle pixel.\n    for( int iBand = 0; iBand \u003c nComponents; iBand++ )\n    {\n        if( !(IsEqualToNoData(pBuffer[iBand], noDataValue) \u0026\u0026\n              IsEqualToNoData(\n                  pBuffer[static_cast\u003csize_t\u003e(nWidth - 1) * nComponents +\n                          iBand],\n                  noDataValue) \u0026\u0026\n              IsEqualToNoData(\n                  pBuffer[(static_cast\u003csize_t\u003e(nHeight-1)/2 * nLineStride +\n                           (nWidth - 1)/2) * nComponents + iBand],\n                  noDataValue) \u0026\u0026\n              IsEqualToNoData(\n                  pBuffer[static_cast\u003csize_t\u003e(nHeight - 1) * nLineStride *\n                          nComponents + iBand], noDataValue) \u0026\u0026\n              IsEqualToNoData(\n                  pBuffer[(static_cast\u003csize_t\u003e(nHeight - 1) * nLineStride +\n                           nWidth - 1) * nComponents + iBand], noDataValue) ) )\n        {\n            return false;\n        }\n    }\n\n    // Test all pixels.\n    for( int iY = 0; iY \u003c nHeight; iY++ )\n    {\n        for( int iX = 0; iX \u003c nWidth * nComponents; iX++ )\n        {\n            if( !IsEqualToNoData(\n                   pBuffer[iY * static_cast\u003csize_t\u003e(nLineStride) * nComponents +\n                           iX], noDataValue) )\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool GTiffDataset::HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                  int nLineStride, int nComponents )\n{\n    const GDALDataType eDT = GetRasterBand(1)-\u003eGetRasterDataType();\n\n    // In the case where the nodata is 0, we can compare several bytes at\n    // once. Select the largest natural integer type for the architecture.\n#if SIZEOF_VOIDP == 8 || defined(__x86_64__)\n    // We test __x86_64__ for x32 arch where SIZEOF_VOIDP == 4\n    typedef GUInt64 WordType;\n#else\n    typedef unsigned int WordType;\n#endif\n    if( (!bNoDataSet || dfNoDataValue == 0.0) \u0026\u0026 nWidth == nLineStride\n#ifdef CPL_CPU_REQUIRES_ALIGNED_ACCESS\n        \u0026\u0026 CPL_IS_ALIGNED(pBuffer, sizeof(WordType))\n#endif\n        )\n    {\n        const GByte* pabyBuffer = static_cast\u003cconst GByte*\u003e(pBuffer);\n        const size_t nSize = static_cast\u003csize_t\u003e(nWidth) * nHeight *\n                             nComponents * GDALGetDataTypeSizeBytes(eDT);\n        size_t i = 0;\n        for( ; i + sizeof(WordType) - 1 \u003c nSize; i += sizeof(WordType) )\n        {\n            if( *(reinterpret_cast\u003cconst WordType*\u003e(pabyBuffer + i)) )\n                return false;\n        }\n        for( ; i \u003c nSize; i++ )\n        {\n            if( pabyBuffer[i] )\n                return false;\n        }\n        return true;\n    }\n\n    if( nBitsPerSample == 8 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return HasOnlyNoDataT(static_cast\u003cconst signed char*\u003e(pBuffer),\n                                  nWidth, nHeight, nLineStride, nComponents);\n        }\n        return HasOnlyNoDataT(static_cast\u003cconst GByte*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 16 \u0026\u0026 eDT == GDT_UInt16 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst GUInt16*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 16 \u0026\u0026 eDT== GDT_Int16 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst GInt16*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 32 \u0026\u0026 eDT == GDT_UInt32 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst GUInt32*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 32 \u0026\u0026 eDT == GDT_Int32 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst GInt32*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 32 \u0026\u0026 eDT == GDT_Float32 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst float*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 64 \u0026\u0026 eDT == GDT_Float64 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst double*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                     IsFirstPixelEqualToNoData()                      */\n/************************************************************************/\n\ninline bool GTiffDataset::IsFirstPixelEqualToNoData( const void* pBuffer )\n{\n    const GDALDataType eDT = GetRasterBand(1)-\u003eGetRasterDataType();\n    const double dfEffectiveNoData = (bNoDataSet) ? dfNoDataValue : 0.0;\n    if( nBitsPerSample == 8 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return GDALIsValueInRange\u003csigned char\u003e(dfEffectiveNoData) \u0026\u0026\n                   *(static_cast\u003cconst signed char*\u003e(pBuffer)) ==\n                        static_cast\u003csigned char\u003e(dfEffectiveNoData);\n        }\n        return GDALIsValueInRange\u003cGByte\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst GByte*\u003e(pBuffer)) ==\n                        static_cast\u003cGByte\u003e(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 16 \u0026\u0026 eDT == GDT_UInt16 )\n    {\n        return GDALIsValueInRange\u003cGUInt16\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst GUInt16*\u003e(pBuffer)) ==\n                        static_cast\u003cGUInt16\u003e(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 16 \u0026\u0026 eDT == GDT_Int16 )\n    {\n        return GDALIsValueInRange\u003cGInt16\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst GInt16*\u003e(pBuffer)) ==\n                        static_cast\u003cGInt16\u003e(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 32 \u0026\u0026 eDT == GDT_UInt32 )\n    {\n        return GDALIsValueInRange\u003cGUInt32\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst GUInt32*\u003e(pBuffer)) ==\n                        static_cast\u003cGUInt32\u003e(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 32 \u0026\u0026 eDT == GDT_Int32 )\n    {\n        return GDALIsValueInRange\u003cGInt32\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst GInt32*\u003e(pBuffer)) ==\n                        static_cast\u003cGInt32\u003e(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 32 \u0026\u0026 eDT == GDT_Float32 )\n    {\n        if( CPLIsNan(dfNoDataValue) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast\u003cconst float*\u003e(pBuffer))));\n        return GDALIsValueInRange\u003cfloat\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst float*\u003e(pBuffer)) ==\n                        static_cast\u003cfloat\u003e(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 64 \u0026\u0026 eDT == GDT_Float64 )\n    {\n        if( CPLIsNan(dfEffectiveNoData) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast\u003cconst double*\u003e(pBuffer))));\n        return *(static_cast\u003cconst double*\u003e(pBuffer)) == dfEffectiveNoData;\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                        WriteEncodedTile()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedTile( uint32 tile, GByte *pabyData,\n                                     int bPreserveDataBuffer )\n{\n    int iRow = 0;\n    int iColumn = 0;\n    int nBlocksPerRow = 1;\n    int nBlocksPerColumn = 1;\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !bWriteEmptyTiles \u0026\u0026 IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(tile) )\n        {\n            const int nComponents =\n                nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n            nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n            nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n\n            iColumn = (tile % nBlocksPerBand) % nBlocksPerRow;\n            iRow = (tile % nBlocksPerBand) / nBlocksPerRow;\n\n            const int nActualBlockWidth =\n                ( iColumn == nBlocksPerRow - 1 ) ?\n                nRasterXSize - iColumn * nBlockXSize : nBlockXSize;\n            const int nActualBlockHeight =\n                ( iRow == nBlocksPerColumn - 1 ) ?\n                nRasterYSize - iRow * nBlockYSize : nBlockYSize;\n\n            if( HasOnlyNoData(pabyData,\n                              nActualBlockWidth, nActualBlockHeight,\n                              nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n    // Do we need to spread edge values right or down for a partial\n    // JPEG encoded tile?  We do this to avoid edge artifacts.\n    bool bNeedTileFill = false;\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n\n        iColumn = (tile % nBlocksPerBand) % nBlocksPerRow;\n        iRow = (tile % nBlocksPerBand) / nBlocksPerRow;\n\n        // Is this a partial right edge tile?\n        if( iRow == nBlocksPerRow - 1\n            \u0026\u0026 nRasterXSize % nBlockXSize != 0 )\n            bNeedTileFill = true;\n\n        // Is this a partial bottom edge tile?\n        if( iColumn == nBlocksPerColumn - 1\n            \u0026\u0026 nRasterYSize % nBlockYSize != 0 )\n            bNeedTileFill = true;\n    }\n\n    // If we need to fill out the tile, or if we want to prevent\n    // TIFFWriteEncodedTile from altering the buffer as part of\n    // byte swapping the data on write then we will need a temporary\n    // working buffer.  If not, we can just do a direct write.\n    const int cc = static_cast\u003cint\u003e(TIFFTileSize( hTIFF ));\n\n    if( bPreserveDataBuffer\n        \u0026\u0026 (TIFFIsByteSwapped(hTIFF) || bNeedTileFill || bHasDiscardedLsb) )\n    {\n        if( cc != nTempWriteBufferSize )\n        {\n            pabyTempWriteBuffer = CPLRealloc(pabyTempWriteBuffer, cc);\n            nTempWriteBufferSize = cc;\n        }\n        memcpy(pabyTempWriteBuffer, pabyData, cc);\n\n        pabyData = static_cast\u003cGByte *\u003e( pabyTempWriteBuffer );\n    }\n\n    // Perform tile fill if needed.\n    // TODO: we should also handle the case of nBitsPerSample == 12\n    // but this is more involved.\n    if( bNeedTileFill \u0026\u0026 nBitsPerSample == 8 )\n    {\n        const int nComponents =\n            nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n        CPLDebug( \"GTiff\", \"Filling out jpeg edge tile on write.\" );\n\n        const int nRightPixelsToFill =\n            iColumn == nBlocksPerRow - 1 ?\n            nBlockXSize * (iColumn + 1) - nRasterXSize :\n            0;\n        const int nBottomPixelsToFill =\n            iRow == nBlocksPerColumn - 1 ?\n            nBlockYSize * (iRow + 1) - nRasterYSize :\n            0;\n\n        // Fill out to the right.\n        const int iSrcX = nBlockXSize - nRightPixelsToFill - 1;\n\n        for( int iX = iSrcX + 1; iX \u003c nBlockXSize; ++iX )\n        {\n            for( int iY = 0; iY \u003c nBlockYSize; ++iY )\n            {\n                memcpy( pabyData + (nBlockXSize * iY + iX) * nComponents,\n                        pabyData + (nBlockXSize * iY + iSrcX) * nComponents,\n                        nComponents );\n            }\n        }\n\n        // Now fill out the bottom.\n        const int iSrcY = nBlockYSize - nBottomPixelsToFill - 1;\n        for( int iY = iSrcY + 1; iY \u003c nBlockYSize; ++iY )\n        {\n            memcpy( pabyData + nBlockXSize * nComponents * iY,\n                    pabyData + nBlockXSize * nComponents * iSrcY,\n                    nBlockXSize * nComponents );\n        }\n    }\n\n    if( bHasDiscardedLsb )\n    {\n        const int iBand =\n            nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast\u003cint\u003e(tile) / nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( bStreamingOut )\n    {\n        if( tile != static_cast\u003cuint32\u003e(nLastWrittenBlockId + 1) )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     tile, nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast\u003cint\u003e( VSIFWriteL(pabyData, 1, cc, fpToWrite) ) != cc )\n        {\n            CPLError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      cc );\n            return false;\n        }\n        nLastWrittenBlockId = tile;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(tile, pabyData, cc, nBlockYSize) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if !defined(INTERNAL_LIBTIFF) \u0026\u0026 (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION \u003c= 20150912))\n    const CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    const bool bRet =\n        static_cast\u003cint\u003e(TIFFWriteEncodedTile(hTIFF, tile, pabyData, cc)) == cc;\n#if !defined(INTERNAL_LIBTIFF) \u0026\u0026 (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION \u003c= 20150912))\n    if( eBefore == CE_None \u0026\u0026 CPLGetLastErrorType() == CE_Failure )\n        return false;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        WriteEncodedStrip()                           */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                      int bPreserveDataBuffer )\n{\n    int cc = static_cast\u003cint\u003e(TIFFStripSize( hTIFF ));\n\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n    const int nStripWithinBand = strip % nBlocksPerBand;\n    int nStripHeight = nRowsPerStrip;\n\n    if( nStripWithinBand * nStripHeight \u003e GetRasterYSize() - nStripHeight )\n    {\n        nStripHeight = GetRasterYSize() - nStripWithinBand * nRowsPerStrip;\n        cc = (cc / nRowsPerStrip) * nStripHeight;\n        CPLDebug( \"GTiff\", \"Adjusted bytes to write from %d to %d.\",\n                  static_cast\u003cint\u003e(TIFFStripSize(hTIFF)), cc );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !bWriteEmptyTiles \u0026\u0026 IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(strip) )\n        {\n            const int nComponents =\n                nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n            if( HasOnlyNoData(pabyData,\n                              nBlockXSize, nStripHeight,\n                              nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      TIFFWriteEncodedStrip can alter the passed buffer if            */\n/*      byte-swapping is necessary so we use a temporary buffer         */\n/*      before calling it.                                              */\n/* -------------------------------------------------------------------- */\n    if( bPreserveDataBuffer \u0026\u0026 (TIFFIsByteSwapped(hTIFF) || bHasDiscardedLsb) )\n    {\n        if( cc != nTempWriteBufferSize )\n        {\n            pabyTempWriteBuffer = CPLRealloc(pabyTempWriteBuffer, cc);\n            nTempWriteBufferSize = cc;\n        }\n        memcpy(pabyTempWriteBuffer, pabyData, cc);\n        pabyData = static_cast\u003cGByte *\u003e( pabyTempWriteBuffer );\n    }\n\n    if( bHasDiscardedLsb )\n    {\n        int iBand =\n            nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast\u003cint\u003e(strip) / nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( bStreamingOut )\n    {\n        if( strip != static_cast\u003cuint32\u003e(nLastWrittenBlockId + 1) )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     strip, nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast\u003cint\u003e( VSIFWriteL(pabyData, 1, cc, fpToWrite) ) != cc )\n        {\n            CPLError(CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                     cc);\n            return false;\n        }\n        nLastWrittenBlockId = strip;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(strip, pabyData, cc, nStripHeight) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if !defined(INTERNAL_LIBTIFF) \u0026\u0026 (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION \u003c= 20150912))\n    CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    bool bRet =\n        static_cast\u003cint\u003e(TIFFWriteEncodedStrip( hTIFF, strip,\n                                                pabyData, cc)) == cc;\n#if !defined(INTERNAL_LIBTIFF) \u0026\u0026 (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION \u003c= 20150912))\n    if( eBefore == CE_None \u0026\u0026 CPLGetLastErrorType() == CE_Failure )\n        bRet = FALSE;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        InitCompressionThreads()                      */\n/************************************************************************/\n\nvoid GTiffDataset::InitCompressionThreads( char** papszOptions )\n{\n    // Raster == tile, then no need for threads\n    if( nBlockXSize == nRasterXSize \u0026\u0026 nBlockYSize == nRasterYSize )\n        return;\n\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"NUM_THREADS\" );\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption(\"GDAL_NUM_THREADS\", nullptr);\n    if( pszValue )\n    {\n        const int nThreads =\n            EQUAL(pszValue, \"ALL_CPUS\") ? CPLGetNumCPUs() : atoi(pszValue);\n        if( nThreads \u003e 1 )\n        {\n            if( nCompression == COMPRESSION_NONE ||\n                nCompression == COMPRESSION_JPEG )\n            {\n                CPLDebug( \"GTiff\",\n                          \"NUM_THREADS ignored with uncompressed or JPEG\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Using %d threads for compression\", nThreads);\n\n                // Try to reuse previously created thread pool\n                {\n                    std::lock_guard\u003cstd::mutex\u003e oLock(gMutexThreadPool);\n                    if( gpoCompressThreadPool \u0026\u0026\n                        gpoCompressThreadPool-\u003eGetThreadCount() == nThreads )\n                    {\n                        poCompressThreadPool = gpoCompressThreadPool;\n                    }\n                    else\n                    {\n                        delete gpoCompressThreadPool;\n                    }\n                    gpoCompressThreadPool = nullptr;\n                }\n\n                if( poCompressThreadPool == nullptr )\n                {\n                    poCompressThreadPool = new CPLWorkerThreadPool();\n                    if( !poCompressThreadPool-\u003eSetup(nThreads, nullptr, nullptr) )\n                    {\n                        delete poCompressThreadPool;\n                        poCompressThreadPool = nullptr;\n                    }\n                }\n                if( poCompressThreadPool != nullptr )\n                {\n                    // Add a margin of an extra job w.r.t thread number\n                    // so as to optimize compression time (enables the main\n                    // thread to do boring I/O while all CPUs are working).\n                    asCompressionJobs.resize(nThreads + 1);\n                    memset(\u0026asCompressionJobs[0], 0,\n                           asCompressionJobs.size() *\n                           sizeof(GTiffCompressionJob));\n                    for( int i = 0;\n                         i \u003c static_cast\u003cint\u003e(asCompressionJobs.size());\n                         ++i )\n                    {\n                        asCompressionJobs[i].pszTmpFilename =\n                            CPLStrdup(CPLSPrintf(\"/vsimem/gtiff/thread/job/%p\",\n                                                 \u0026asCompressionJobs[i]));\n                        asCompressionJobs[i].nStripOrTile = -1;\n                    }\n                    hCompressThreadPoolMutex = CPLCreateMutex();\n                    CPLReleaseMutex(hCompressThreadPoolMutex);\n\n                    // This is kind of a hack, but basically using\n                    // TIFFWriteRawStrip/Tile and then TIFFReadEncodedStrip/Tile\n                    // does not work on a newly created file, because\n                    // TIFF_MYBUFFER is not set in tif_flags\n                    // (if using TIFFWriteEncodedStrip/Tile first,\n                    // TIFFWriteBufferSetup() is automatically called).\n                    // This should likely rather fixed in libtiff itself.\n                    TIFFWriteBufferSetup(hTIFF, nullptr, -1);\n                }\n            }\n        }\n        else if( nThreads \u003c 0 ||\n                 (!EQUAL(pszValue, \"0\") \u0026\u0026\n                  !EQUAL(pszValue, \"1\") \u0026\u0026\n                  !EQUAL(pszValue, \"ALL_CPUS\")) )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"Invalid value for NUM_THREADS: %s\", pszValue);\n        }\n    }\n}\n\n/************************************************************************/\n/*                       GetGTIFFKeysFlavor()                           */\n/************************************************************************/\n\nstatic GTIFFKeysFlavorEnum GetGTIFFKeysFlavor( char** papszOptions )\n{\n    const char* pszGeoTIFFKeysFlavor =\n        CSLFetchNameValueDef( papszOptions, \"GEOTIFF_KEYS_FLAVOR\", \"STANDARD\" );\n    if( EQUAL(pszGeoTIFFKeysFlavor, \"ESRI_PE\") )\n        return GEOTIFF_KEYS_ESRI_PE;\n    return GEOTIFF_KEYS_STANDARD;\n}\n\n/************************************************************************/\n/*                      InitCreationOrOpenOptions()                     */\n/************************************************************************/\n\nvoid GTiffDataset::InitCreationOrOpenOptions( char** papszOptions )\n{\n    InitCompressionThreads(papszOptions);\n\n    eGeoTIFFKeysFlavor = GetGTIFFKeysFlavor(papszOptions);\n}\n\n/************************************************************************/\n/*                      ThreadCompressionFunc()                         */\n/************************************************************************/\n\nvoid GTiffDataset::ThreadCompressionFunc( void* pData )\n{\n    GTiffCompressionJob* psJob = static_cast\u003cGTiffCompressionJob *\u003e(pData);\n    GTiffDataset* poDS = psJob-\u003epoDS;\n\n    VSILFILE* fpTmp = VSIFOpenL(psJob-\u003epszTmpFilename, \"wb+\");\n    TIFF* hTIFFTmp = VSI_TIFFOpen(psJob-\u003epszTmpFilename,\n        psJob-\u003ebTIFFIsBigEndian ? \"wb+\" : \"wl+\", fpTmp);\n    CPLAssert( hTIFFTmp != nullptr );\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGEWIDTH, poDS-\u003enBlockXSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGELENGTH, psJob-\u003enHeight);\n    TIFFSetField(hTIFFTmp, TIFFTAG_BITSPERSAMPLE, poDS-\u003enBitsPerSample);\n    TIFFSetField(hTIFFTmp, TIFFTAG_COMPRESSION, poDS-\u003enCompression);\n    if( psJob-\u003enPredictor != PREDICTOR_NONE )\n        TIFFSetField(hTIFFTmp, TIFFTAG_PREDICTOR, psJob-\u003enPredictor);\n\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS-\u003enPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS-\u003enSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS-\u003enSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS-\u003enBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS-\u003enPlanarConfig);\n\n    poDS-\u003eRestoreVolatileParameters(hTIFFTmp);\n\n    bool bOK =\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, psJob-\u003epabyBuffer,\n                              psJob-\u003enBufferSize) == psJob-\u003enBufferSize;\n\n    int nOffset = 0;\n    if( bOK )\n    {\n        toff_t* panOffsets = nullptr;\n        toff_t* panByteCounts = nullptr;\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPOFFSETS, \u0026panOffsets);\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPBYTECOUNTS, \u0026panByteCounts);\n\n        nOffset = static_cast\u003cint\u003e( panOffsets[0]);\n        psJob-\u003enCompressedBufferSize = static_cast\u003cint\u003e( panByteCounts[0] );\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Error when compressing strip/tile %d\",\n                  psJob-\u003enStripOrTile);\n    }\n\n    XTIFFClose(hTIFFTmp);\n    if( VSIFCloseL(fpTmp) != 0 )\n    {\n        if( bOK )\n        {\n            bOK = false;\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Error when compressing strip/tile %d\",\n                      psJob-\u003enStripOrTile);\n        }\n    }\n\n    if( bOK )\n    {\n        vsi_l_offset nFileSize = 0;\n        GByte* pabyCompressedBuffer = VSIGetMemFileBuffer(psJob-\u003epszTmpFilename,\n                                                          \u0026nFileSize,\n                                                          FALSE);\n        CPLAssert( nOffset + psJob-\u003enCompressedBufferSize \u003c=\n                   static_cast\u003cint\u003e(nFileSize) );\n        psJob-\u003epabyCompressedBuffer = pabyCompressedBuffer + nOffset;\n    }\n    else\n    {\n        psJob-\u003epabyCompressedBuffer = nullptr;\n        psJob-\u003enCompressedBufferSize = 0;\n    }\n\n    CPLAcquireMutex(poDS-\u003ehCompressThreadPoolMutex, 1000.0);\n    psJob-\u003ebReady = true;\n    CPLReleaseMutex(poDS-\u003ehCompressThreadPoolMutex);\n}\n\n/************************************************************************/\n/*                        WriteRawStripOrTile()                         */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        int nCompressedBufferSize )\n{\n#ifdef DEBUG_VERBOSE\n    CPLDebug(\"GTIFF\", \"Writing raw strip/tile %d, size %d\",\n             nStripOrTile, nCompressedBufferSize);\n#endif\n    toff_t *panOffsets = nullptr;\n    if( TIFFGetField(\n            hTIFF,\n            TIFFIsTiled( hTIFF ) ?\n            TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS, \u0026panOffsets ) \u0026\u0026\n            panOffsets[nStripOrTile] != 0 )\n    {\n        // Make sure that if the tile/strip already exists,\n        // we write at end of file.\n        TIFFSetWriteOffset(hTIFF, 0);\n    }\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFWriteRawTile( hTIFF, nStripOrTile, pabyCompressedBuffer,\n                          nCompressedBufferSize );\n    else\n        TIFFWriteRawStrip( hTIFF, nStripOrTile, pabyCompressedBuffer,\n                           nCompressedBufferSize );\n}\n\n/************************************************************************/\n/*                        WaitCompletionForBlock()                      */\n/************************************************************************/\n\nvoid GTiffDataset::WaitCompletionForBlock(int nBlockId)\n{\n    if( poCompressThreadPool != nullptr )\n    {\n        for( int i = 0; i \u003c static_cast\u003cint\u003e(asCompressionJobs.size()); ++i )\n        {\n            if( asCompressionJobs[i].nStripOrTile == nBlockId )\n            {\n                CPLDebug(\"GTIFF\",\n                         \"Waiting for worker job to finish handling block %d\",\n                         nBlockId);\n\n                CPLAcquireMutex(hCompressThreadPoolMutex, 1000.0);\n                const bool bReady = asCompressionJobs[i].bReady;\n                CPLReleaseMutex(hCompressThreadPoolMutex);\n                if( !bReady )\n                {\n                    poCompressThreadPool-\u003eWaitCompletion(0);\n                    CPLAssert( asCompressionJobs[i].bReady );\n                }\n\n                if( asCompressionJobs[i].nCompressedBufferSize )\n                {\n                    WriteRawStripOrTile(asCompressionJobs[i].nStripOrTile,\n                                  asCompressionJobs[i].pabyCompressedBuffer,\n                                  asCompressionJobs[i].nCompressedBufferSize);\n                }\n                asCompressionJobs[i].pabyCompressedBuffer = nullptr;\n                asCompressionJobs[i].nBufferSize = 0;\n                asCompressionJobs[i].bReady = false;\n                asCompressionJobs[i].nStripOrTile = -1;\n                return;\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                      SubmitCompressionJob()                          */\n/************************************************************************/\n\nbool GTiffDataset::SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         int cc, int nHeight )\n{\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( !( poCompressThreadPool != nullptr \u0026\u0026\n           (nCompression == COMPRESSION_ADOBE_DEFLATE ||\n            nCompression == COMPRESSION_LZW ||\n            nCompression == COMPRESSION_PACKBITS ||\n            nCompression == COMPRESSION_LZMA ||\n            nCompression == COMPRESSION_ZSTD ||\n            nCompression == COMPRESSION_LERC ||\n            nCompression == COMPRESSION_WEBP) ) )\n        return false;\n\n    int nNextCompressionJobAvail = -1;\n    // Wait that at least one job is finished.\n    poCompressThreadPool-\u003eWaitCompletion(\n        static_cast\u003cint\u003e(asCompressionJobs.size() - 1) );\n    for( int i = 0; i \u003c static_cast\u003cint\u003e(asCompressionJobs.size()); ++i )\n    {\n        CPLAcquireMutex(hCompressThreadPoolMutex, 1000.0);\n        const bool bReady = asCompressionJobs[i].bReady;\n        CPLReleaseMutex(hCompressThreadPoolMutex);\n        if( bReady )\n        {\n            if( asCompressionJobs[i].nCompressedBufferSize )\n            {\n                WriteRawStripOrTile( asCompressionJobs[i].nStripOrTile,\n                                asCompressionJobs[i].pabyCompressedBuffer,\n                                asCompressionJobs[i].nCompressedBufferSize );\n            }\n            asCompressionJobs[i].pabyCompressedBuffer = nullptr;\n            asCompressionJobs[i].nBufferSize = 0;\n            asCompressionJobs[i].bReady = false;\n            asCompressionJobs[i].nStripOrTile = -1;\n        }\n        if( asCompressionJobs[i].nBufferSize == 0 )\n        {\n            if( nNextCompressionJobAvail \u003c 0 )\n                nNextCompressionJobAvail = i;\n        }\n    }\n    CPLAssert(nNextCompressionJobAvail \u003e= 0);\n\n    GTiffCompressionJob* psJob = \u0026asCompressionJobs[nNextCompressionJobAvail];\n    psJob-\u003epoDS = this;\n    psJob-\u003ebTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(hTIFF) );\n    psJob-\u003epabyBuffer =\n        static_cast\u003cGByte*\u003e( CPLRealloc(psJob-\u003epabyBuffer, cc) );\n    memcpy(psJob-\u003epabyBuffer, pabyData, cc);\n    psJob-\u003enBufferSize = cc;\n    psJob-\u003enHeight = nHeight;\n    psJob-\u003enStripOrTile = nStripOrTile;\n    psJob-\u003enPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, \u0026psJob-\u003enPredictor );\n    }\n\n    poCompressThreadPool-\u003eSubmitJob(ThreadCompressionFunc, psJob);\n    return true;\n}\n\n/************************************************************************/\n/*                          DiscardLsb()                                */\n/************************************************************************/\n\nvoid GTiffDataset::DiscardLsb( GByte* pabyBuffer, int nBytes, int iBand ) const\n{\n    if( nBitsPerSample == 8 )\n    {\n        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = anMaskLsb[iBand];\n            const int nOffset = anOffsetLsb[iBand];\n            for( int i = 0; i \u003c nBytes; ++i )\n            {\n                // Keep 255 in case it is alpha.\n                if( pabyBuffer[i] != 255 )\n                    pabyBuffer[i] =\n                        static_cast\u003cGByte\u003e((pabyBuffer[i] \u0026 nMask) | nOffset);\n            }\n        }\n        else\n        {\n            for( int i = 0; i \u003c nBytes; i += nBands )\n            {\n                for( int j = 0; j \u003c nBands; ++j )\n                {\n                    // Keep 255 in case it is alpha.\n                    if( pabyBuffer[i + j] != 255 )\n                        pabyBuffer[i + j] =\n                            static_cast\u003cGByte\u003e((pabyBuffer[i + j] \u0026\n                                                anMaskLsb[j]) | anOffsetLsb[j]);\n                }\n            }\n        }\n    }\n    else if( nBitsPerSample == 16 )\n    {\n        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = anMaskLsb[iBand];\n            const int nOffset = anOffsetLsb[iBand];\n            for( int i = 0; i \u003c nBytes/2; ++i )\n            {\n                reinterpret_cast\u003cGUInt16*\u003e(pabyBuffer)[i] =\n                    static_cast\u003cGUInt16\u003e(\n                        (reinterpret_cast\u003cGUInt16 *\u003e(pabyBuffer)[i] \u0026 nMask) |\n                        nOffset);\n            }\n        }\n        else\n        {\n            for( int i = 0; i \u003c nBytes/2; i += nBands )\n            {\n                for( int j = 0; j \u003c nBands; ++j )\n                {\n                    reinterpret_cast\u003cGUInt16*\u003e(pabyBuffer)[i + j] =\n                        static_cast\u003cGUInt16\u003e(\n                            (reinterpret_cast\u003cGUInt16*\u003e(pabyBuffer)[i + j] \u0026\n                             anMaskLsb[j]) |\n                            anOffsetLsb[j]);\n                }\n            }\n        }\n    }\n    else if( nBitsPerSample == 32 )\n    {\n        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = anMaskLsb[iBand];\n            const int nOffset = anOffsetLsb[iBand];\n            for( int i = 0; i \u003c nBytes/4; ++i )\n            {\n                reinterpret_cast\u003cGUInt32 *\u003e(pabyBuffer)[i] =\n                    (reinterpret_cast\u003cGUInt32*\u003e(pabyBuffer)[i] \u0026 nMask) |\n                    nOffset;\n            }\n        }\n        else\n        {\n            for( int i = 0; i \u003c nBytes/4; i += nBands )\n            {\n                for( int j = 0; j \u003c nBands; ++j )\n                {\n                    reinterpret_cast\u003cGUInt32 *\u003e(pabyBuffer)[i + j] =\n                        (reinterpret_cast\u003cGUInt32 *\u003e(pabyBuffer)[i + j] \u0026\n                         anMaskLsb[j]) |\n                        anOffsetLsb[j];\n                }\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                  WriteEncodedTileOrStrip()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                              int bPreserveDataBuffer )\n{\n    CPLErr eErr = CE_None;\n\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( !(WriteEncodedTile(\n               tile_or_strip,\n               static_cast\u003cGByte *\u003e(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( !(WriteEncodedStrip(\n               tile_or_strip,\n               static_cast\u003cGByte *\u003e(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           FlushBlockBuf()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::FlushBlockBuf()\n\n{\n    if( nLoadedBlock \u003c 0 || !bLoadedBlockDirty )\n        return CE_None;\n\n    bLoadedBlockDirty = false;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    const CPLErr eErr =\n        WriteEncodedTileOrStrip(nLoadedBlock, pabyBlockBuf, true);\n    if( eErr != CE_None )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                    \"WriteEncodedTile/Strip() failed.\" );\n        bWriteErrorInFlushBlockBuf = true;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            LoadBlockBuf()                            */\n/*                                                                      */\n/*      Load working block buffer with request block (tile/strip).      */\n/************************************************************************/\n\nCPLErr GTiffDataset::LoadBlockBuf( int nBlockId, bool bReadFromDisk )\n\n{\n    if( nLoadedBlock == nBlockId )\n        return CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      If we have a dirty loaded block, flush it out first.            */\n/* -------------------------------------------------------------------- */\n    if( nLoadedBlock != -1 \u0026\u0026 bLoadedBlockDirty )\n    {\n        const CPLErr eErr = FlushBlockBuf();\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get block size.                                                 */\n/* -------------------------------------------------------------------- */\n    const int nBlockBufSize =\n        static_cast\u003cint\u003e(\n            TIFFIsTiled(hTIFF) ? TIFFTileSize(hTIFF) : TIFFStripSize(hTIFF));\n    if( !nBlockBufSize )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Bogus block size; unable to allocate a buffer.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( pabyBlockBuf == nullptr )\n    {\n        pabyBlockBuf =\n            static_cast\u003cGByte *\u003e( VSI_CALLOC_VERBOSE( 1, nBlockBufSize ) );\n        if( pabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*  When called from ::IWriteBlock in separate cases (or in single band */\n/*  geotiffs), the ::IWriteBlock will override the content of the buffer*/\n/*  with pImage, so we don't need to read data from disk                */\n/* -------------------------------------------------------------------- */\n    if( !bReadFromDisk || bStreamingOut )\n    {\n        nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n    // libtiff 3.X doesn't like mixing read\u0026write of JPEG compressed blocks\n    // The below hack is necessary due to another hack that consist in\n    // writing zero block to force creation of JPEG tables.\n    if( nBlockId == 0 \u0026\u0026 bDontReloadFirstBlock )\n    {\n        bDontReloadFirstBlock = false;\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n        nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    int nBlockReqSize = nBlockBufSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    const int nBlockYOff = (nBlockId % nBlocksPerBand) / nBlocksPerRow;\n\n    if( nBlockYOff * nBlockYSize \u003e nRasterYSize - nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize)\n            * (nBlockYSize - static_cast\u003cint\u003e(\n                (static_cast\u003cGIntBig\u003e(nBlockYOff + 1) * nBlockYSize) %\n                    nRasterYSize));\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have this block already loaded, and we know it      */\n/*      doesn't yet exist on disk, just zero the memory buffer and      */\n/*      pretend we loaded it.                                           */\n/* -------------------------------------------------------------------- */\n    bool bErrOccurred = false;\n    if( !IsBlockAvailable( nBlockId, nullptr, nullptr, \u0026bErrOccurred ) )\n    {\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n        nLoadedBlock = nBlockId;\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block, if it isn't our current block.                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( TIFFReadEncodedTile(hTIFF, nBlockId, pabyBlockBuf,\n                                nBlockReqSize) == -1\n            \u0026\u0026 !bIgnoreReadErrors )\n        {\n            // Once TIFFError() is properly hooked, this can go away.\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadEncodedTile() failed.\" );\n\n            memset( pabyBlockBuf, 0, nBlockBufSize );\n\n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( TIFFReadEncodedStrip(hTIFF, nBlockId, pabyBlockBuf,\n                                 nBlockReqSize) == -1\n            \u0026\u0026 !bIgnoreReadErrors )\n        {\n            // Once TIFFError() is properly hooked, this can go away.\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadEncodedStrip() failed.\" );\n\n            memset( pabyBlockBuf, 0, nBlockBufSize );\n\n            eErr = CE_Failure;\n        }\n    }\n\n    if( eErr == CE_None )\n    {\n        nLoadedBlock = nBlockId;\n    }\n    else\n    {\n        nLoadedBlock = -1;\n    }\n    bLoadedBlockDirty = false;\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                   GTiffFillStreamableOffsetAndCount()                */\n/************************************************************************/\n\nstatic void GTiffFillStreamableOffsetAndCount( TIFF* hTIFF, int nSize )\n{\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, \u0026nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, \u0026nYSize );\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(hTIFF) );\n    const int nBlockCount =\n        bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n\n    toff_t *panOffset = nullptr;\n    TIFFGetField( hTIFF, bIsTiled ? TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                  \u0026panOffset );\n    toff_t *panSize = nullptr;\n    TIFFGetField( hTIFF,\n                  bIsTiled ? TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS,\n                  \u0026panSize );\n    toff_t nOffset = nSize;\n    // Trick to avoid clang static analyzer raising false positive about\n    // divide by zero later.\n    int nBlocksPerBand = 1;\n    uint32 nRowsPerStrip = 0;\n    if( !bIsTiled )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, \u0026nRowsPerStrip);\n        if( nRowsPerStrip \u003e static_cast\u003cuint32\u003e(nYSize) )\n            nRowsPerStrip = nYSize;\n        nBlocksPerBand = DIV_ROUND_UP(nYSize, nRowsPerStrip);\n    }\n    for( int i = 0; i \u003c nBlockCount; ++i )\n    {\n        int cc = bIsTiled ? static_cast\u003cint\u003e(TIFFTileSize(hTIFF)) :\n                            static_cast\u003cint\u003e(TIFFStripSize(hTIFF));\n        if( !bIsTiled )\n        {\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n            int nStripWithinBand = i % nBlocksPerBand;\n            if( nStripWithinBand * nRowsPerStrip \u003e nYSize - nRowsPerStrip )\n            {\n                cc = (cc / nRowsPerStrip)\n                    * (nYSize - nStripWithinBand * nRowsPerStrip);\n            }\n        }\n        panOffset[i] = nOffset;\n        panSize[i] = cc;\n        nOffset += cc;\n    }\n}\n\n/************************************************************************/\n/*                             Crystalize()                             */\n/*                                                                      */\n/*      Make sure that the directory information is written out for     */\n/*      a new file, require before writing any imagery data.            */\n/************************************************************************/\n\nvoid GTiffDataset::Crystalize()\n\n{\n    if( bCrystalized )\n        return;\n\n    // TODO: libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n    WriteMetadata( this, hTIFF, true, osProfile, osFilename,\n                   papszCreationOptions );\n    WriteGeoTIFFInfo();\n    if( bNoDataSet )\n        WriteNoDataValue( hTIFF, dfNoDataValue );\n\n    bMetadataChanged = false;\n    bGeoTIFFInfoChanged = false;\n    bNoDataChanged = false;\n    bNeedsRewrite = false;\n\n    bCrystalized = true;\n\n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffDataset::Crystalize\");\n\n    TIFFWriteDirectory( hTIFF );\n    if( bStreamingOut )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( hTIFF, 0 );\n        TIFFWriteDirectory( hTIFF );\n\n        if( VSIFSeekL( fpL, 0, SEEK_END ) != 0 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO, \"Could not seek\");\n        }\n        const int nSize = static_cast\u003cint\u003e( VSIFTellL(fpL) );\n\n        TIFFSetDirectory( hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( hTIFF, nSize );\n        TIFFWriteDirectory( hTIFF );\n\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( osTmpFilename, \u0026nDataLength, FALSE);\n        if( static_cast\u003cint\u003e(\n                VSIFWriteL( pabyBuffer, 1,\n                            static_cast\u003cint\u003e(nDataLength), fpToWrite ) ) !=\n            static_cast\u003cint\u003e(nDataLength) )\n        {\n            CPLError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      static_cast\u003cint\u003e(nDataLength) );\n        }\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        TIFFSetDirectory( hTIFF, 0 );\n        CPLPopErrorHandler();\n    }\n    else\n    {\n        TIFFSetDirectory( hTIFF, 0 );\n    }\n\n    RestoreVolatileParameters( hTIFF );\n\n    nDirOffset = TIFFCurrentDirOffset( hTIFF );\n}\n\n#if defined(INTERNAL_LIBTIFF) \u0026\u0026 defined(DEFER_STRILE_LOAD)\n\nstatic\nbool GTiffCacheOffsetOrCount( VSILFILE* fp,\n                              bool bSwab,\n                              vsi_l_offset nBaseOffset,\n                              int nBlockId,\n                              uint32 nstrips,\n                              uint64* panVals,\n                              size_t sizeofval )\n{\n    constexpr vsi_l_offset IO_CACHE_PAGE_SIZE = 4096;\n\n    const int sizeofvalint = static_cast\u003cint\u003e(sizeofval);\n    const vsi_l_offset nOffset = nBaseOffset + sizeofval * nBlockId;\n    const vsi_l_offset nOffsetStartPage =\n        (nOffset / IO_CACHE_PAGE_SIZE) * IO_CACHE_PAGE_SIZE;\n    vsi_l_offset nOffsetEndPage = nOffsetStartPage + IO_CACHE_PAGE_SIZE;\n\n    if( nOffset + sizeofval \u003e nOffsetEndPage )\n        nOffsetEndPage += IO_CACHE_PAGE_SIZE;\n    vsi_l_offset nLastStripOffset = nBaseOffset + nstrips * sizeofval;\n    if( nLastStripOffset \u003c nOffsetEndPage )\n        nOffsetEndPage = nLastStripOffset;\n    if( nOffsetStartPage \u003e= nOffsetEndPage )\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"Cannot read offset/size for strile %d\", nBlockId);\n        panVals[nBlockId] = 0;\n        return false;\n    }\n    if( VSIFSeekL(fp, nOffsetStartPage, SEEK_SET) != 0 )\n    {\n        panVals[nBlockId] = 0;\n        return false;\n    }\n\n    const size_t nToRead =\n        static_cast\u003csize_t\u003e(nOffsetEndPage - nOffsetStartPage);\n    GByte buffer[2 * IO_CACHE_PAGE_SIZE] = {};  // TODO(schwehr): Off the stack.\n    const size_t nRead = VSIFReadL(buffer, 1, nToRead, fp);\n    if( nRead \u003c nToRead )\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"Cannot read offset/size for strile around ~%d\", nBlockId);\n        return false;\n    }\n    int iStartBefore =\n        - static_cast\u003cint\u003e((nOffset - nOffsetStartPage) / sizeofval);\n    if( nBlockId + iStartBefore \u003c 0 )\n        iStartBefore = -nBlockId;\n    for( int i = iStartBefore;\n         static_cast\u003cuint32\u003e(nBlockId + i) \u003c nstrips \u0026\u0026\n         static_cast\u003cGIntBig\u003e(nOffset) + (i + 1) * sizeofvalint \u003c=\n         static_cast\u003cGIntBig\u003e(nOffsetEndPage);\n         ++i )\n    {\n        if( sizeofval == 2 )\n        {\n            uint16 val;\n            memcpy(\u0026val,\n                   buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,\n                   sizeof(val));\n            if( bSwab )\n                CPL_SWAP16PTR(\u0026val);\n            panVals[nBlockId + i] = val;\n        }\n        else if( sizeofval == 4 )\n        {\n            uint32 val;\n            memcpy(\u0026val,\n                   buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,\n                   sizeof(val));\n            if( bSwab )\n                CPL_SWAP32PTR(\u0026val);\n            panVals[nBlockId + i] = val;\n        }\n        else\n        {\n            uint64 val;\n            memcpy(\u0026val,\n                   buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,\n                   sizeof(val));\n            if( bSwab )\n                CPL_SWAP64PTR(\u0026val);\n            panVals[nBlockId + i] = val;\n        }\n    }\n    return true;\n}\n\nstatic bool ReadStripArray( VSILFILE* fp,\n                            TIFF* hTIFF,\n                            const TIFFDirEntry* psEntry,\n                            int nBlockId,\n                            uint32 nStripArrayAlloc,\n                            uint64* panOffsetOrCountArray )\n{\n    const bool bSwab = (hTIFF-\u003etif_flags \u0026 TIFF_SWAB) != 0;\n    if( (hTIFF-\u003etif_flags\u0026TIFF_BIGTIFF) \u0026\u0026\n        psEntry-\u003etdir_type == TIFF_SHORT \u0026\u0026\n        psEntry-\u003etdir_count \u003c= 4 )\n    {\n        uint16 offset;\n        const GByte* src = reinterpret_cast\u003cconst GByte*\u003e(\n                                    \u0026(psEntry-\u003etdir_offset.toff_long8));\n        for( size_t i = 0; i \u003c 4 \u0026\u0026 i \u003c nStripArrayAlloc; i++ )\n        {\n            memcpy(\u0026offset, src + sizeof(offset) * i, sizeof(offset));\n            if( bSwab )\n                CPL_SWAP16PTR(\u0026offset);\n            panOffsetOrCountArray[i] = offset;\n        }\n        return true;\n    }\n    else if( (hTIFF-\u003etif_flags\u0026TIFF_BIGTIFF) \u0026\u0026\n        psEntry-\u003etdir_type == TIFF_LONG \u0026\u0026\n        psEntry-\u003etdir_count \u003c= 2 )\n    {\n        uint32 offset;\n        const GByte* src = reinterpret_cast\u003cconst GByte*\u003e(\n                                    \u0026(psEntry-\u003etdir_offset.toff_long8));\n        for( size_t i = 0; i \u003c 2 \u0026\u0026 i \u003c nStripArrayAlloc; i++ )\n        {\n            memcpy(\u0026offset, src + sizeof(offset) * i, sizeof(offset));\n            if( bSwab )\n                CPL_SWAP32PTR(\u0026offset);\n            panOffsetOrCountArray[i] = offset;\n        }\n        return true;\n    }\n    else if( (hTIFF-\u003etif_flags\u0026TIFF_BIGTIFF) \u0026\u0026\n        psEntry-\u003etdir_type == TIFF_LONG8 \u0026\u0026\n        psEntry-\u003etdir_count \u003c= 1 )\n    {\n        uint64 offset = psEntry-\u003etdir_offset.toff_long8;\n        if( bSwab )\n            CPL_SWAP64PTR(\u0026offset);\n        panOffsetOrCountArray[0] = offset;\n        return true;\n    }\n    else if( !(hTIFF-\u003etif_flags\u0026TIFF_BIGTIFF) \u0026\u0026\n        psEntry-\u003etdir_type == TIFF_SHORT \u0026\u0026\n        psEntry-\u003etdir_count \u003c= 2 )\n    {\n        uint16 offset;\n        const GByte* src = reinterpret_cast\u003cconst GByte*\u003e(\n                                    \u0026(psEntry-\u003etdir_offset.toff_long));\n\n        for( size_t i = 0; i \u003c 2 \u0026\u0026 i \u003c nStripArrayAlloc; i++ )\n        {\n            memcpy(\u0026offset, src + sizeof(offset) * i, sizeof(offset));\n            if( bSwab )\n                CPL_SWAP16PTR(\u0026offset);\n            panOffsetOrCountArray[i] = offset;\n        }\n        return true;\n    }\n    else if( !(hTIFF-\u003etif_flags\u0026TIFF_BIGTIFF) \u0026\u0026\n        psEntry-\u003etdir_type == TIFF_LONG \u0026\u0026\n        psEntry-\u003etdir_count \u003c= 1 )\n    {\n        uint32 offset = psEntry-\u003etdir_offset.toff_long;\n        if( bSwab )\n            CPL_SWAP32PTR(\u0026offset);\n        panOffsetOrCountArray[0] = offset;\n        return true;\n    }\n    else\n    {\n        vsi_l_offset l_nDirOffset = 0;\n        if( hTIFF-\u003etif_flags\u0026TIFF_BIGTIFF )\n        {\n            uint64 offset = psEntry-\u003etdir_offset.toff_long8;\n            if( bSwab )\n                CPL_SWAP64PTR(\u0026offset);\n            l_nDirOffset = offset;\n        }\n        else\n        {\n            uint32 offset = psEntry-\u003etdir_offset.toff_long;\n            if( bSwab )\n                CPL_SWAP32PTR(\u0026offset);\n            l_nDirOffset = offset;\n        }\n\n        if( psEntry-\u003etdir_type == TIFF_SHORT )\n        {\n            return GTiffCacheOffsetOrCount(fp,\n                                    bSwab,\n                                    l_nDirOffset,\n                                    nBlockId,\n                                    nStripArrayAlloc,\n                                    panOffsetOrCountArray,\n                                    sizeof(uint16));\n        }\n        else if( psEntry-\u003etdir_type == TIFF_LONG )\n        {\n            return GTiffCacheOffsetOrCount(fp,\n                                    bSwab,\n                                    l_nDirOffset,\n                                    nBlockId,\n                                    nStripArrayAlloc,\n                                    panOffsetOrCountArray,\n                                    sizeof(uint32));\n        }\n        else\n        {\n            return GTiffCacheOffsetOrCount(fp,\n                                    bSwab,\n                                    l_nDirOffset,\n                                    nBlockId,\n                                    nStripArrayAlloc,\n                                    panOffsetOrCountArray,\n                                    sizeof(uint64));\n        }\n    }\n}\n\n#endif  // #if defined(INTERNAL_LIBTIFF) \u0026\u0026 defined(DEFER_STRILE_LOAD)\n\n/************************************************************************/\n/*                          IsBlockAvailable()                          */\n/*                                                                      */\n/*      Return true if the indicated strip/tile is available.  We       */\n/*      establish this by testing if the stripbytecount is zero.  If    */\n/*      zero then the block has never been committed to disk.           */\n/************************************************************************/\n\nbool GTiffDataset::IsBlockAvailable( int nBlockId,\n                                     vsi_l_offset* pnOffset,\n                                     vsi_l_offset* pnSize,\n                                     bool *pbErrOccurred )\n\n{\n    if( pbErrOccurred )\n        *pbErrOccurred = false;\n\n    WaitCompletionForBlock(nBlockId);\n\n#if defined(INTERNAL_LIBTIFF) \u0026\u0026 defined(DEFER_STRILE_LOAD)\n    // Optimization to avoid fetching the whole Strip/TileCounts and\n    // Strip/TileOffsets arrays.\n\n    // Note: if strip choping is in effect, _TIFFFillStrilesInternal()\n    // will have 0-memset td_stripoffset_entry/td_stripbytecount_entry, so\n    // we won't enter the below block\n\n    if( eAccess == GA_ReadOnly \u0026\u0026\n        hTIFF-\u003etif_dir.td_stripoffset_entry.tdir_tag != 0 \u0026\u0026\n        hTIFF-\u003etif_dir.td_stripbytecount_entry.tdir_tag != 0 \u0026\u0026\n        !bStreamingIn )\n    {\n        if( !((hTIFF-\u003etif_dir.td_stripoffset_entry.tdir_type == TIFF_SHORT ||\n               hTIFF-\u003etif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG ||\n               hTIFF-\u003etif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG8) \u0026\u0026\n              (hTIFF-\u003etif_dir.td_stripbytecount_entry.tdir_type == TIFF_SHORT ||\n               hTIFF-\u003etif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG ||\n               hTIFF-\u003etif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG8)) )\n        {\n            if( nStripArrayAlloc == 0 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Unhandled type for StripOffset/StripByteCount\");\n                nStripArrayAlloc = ~nStripArrayAlloc;\n            }\n            if( pnOffset )\n                *pnOffset = 0;\n            if( pnSize )\n                *pnSize = 0;\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        // The size of tags can be actually lesser than the number of strips\n        // (libtiff accepts such files)\n        if( static_cast\u003cuint32\u003e(nBlockId) \u003e=\n                hTIFF-\u003etif_dir.td_stripoffset_entry.tdir_count ||\n            static_cast\u003cuint32\u003e(nBlockId) \u003e=\n                hTIFF-\u003etif_dir.td_stripbytecount_entry.tdir_count )\n        {\n            // In case the tags aren't large enough.\n            if( pnOffset )\n                *pnOffset = 0;\n            if( pnSize )\n                *pnSize = 0;\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( hTIFF-\u003etif_dir.td_stripoffset == nullptr )\n        {\n            nStripArrayAlloc = 0;\n        }\n        if( static_cast\u003cuint32\u003e(nBlockId) \u003e= nStripArrayAlloc )\n        {\n            if( nBlockId \u003e 1000000 )\n            {\n                // Avoid excessive memory allocation attempt\n                if( m_nFileSize == 0 )\n                {\n                    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n                    const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                    CPL_IGNORE_RET_VAL( VSIFSeekL(fp, 0, SEEK_END) );\n                    m_nFileSize = VSIFTellL(fp);\n                    CPL_IGNORE_RET_VAL( VSIFSeekL(fp, nCurOffset, SEEK_SET) );\n                }\n                // For such a big blockid we need at least a TIFF_LONG\n                if( static_cast\u003cvsi_l_offset\u003e(nBlockId) \u003e\n                                        m_nFileSize / (2 * sizeof(GUInt32)) )\n                {\n                    CPLError(CE_Failure, CPLE_AppDefined, \"File too short\");\n                    if( pnOffset )\n                        *pnOffset = 0;\n                    if( pnSize )\n                        *pnSize = 0;\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n\n            uint32 nStripArrayAllocBefore = nStripArrayAlloc;\n            uint32 nStripArrayAllocNew;\n            if( nStripArrayAlloc == 0 \u0026\u0026\n                hTIFF-\u003etif_dir.td_nstrips \u003c 1024 * 1024 )\n            {\n                nStripArrayAllocNew = hTIFF-\u003etif_dir.td_nstrips;\n            }\n            else\n            {\n                nStripArrayAllocNew = std::max(\n                    static_cast\u003cuint32\u003e(nBlockId) + 1, 1024U * 512U );\n                if( nStripArrayAllocNew \u003c UINT_MAX / 2  )\n                    nStripArrayAllocNew *= 2;\n                nStripArrayAllocNew = std::min(\n                    nStripArrayAllocNew, hTIFF-\u003etif_dir.td_nstrips);\n            }\n            CPLAssert( static_cast\u003cuint32\u003e(nBlockId) \u003c nStripArrayAllocNew );\n            const uint64 nArraySize64 =\n                static_cast\u003cuint64\u003e(sizeof(uint64)) * nStripArrayAllocNew;\n            const size_t nArraySize = static_cast\u003csize_t\u003e(nArraySize64);\n#if SIZEOF_VOIDP == 4\n            if( nArraySize != nArraySize64 )\n            {\n                CPLError(CE_Failure, CPLE_OutOfMemory,\n                         \"Cannot allocate strip offset and bytecount arrays\");\n                if( pbErrOccurred )\n                    *pbErrOccurred = true;\n                return false;\n            }\n#endif\n            uint64* offsetArray = static_cast\u003cuint64 *\u003e(\n                _TIFFrealloc( hTIFF-\u003etif_dir.td_stripoffset, nArraySize ) );\n            uint64* bytecountArray = static_cast\u003cuint64 *\u003e(\n                _TIFFrealloc( hTIFF-\u003etif_dir.td_stripbytecount, nArraySize ) );\n            if( offsetArray )\n                hTIFF-\u003etif_dir.td_stripoffset = offsetArray;\n            if( bytecountArray )\n                hTIFF-\u003etif_dir.td_stripbytecount = bytecountArray;\n            if( offsetArray \u0026\u0026 bytecountArray )\n            {\n                nStripArrayAlloc = nStripArrayAllocNew;\n                memset(hTIFF-\u003etif_dir.td_stripoffset + nStripArrayAllocBefore,\n                    0xFF,\n                    (nStripArrayAlloc - nStripArrayAllocBefore) * sizeof(uint64) );\n                memset(hTIFF-\u003etif_dir.td_stripbytecount + nStripArrayAllocBefore,\n                    0xFF,\n                    (nStripArrayAlloc - nStripArrayAllocBefore) * sizeof(uint64) );\n            }\n            else\n            {\n                CPLError(CE_Failure, CPLE_OutOfMemory,\n                         \"Cannot allocate strip offset and bytecount arrays\");\n                _TIFFfree(hTIFF-\u003etif_dir.td_stripoffset);\n                hTIFF-\u003etif_dir.td_stripoffset = nullptr;\n                _TIFFfree(hTIFF-\u003etif_dir.td_stripbytecount);\n                hTIFF-\u003etif_dir.td_stripbytecount = nullptr;\n                nStripArrayAlloc = 0;\n            }\n        }\n        if( hTIFF-\u003etif_dir.td_stripbytecount == nullptr )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        if( ~(hTIFF-\u003etif_dir.td_stripoffset[nBlockId]) == 0 ||\n            ~(hTIFF-\u003etif_dir.td_stripbytecount[nBlockId]) == 0 )\n        {\n            VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            const vsi_l_offset nCurOffset = VSIFTellL(fp);\n            if( ~(hTIFF-\u003etif_dir.td_stripoffset[nBlockId]) == 0 )\n            {\n                if( !ReadStripArray( fp,\n                                hTIFF,\n                                \u0026hTIFF-\u003etif_dir.td_stripoffset_entry,\n                                nBlockId,\n                                nStripArrayAlloc,\n                                hTIFF-\u003etif_dir.td_stripoffset ) )\n                {\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n\n            if( ~(hTIFF-\u003etif_dir.td_stripbytecount[nBlockId]) == 0 )\n            {\n                if( !ReadStripArray( fp,\n                                hTIFF,\n                                \u0026hTIFF-\u003etif_dir.td_stripbytecount_entry,\n                                nBlockId,\n                                nStripArrayAlloc,\n                                hTIFF-\u003etif_dir.td_stripbytecount ) )\n                {\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n            if( VSIFSeekL(fp, nCurOffset, SEEK_SET) != 0 )\n            {\n                // For some reason Coverity reports:\n                // Value of non-local \"this-\u003ehTIFF-\u003etif_dir.td_stripoffset\"\n                // that was verified to be \"NULL\" is not restored as it was\n                // along other paths.\n                // coverity[end_of_path]\n                if( pbErrOccurred )\n                    *pbErrOccurred = true;\n                return false;\n            }\n        }\n        if( pnOffset )\n            *pnOffset = hTIFF-\u003etif_dir.td_stripoffset[nBlockId];\n        if( pnSize )\n            *pnSize = hTIFF-\u003etif_dir.td_stripbytecount[nBlockId];\n        return hTIFF-\u003etif_dir.td_stripbytecount[nBlockId] != 0;\n    }\n#endif  // defined(INTERNAL_LIBTIFF) \u0026\u0026 defined(DEFER_STRILE_LOAD)\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(hTIFF) );\n\n    if( ( bIsTiled\n          \u0026\u0026 TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, \u0026panByteCounts )\n          \u0026\u0026 (pnOffset == nullptr ||\n              TIFFGetField( hTIFF, TIFFTAG_TILEOFFSETS, \u0026panOffsets )) )\n        || ( !bIsTiled\n          \u0026\u0026 TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, \u0026panByteCounts )\n          \u0026\u0026 (pnOffset == nullptr ||\n              TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, \u0026panOffsets )) ) )\n    {\n        if( panByteCounts == nullptr || (pnOffset != nullptr \u0026\u0026 panOffsets == nullptr) )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        const int nBlockCount =\n            bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n        if( nBlockId \u003e= nBlockCount )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( pnOffset )\n            *pnOffset = panOffsets[nBlockId];\n        if( pnSize )\n            *pnSize = panByteCounts[nBlockId];\n        return panByteCounts[nBlockId] != 0;\n    }\n    else\n    {\n        if( pbErrOccurred )\n            *pbErrOccurred = true;\n    }\n\n    return false;\n}\n\n/************************************************************************/\n/*                             FlushCache()                             */\n/*                                                                      */\n/*      We override this so we can also flush out local tiff strip      */\n/*      cache if need be.                                               */\n/************************************************************************/\n\nvoid GTiffDataset::FlushCache()\n\n{\n    FlushCacheInternal( true );\n}\n\nvoid GTiffDataset::FlushCacheInternal( bool bFlushDirectory )\n{\n    if( bIsFinalized || ppoActiveDSRef == nullptr )\n        return;\n\n    GDALPamDataset::FlushCache();\n\n    if( bLoadedBlockDirty \u0026\u0026 nLoadedBlock != -1 )\n        FlushBlockBuf();\n\n    CPLFree( pabyBlockBuf );\n    pabyBlockBuf = nullptr;\n    nLoadedBlock = -1;\n    bLoadedBlockDirty = false;\n\n    // Finish compression\n    if( poCompressThreadPool )\n    {\n        poCompressThreadPool-\u003eWaitCompletion();\n\n        // Flush remaining data\n        for( int i = 0; i \u003c static_cast\u003cint\u003e(asCompressionJobs.size()); ++i )\n        {\n            if( asCompressionJobs[i].bReady )\n            {\n                if( asCompressionJobs[i].nCompressedBufferSize )\n                {\n                    WriteRawStripOrTile( asCompressionJobs[i].nStripOrTile,\n                                   asCompressionJobs[i].pabyCompressedBuffer,\n                                   asCompressionJobs[i].nCompressedBufferSize );\n                }\n                asCompressionJobs[i].pabyCompressedBuffer = nullptr;\n                asCompressionJobs[i].nBufferSize = 0;\n                asCompressionJobs[i].bReady = false;\n                asCompressionJobs[i].nStripOrTile = -1;\n            }\n        }\n    }\n\n    if( bFlushDirectory \u0026\u0026 GetAccess() == GA_Update )\n    {\n        if( !SetDirectory() )\n            return;\n        FlushDirectory();\n    }\n}\n\n/************************************************************************/\n/*                           FlushDirectory()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FlushDirectory()\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        if( bMetadataChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            bNeedsRewrite =\n                    WriteMetadata( this, hTIFF, true, osProfile, osFilename,\n                                   papszCreationOptions );\n            bMetadataChanged = false;\n\n            if( m_bForceUnsetRPC )\n            {\n#ifdef HAVE_UNSETFIELD\n                double *padfRPCTag = nullptr;\n                uint16 nCount;\n                if( TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, \u0026nCount, \u0026padfRPCTag ) )\n                {\n                    std::vector\u003cdouble\u003e zeroes(92);\n                    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, zeroes.data() );\n                    TIFFUnsetField( hTIFF, TIFFTAG_RPCCOEFFICIENT );\n                    bNeedsRewrite = true;\n                }\n#endif\n                GDALWriteRPCTXTFile( osFilename, nullptr );\n                GDALWriteRPBFile( osFilename, nullptr );\n            }\n        }\n\n        if( bGeoTIFFInfoChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            WriteGeoTIFFInfo();\n        }\n\n        if( bNoDataChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            if( bNoDataSet )\n            {\n                WriteNoDataValue( hTIFF, dfNoDataValue );\n            }\n            else\n            {\n                UnsetNoDataValue( hTIFF );\n            }\n            bNeedsRewrite = true;\n            bNoDataChanged = false;\n        }\n\n        if( bNeedsRewrite )\n        {\n#if defined(TIFFLIB_VERSION)\n#if defined(HAVE_TIFFGETSIZEPROC)\n            if( !SetDirectory() )\n                return;\n\n            const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n            nDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n            if( (nDirOffset % 2) == 1 )\n                ++nDirOffset;\n\n            TIFFRewriteDirectory( hTIFF );\n\n            TIFFSetSubDirectory( hTIFF, nDirOffset );\n#elif TIFFLIB_VERSION \u003e 20010925 \u0026\u0026 TIFFLIB_VERSION != 20011807\n            if( !SetDirectory() )\n                return;\n\n            TIFFRewriteDirectory( hTIFF );\n#endif\n#endif\n            bNeedsRewrite = false;\n        }\n    }\n\n    // There are some circumstances in which we can reach this point\n    // without having made this our directory (SetDirectory()) in which\n    // case we should not risk a flush.\n    if( GetAccess() == GA_Update \u0026\u0026 TIFFCurrentDirOffset(hTIFF) == nDirOffset )\n    {\n#if defined(BIGTIFF_SUPPORT)\n        const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n\n        TIFFFlush( hTIFF );\n\n        if( nDirOffset != TIFFCurrentDirOffset( hTIFF ) )\n        {\n            nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\",\n                      \"directory moved during flush in FlushDirectory()\" );\n        }\n#else\n        // For libtiff 3.X, the above causes regressions and crashes in\n        // tiff_write.py and tiff_ovr.py.\n        TIFFFlush( hTIFF );\n#endif\n    }\n}\n\n/************************************************************************/\n/*                           CleanOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( bBase );\n\n    ScanDirectories();\n\n    FlushDirectory();\n    *ppoActiveDSRef = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector\u003ctoff_t\u003e anOvDirOffsets;\n\n    for( int i = 0; i \u003c nOverviewCount; ++i )\n    {\n        anOvDirOffsets.push_back( papoOverviewDS[i]-\u003enDirOffset );\n        delete papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector\u003cuint16\u003e anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( hTIFF, 0 );\n\n    while( true )\n    {\n        for( int i = 0; i \u003c nOverviewCount; ++i )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -\u003e %d\",\n                          static_cast\u003cint\u003e(anOvDirOffsets[i]), iThisOffset );\n                anOvDirIndexes.push_back( static_cast\u003cuint16\u003e(iThisOffset) );\n            }\n        }\n\n        if( TIFFLastDirectory( hTIFF ) )\n            break;\n\n        TIFFReadDirectory( hTIFF );\n        ++iThisOffset;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( papoOverviewDS );\n\n    nOverviewCount = 0;\n    papoOverviewDS = nullptr;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                   RegisterNewOverviewDataset()                       */\n/************************************************************************/\n\nCPLErr GTiffDataset::RegisterNewOverviewDataset(toff_t nOverviewOffset,\n                                                int l_nJpegQuality)\n{\n    GTiffDataset* poODS = new GTiffDataset();\n    poODS-\u003eosFilename = osFilename;\n    poODS-\u003enJpegQuality = l_nJpegQuality;\n    poODS-\u003enZLevel = nZLevel;\n    poODS-\u003enLZMAPreset = nLZMAPreset;\n    poODS-\u003enZSTDLevel = nZSTDLevel;\n    poODS-\u003enWebPLevel = nWebPLevel;\n    poODS-\u003ebWebPLossless = bWebPLossless;\n    poODS-\u003enJpegTablesMode = nJpegTablesMode;\n#if HAVE_LERC\n    poODS-\u003edfMaxZError = dfMaxZError;\n    memcpy(poODS-\u003eanLercAddCompressionAndVersion, anLercAddCompressionAndVersion,\n           sizeof(anLercAddCompressionAndVersion));\n#endif\n\n    if( poODS-\u003eOpenOffset( hTIFF, ppoActiveDSRef, nOverviewOffset, false,\n                            GA_Update ) != CE_None )\n    {\n        delete poODS;\n        return CE_Failure;\n    }\n\n    ++nOverviewCount;\n    papoOverviewDS = static_cast\u003cGTiffDataset **\u003e(\n        CPLRealloc( papoOverviewDS,\n                    nOverviewCount * (sizeof(void*))) );\n    papoOverviewDS[nOverviewCount-1] = poODS;\n    poODS-\u003epoBaseDS = this;\n    poODS-\u003ebIsOverview_ = true;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                     CreateTIFFColorTable()                           */\n/************************************************************************/\n\nstatic void CreateTIFFColorTable(GDALColorTable* poColorTable,\n                                 int nBits,\n                                 std::vector\u003cunsigned short\u003e\u0026 anTRed,\n                                 std::vector\u003cunsigned short\u003e\u0026 anTGreen,\n                                 std::vector\u003cunsigned short\u003e\u0026 anTBlue,\n                                 unsigned short*\u0026 panRed,\n                                 unsigned short*\u0026 panGreen,\n                                 unsigned short*\u0026 panBlue)\n{\n    int nColors;\n\n    if( nBits == 8 )\n        nColors = 256;\n    else if( nBits \u003c 8 )\n        nColors = 1 \u003c\u003c nBits;\n    else\n        nColors = 65536;\n\n    anTRed.resize(nColors,0);\n    anTGreen.resize(nColors,0);\n    anTBlue.resize(nColors,0);\n\n    for( int iColor = 0; iColor \u003c nColors; ++iColor )\n    {\n        if( iColor \u003c poColorTable-\u003eGetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n\n            poColorTable-\u003eGetColorEntryAsRGB( iColor, \u0026sRGB );\n\n            anTRed[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c1);\n            anTGreen[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c2);\n            anTBlue[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c3);\n        }\n        else\n        {\n            anTRed[iColor] = 0;\n            anTGreen[iColor] = 0;\n            anTBlue[iColor] = 0;\n        }\n    }\n\n    panRed = \u0026(anTRed[0]);\n    panGreen = \u0026(anTGreen[0]);\n    panBlue = \u0026(anTBlue[0]);\n}\n\n/************************************************************************/\n/*                  CreateOverviewsFromSrcOverviews()                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateOverviewsFromSrcOverviews(GDALDataset* poSrcDS)\n{\n    CPLAssert(poSrcDS-\u003eGetRasterCount() != 0);\n    CPLAssert(nOverviewCount == 0);\n\n    ScanDirectories();\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if( !SetDirectory() )\n        return CE_Failure;\n    FlushDirectory();\n\n    int nOvBitsPerSample = nBitsPerSample;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector\u003cunsigned short\u003e anTRed;\n    std::vector\u003cunsigned short\u003e anTGreen;\n    std::vector\u003cunsigned short\u003e anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE \u0026\u0026 poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( \"NONE\", this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, \u0026nExtraSamples,\n                      \u0026panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast\u003cuint16*\u003e(\n                CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, \u0026nPredictor );\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(\u0026nOvrBlockXSize, \u0026nOvrBlockYSize);\n\n    int nSrcOverviews = poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverviewCount();\n    CPLErr eErr = CE_None;\n\n    for( int i = 0; i \u003c nSrcOverviews \u0026\u0026 eErr == CE_None; ++i )\n    {\n        GDALRasterBand* poOvrBand = poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(i);\n\n        int nOXSize = poOvrBand-\u003eGetXSize();\n        int nOYSize = poOvrBand-\u003eGetYSize();\n\n        int nOvrJpegQuality = nJpegQuality;\n        if( nCompression == COMPRESSION_JPEG \u0026\u0026\n            CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrJpegQuality =\n                atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n        }\n\n        CPLString osNoData; // don't move this in inner scope\n        const char* pszNoData = nullptr;\n        if( bNoDataSet )\n        {\n            osNoData = GTiffFormatGDALNoDataTagValue(dfNoDataValue);\n            pszNoData = osNoData.c_str();\n        }\n\n        toff_t nOverviewOffset =\n                GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize,\n                                    nOvBitsPerSample, nPlanarConfig,\n                                    nSamplesPerPixel,\n                                    nOvrBlockXSize,\n                                    nOvrBlockYSize,\n                                    TRUE,\n                                    nCompression, nPhotometric, nSampleFormat,\n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata,\n                                    nOvrJpegQuality \u003e= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                                    CPLSPrintf(\"%d\", nJpegTablesMode),\n                                    pszNoData,\n#ifdef HAVE_LERC\n                                    anLercAddCompressionAndVersion\n#else\n                                    nullptr\n#endif\n                                   );\n\n        if( nOverviewOffset == 0 )\n            eErr = CE_Failure;\n        else\n            eErr = RegisterNewOverviewDataset(nOverviewOffset, nOvrJpegQuality);\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr == CE_None )\n        eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       CreateInternalMaskOverviews()                  */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateInternalMaskOverviews(int nOvrBlockXSize,\n                                                 int nOvrBlockYSize)\n{\n    ScanDirectories();\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    const char* pszInternalMask =\n        CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", nullptr);\n    if( poMaskDS != nullptr \u0026\u0026\n        poMaskDS-\u003eGetRasterCount() == 1 \u0026\u0026\n        (pszInternalMask == nullptr || CPLTestBool(pszInternalMask)) )\n    {\n        int nMaskOvrCompression;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"\u003cValue\u003eDEFLATE\u003c/Value\u003e\") != nullptr )\n            nMaskOvrCompression = COMPRESSION_ADOBE_DEFLATE;\n        else\n            nMaskOvrCompression = COMPRESSION_PACKBITS;\n\n        for( int i = 0; i \u003c nOverviewCount; ++i )\n        {\n            if( papoOverviewDS[i]-\u003epoMaskDS == nullptr )\n            {\n                const toff_t nOverviewOffset =\n                    GTIFFWriteDirectory(\n                        hTIFF, FILETYPE_REDUCEDIMAGE | FILETYPE_MASK,\n                        papoOverviewDS[i]-\u003enRasterXSize,\n                        papoOverviewDS[i]-\u003enRasterYSize,\n                        1, PLANARCONFIG_CONTIG,\n                        1, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                        nMaskOvrCompression, PHOTOMETRIC_MASK,\n                        SAMPLEFORMAT_UINT, PREDICTOR_NONE,\n                        nullptr, nullptr, nullptr, 0, nullptr,\n                        \"\",\n                        nullptr, nullptr, nullptr, nullptr );\n\n                if( nOverviewOffset == 0 )\n                {\n                    eErr = CE_Failure;\n                    continue;\n                }\n\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS-\u003eosFilename = osFilename;\n                if( poODS-\u003eOpenOffset( hTIFF, ppoActiveDSRef,\n                                       nOverviewOffset, false,\n                                       GA_Update ) != CE_None )\n                {\n                    delete poODS;\n                    eErr = CE_Failure;\n                }\n                else\n                {\n                    poODS-\u003ebPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption(\n                                \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\" ) );\n                    poODS-\u003epoBaseDS = this;\n                    papoOverviewDS[i]-\u003epoMaskDS = poODS;\n                    ++poMaskDS-\u003enOverviewCount;\n                    poMaskDS-\u003epapoOverviewDS = static_cast\u003cGTiffDataset **\u003e(\n                        CPLRealloc(\n                            poMaskDS-\u003epapoOverviewDS,\n                            poMaskDS-\u003enOverviewCount * (sizeof(void*))) );\n                    poMaskDS-\u003epapoOverviewDS[poMaskDS-\u003enOverviewCount-1] =\n                        poODS;\n                }\n            }\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                          IBuildOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::IBuildOverviews(\n    const char * pszResampling,\n    int nOverviews, int * panOverviewList,\n    int nBandsIn, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    ScanDirectories();\n\n    // Make implicit JPEG overviews invisible, but do not destroy\n    // them in case they are already used (not sure that the client\n    // has the right to do that.  Behaviour maybe undefined in GDAL API.\n    nJPEGOverviewCount = 0;\n\n/* -------------------------------------------------------------------- */\n/*      If RRD or external OVR overviews requested, then invoke         */\n/*      generic handling.                                               */\n/* -------------------------------------------------------------------- */\n    bool bUseGenericHandling = false;\n\n    if( CPLTestBool(CPLGetConfigOption( \"USE_RRD\", \"NO\" ))\n        || CPLTestBool(CPLGetConfigOption( \"TIFF_USE_OVR\", \"NO\" )) )\n    {\n        bUseGenericHandling = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        bUseGenericHandling = true;\n    }\n\n    if( bUseGenericHandling )\n    {\n        if( nOverviewCount != 0 )\n        {\n            CPLError(\n                CE_Failure, CPLE_NotSupported,\n                \"Cannot add external overviews when there are already \"\n                \"internal overviews\" );\n            return CE_Failure;\n        }\n\n        return GDALDataset::IBuildOverviews(\n            pszResampling, nOverviews, panOverviewList,\n            nBandsIn, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBandsIn != GetRasterCount() )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only \"\n                  \"supported when operating on all bands.  \"\n                  \"Operation failed.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews(\n                pszResampling, nOverviews, panOverviewList,\n                nBandsIn, panBandList, pfnProgress, pProgressData );\n\n        return CleanOverviews();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      libtiff 3.X has issues when generating interleaved overviews.   */\n/*      so generate them one after another one.                         */\n/* -------------------------------------------------------------------- */\n\n    CPLErr eErr = CE_None;\n\n#ifndef BIGTIFF_SUPPORT\n    if( nOverviews \u003e 1 )\n    {\n        double* padfOvrRasterFactor =\n            static_cast\u003cdouble*\u003e( CPLMalloc(sizeof(double) * nOverviews) );\n        double dfTotal = 0;\n        for( int i = 0; i \u003c nOverviews; ++i )\n        {\n            if( panOverviewList[i] \u003c= 0 )\n            {\n                CPLError(CE_Failure, CPLE_AppDefined,\n                         \"Invalid overview factor : %d\", panOverviewList[i]);\n                eErr = CE_Failure;\n                break;\n            }\n            padfOvrRasterFactor[i] =\n                1.0 / (panOverviewList[i] * panOverviewList[i]);\n            dfTotal += padfOvrRasterFactor[i];\n        }\n\n        double dfAcc = 0.0;\n        for( int i = 0; i \u003c nOverviews \u0026\u0026 eErr == CE_None; ++i )\n        {\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    dfAcc / dfTotal,\n                    (dfAcc + padfOvrRasterFactor[i]) / dfTotal,\n                    pfnProgress, pProgressData );\n            dfAcc += padfOvrRasterFactor[i];\n\n            eErr = IBuildOverviews(\n                pszResampling, 1, \u0026panOverviewList[i],\n                nBandsIn, panBandList, GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress(pScaledProgressData);\n        }\n\n        CPLFree(padfOvrRasterFactor);\n\n        return eErr;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, nullptr, pProgressData ) )\n    {\n        CPLError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if( !SetDirectory() )\n        return CE_Failure;\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = nBitsPerSample;\n\n    if( STARTS_WITH_CI(pszResampling, \"AVERAGE_BIT2\") )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector\u003cunsigned short\u003e anTRed;\n    std::vector\u003cunsigned short\u003e anTGreen;\n    std::vector\u003cunsigned short\u003e anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE \u0026\u0026 poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, \u0026nExtraSamples,\n                      \u0026panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast\u003cuint16*\u003e( CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16) );\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, \u0026nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(\u0026nOvrBlockXSize, \u0026nOvrBlockYSize);\n    std::vector\u003cbool\u003e abRequireNewOverview(nOverviews, true);\n    for( int i = 0; i \u003c nOverviews \u0026\u0026 eErr == CE_None; ++i )\n    {\n        for( int j = 0; j \u003c nOverviewCount \u0026\u0026 eErr == CE_None; ++j )\n        {\n            GTiffDataset *poODS = papoOverviewDS[j];\n\n            const int nOvFactor =\n                GDALComputeOvFactor(poODS-\u003eGetRasterXSize(),\n                                    GetRasterXSize(),\n                                    poODS-\u003eGetRasterYSize(),\n                                    GetRasterYSize());\n\n            // If we already have a 1x1 overview and this new one would result\n            // in it too, then don't create it.\n            if( poODS-\u003eGetRasterXSize() == 1 \u0026\u0026\n                poODS-\u003eGetRasterYSize() == 1 \u0026\u0026\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 \u0026\u0026\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n\n            if( nOvFactor == panOverviewList[i]\n                || nOvFactor == GDALOvLevelAdjust2( panOverviewList[i],\n                                                    GetRasterXSize(),\n                                                    GetRasterYSize() ) )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n        }\n\n        if( abRequireNewOverview[i] )\n        {\n            const int nOXSize =\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n            const int nOYSize =\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            int nOvrJpegQuality = nJpegQuality;\n            if( nCompression == COMPRESSION_JPEG \u0026\u0026\n                CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrJpegQuality =\n                    atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n            }\n\n            CPLString osNoData; // don't move this in inner scope\n            const char* pszNoData = nullptr;\n            if( bNoDataSet )\n            {\n                osNoData = GTiffFormatGDALNoDataTagValue(dfNoDataValue);\n                pszNoData = osNoData.c_str();\n            }\n\n            const toff_t nOverviewOffset =\n                GTIFFWriteDirectory(\n                    hTIFF, FILETYPE_REDUCEDIMAGE,\n                    nOXSize, nOYSize,\n                    nOvBitsPerSample, nPlanarConfig,\n                    nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                    nCompression, nPhotometric, nSampleFormat,\n                    nPredictor,\n                    panRed, panGreen, panBlue,\n                    nExtraSamples, panExtraSampleValues,\n                    osMetadata,\n                    nOvrJpegQuality \u003e= 0 ?\n                                CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                    CPLSPrintf(\"%d\", nJpegTablesMode),\n                    pszNoData,\n#ifdef HAVE_LERC\n                    anLercAddCompressionAndVersion\n#else\n                    nullptr\n#endif\n            );\n\n            if( nOverviewOffset == 0 )\n                eErr = CE_Failure;\n            else\n                eErr = RegisterNewOverviewDataset(nOverviewOffset,\n                                                  nOvrJpegQuality);\n        }\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr != CE_None )\n        return eErr;\n\n    eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if( poMaskDS != nullptr \u0026\u0026\n        poMaskDS-\u003eGetRasterCount() == 1 )\n    {\n        int nMaskOverviews = 0;\n\n        GDALRasterBand **papoOverviewBands = static_cast\u003cGDALRasterBand **\u003e(\n            CPLCalloc(sizeof(void*),nOverviewCount) );\n        for( int i = 0; i \u003c nOverviewCount; ++i )\n        {\n            if( papoOverviewDS[i]-\u003epoMaskDS != nullptr )\n            {\n                papoOverviewBands[nMaskOverviews++] =\n                        papoOverviewDS[i]-\u003epoMaskDS-\u003eGetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews(\n            poMaskDS-\u003eGetRasterBand(1),\n            nMaskOverviews,\n            reinterpret_cast\u003cGDALRasterBandH *\u003e( papoOverviewBands ),\n            pszResampling, GDALDummyProgress, nullptr );\n        CPLFree(papoOverviewBands);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if( nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )-\u003e\n                              GetRasterDataType()) == FALSE \u0026\u0026\n        GetRasterBand( panBandList[0] )-\u003eGetColorTable() == nullptr \u0026\u0026\n        (STARTS_WITH_CI(pszResampling, \"NEAR\") ||\n         EQUAL(pszResampling, \"AVERAGE\") ||\n         EQUAL(pszResampling, \"GAUSS\") ||\n         EQUAL(pszResampling, \"CUBIC\") ||\n         EQUAL(pszResampling, \"CUBICSPLINE\") ||\n         EQUAL(pszResampling, \"LANCZOS\") ||\n         EQUAL(pszResampling, \"BILINEAR\")) )\n    {\n        // In the case of pixel interleaved compressed overviews, we want to\n        // generate the overviews for all the bands block by block, and not\n        // band after band, in order to write the block once and not loose\n        // space in the TIFF file.  We also use that logic for uncompressed\n        // overviews, since GDALRegenerateOverviewsMultiBand() will be able to\n        // trigger cascading overview regeneration even in the presence\n        // of an alpha band.\n\n        int nNewOverviews = 0;\n\n        GDALRasterBand ***papapoOverviewBands =\n            static_cast\u003cGDALRasterBand ***\u003e(CPLCalloc(sizeof(void*),nBandsIn));\n        GDALRasterBand **papoBandList =\n            static_cast\u003cGDALRasterBand **\u003e(CPLCalloc(sizeof(void*),nBandsIn));\n        for( int iBand = 0; iBand \u003c nBandsIn; ++iBand )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] =\n                static_cast\u003cGDALRasterBand **\u003e( CPLCalloc(\n                    sizeof(void*), poBand-\u003eGetOverviewCount()) );\n\n            int iCurOverview = 0;\n            std::vector\u003cbool\u003e abAlreadyUsedOverviewBand(\n                poBand-\u003eGetOverviewCount(), false);\n\n            for( int i = 0; i \u003c nOverviews; ++i )\n            {\n                for( int j = 0; j \u003c poBand-\u003eGetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand-\u003eGetOverview( j );\n\n                    nOvFactor = GDALComputeOvFactor(poOverview-\u003eGetXSize(),\n                                                     poBand-\u003eGetXSize(),\n                                                     poOverview-\u003eGetYSize(),\n                                                     poBand-\u003eGetYSize());\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand-\u003eGetNoDataValue(\u0026bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview-\u003eSetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand-\u003eGetXSize(),\n                                            poBand-\u003eGetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(iCurOverview \u003c poBand-\u003eGetOverviewCount());\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        ++iCurOverview ;\n                        break;\n                    }\n                }\n            }\n\n            if( nNewOverviews == 0 )\n            {\n                nNewOverviews = iCurOverview;\n            }\n            else if( nNewOverviews != iCurOverview )\n            {\n                CPLAssert(false);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand( nBandsIn, papoBandList,\n                                          nNewOverviews, papapoOverviewBands,\n                                          pszResampling, pfnProgress,\n                                          pProgressData );\n\n        for( int iBand = 0; iBand \u003c nBandsIn; ++iBand )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands = static_cast\u003cGDALRasterBand **\u003e(\n            CPLCalloc(sizeof(void*), nOverviews) );\n\n        for( int iBand = 0; iBand \u003c nBandsIn \u0026\u0026 eErr == CE_None; ++iBand )\n        {\n            GDALRasterBand *poBand = GetRasterBand( panBandList[iBand] );\n            if( poBand == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n\n            std::vector\u003cbool\u003e abAlreadyUsedOverviewBand(\n                poBand-\u003eGetOverviewCount(), false);\n\n            int nNewOverviews = 0;\n            for( int i = 0; i \u003c nOverviews; ++i )\n            {\n                for( int j = 0; j \u003c poBand-\u003eGetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    GDALRasterBand * poOverview = poBand-\u003eGetOverview( j );\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand-\u003eGetNoDataValue(\u0026bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview-\u003eSetNoDataValue(noDataValue);\n\n                    const int nOvFactor =\n                        GDALComputeOvFactor(poOverview-\u003eGetXSize(),\n                                            poBand-\u003eGetXSize(),\n                                            poOverview-\u003eGetYSize(),\n                                            poBand-\u003eGetYSize());\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand-\u003eGetXSize(),\n                                            poBand-\u003eGetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(nNewOverviews \u003c poBand-\u003eGetOverviewCount());\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    iBand / static_cast\u003cdouble\u003e( nBandsIn ),\n                    (iBand + 1) / static_cast\u003cdouble\u003e( nBandsIn ),\n                    pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews(\n                poBand,\n                nNewOverviews,\n                reinterpret_cast\u003cGDALRasterBandH *\u003e( papoOverviewBands ),\n                pszResampling,\n                GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n    pfnProgress( 1.0, nullptr, pProgressData );\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                      GTiffWriteDummyGeokeyDirectory()                */\n/************************************************************************/\n\nstatic void GTiffWriteDummyGeokeyDirectory( TIFF* hTIFF )\n{\n    // If we have existing geokeys, try to wipe them\n    // by writing a dummy geokey directory. (#2546)\n    uint16 *panVI = nullptr;\n    uint16 nKeyCount = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        \u0026nKeyCount, \u0026panVI ) )\n    {\n        GUInt16 anGKVersionInfo[4] = { 1, 1, 0, 0 };\n        double adfDummyDoubleParams[1] = { 0.0 };\n        TIFFSetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        4, anGKVersionInfo );\n        TIFFSetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS,\n                        1, adfDummyDoubleParams );\n        TIFFSetField( hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\" );\n    }\n}\n\n#if LIBGEOTIFF_VERSION \u003e= 1430\n\n/************************************************************************/\n/*               GTiffDatasetLibGeotiffErrorCallback()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetLibGeotiffErrorCallback(GTIF*,\n                                                int level,\n                                                const char* pszMsg, ...)\n{\n    va_list ap;\n    va_start(ap, pszMsg);\n    CPLErrorV( (level == LIBGEOTIFF_WARNING ) ? CE_Warning : CE_Failure,\n               CPLE_AppDefined, pszMsg, ap );\n    va_end(ap);\n}\n\n/************************************************************************/\n/*                           GTiffDatasetGTIFNew()                      */\n/************************************************************************/\n\nstatic GTIF* GTiffDatasetGTIFNew( TIFF* hTIFF )\n{\n    return GTIFNewEx(hTIFF, GTiffDatasetLibGeotiffErrorCallback, nullptr);\n}\n#else\n\n/************************************************************************/\n/*                           GTiffDatasetGTIFNew()                      */\n/************************************************************************/\n\nstatic GTIF* GTiffDatasetGTIFNew( TIFF* hTIFF )\n{\n    return GTIFNew(hTIFF);\n}\n#endif\n\n\n/************************************************************************/\n/*                          WriteGeoTIFFInfo()                          */\n/************************************************************************/\n\nvoid GTiffDataset::WriteGeoTIFFInfo()\n\n{\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    const char* pszAreaOrPoint =\n        GTiffDataset::GetMetadataItem( GDALMD_AREA_OR_POINT );\n    if( pszAreaOrPoint \u0026\u0026 EQUAL(pszAreaOrPoint, GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n    if( bForceUnsetGTOrGCPs )\n    {\n        bNeedsRewrite = true;\n        bForceUnsetGTOrGCPs = false;\n\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTRANSMATRIX );\n#endif\n    }\n\n    if( bForceUnsetProjection )\n    {\n        bNeedsRewrite = true;\n        bForceUnsetProjection = false;\n\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOASCIIPARAMS );\n#else\n        GTiffWriteDummyGeokeyDirectory(hTIFF);\n#endif\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write geotransform if valid.                                    */\n/* -------------------------------------------------------------------- */\n    if( bGeoTransformValid )\n    {\n        bNeedsRewrite = true;\n\n/* -------------------------------------------------------------------- */\n/*      Clear old tags to ensure we don't end up with conflicting       */\n/*      information. (#2625)                                            */\n/* -------------------------------------------------------------------- */\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTRANSMATRIX );\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Write the transform.  If we have a normal north-up image we     */\n/*      use the tiepoint plus pixelscale otherwise we use a matrix.     */\n/* -------------------------------------------------------------------- */\n        if( adfGeoTransform[2] == 0.0 \u0026\u0026 adfGeoTransform[4] == 0.0\n                \u0026\u0026 adfGeoTransform[5] \u003c 0.0 )\n        {\n            double dfOffset = 0.0;\n            if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n            {\n                // In the case the SRS has a vertical component and we have\n                // a single band, encode its scale/offset in the GeoTIFF tags\n                int bHasScale = FALSE;\n                double dfScale = GetRasterBand(1)-\u003eGetScale(\u0026bHasScale);\n                int bHasOffset = FALSE;\n                dfOffset = GetRasterBand(1)-\u003eGetOffset(\u0026bHasOffset);\n                const bool bApplyScaleOffset =\n                    HasVerticalCS(GetProjectionRef()) \u0026\u0026\n                    GetRasterCount() == 1;\n                if( bApplyScaleOffset \u0026\u0026 !bHasScale )\n                    dfScale = 1.0;\n                if( !bApplyScaleOffset || !bHasOffset )\n                    dfOffset = 0.0;\n                const double adfPixelScale[3] = {\n                    adfGeoTransform[1], fabs(adfGeoTransform[5]),\n                    bApplyScaleOffset ? dfScale  : 0.0 };\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            }\n\n            double adfTiePoints[6] = {\n                0.0, 0.0, 0.0, adfGeoTransform[0], adfGeoTransform[3], dfOffset };\n\n            if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n            {\n                adfTiePoints[3] +=\n                    adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                adfTiePoints[4] +=\n                    adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n            }\n\n            if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n        }\n        else\n        {\n            double adfMatrix[16] = {};\n\n            adfMatrix[0] = adfGeoTransform[1];\n            adfMatrix[1] = adfGeoTransform[2];\n            adfMatrix[3] = adfGeoTransform[0];\n            adfMatrix[4] = adfGeoTransform[4];\n            adfMatrix[5] = adfGeoTransform[5];\n            adfMatrix[7] = adfGeoTransform[3];\n            adfMatrix[15] = 1.0;\n\n            if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n            {\n                adfMatrix[3] +=\n                    adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                adfMatrix[7] +=\n                    adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n            }\n\n            if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n        }\n\n        // Do we need a world file?\n        if( CPLFetchBool( papszCreationOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( osFilename, \"tfw\", adfGeoTransform );\n        else if( CPLFetchBool( papszCreationOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( osFilename, \"wld\", adfGeoTransform );\n    }\n    else if( GetGCPCount() \u003e 0 )\n    {\n        bNeedsRewrite = true;\n\n        double *padfTiePoints = static_cast\u003cdouble *\u003e(\n            CPLMalloc( 6 * sizeof(double) * GetGCPCount() ) );\n\n        for( int iGCP = 0; iGCP \u003c GetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPList[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPList[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPList[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPList[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPList[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n            TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS,\n                          6 * GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out projection definition.                                */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection =\n        pszProjection != nullptr \u0026\u0026 strlen(pszProjection) \u003e 0;\n    if( (bHasProjection || bPixelIsPoint)\n        \u0026\u0026 !EQUAL(osProfile,szPROFILE_BASELINE) )\n    {\n        bNeedsRewrite = true;\n\n        // If we have existing geokeys, try to wipe them\n        // by writing a dummy geokey directory. (#2546)\n        GTiffWriteDummyGeokeyDirectory(hTIFF);\n\n        GTIF *psGTIF = GTiffDatasetGTIFNew( hTIFF );\n\n        // Set according to coordinate system.\n        if( bHasProjection )\n        {\n            GTIFSetFromOGISDefnEx( psGTIF, pszProjection, eGeoTIFFKeysFlavor );\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         AppendMetadataItem()                         */\n/************************************************************************/\n\nstatic void AppendMetadataItem( CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                                const char *pszKey, const char *pszValue,\n                                int nBand, const char *pszRole,\n                                const char *pszDomain )\n\n{\n/* -------------------------------------------------------------------- */\n/*      Create the Item element, and subcomponents.                     */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psItem = CPLCreateXMLNode( nullptr, CXT_Element, \"Item\" );\n    CPLCreateXMLNode( CPLCreateXMLNode( psItem, CXT_Attribute, \"name\"),\n                      CXT_Text, pszKey );\n\n    if( nBand \u003e 0 )\n    {\n        char szBandId[32] = {};\n        snprintf( szBandId, sizeof(szBandId), \"%d\", nBand - 1 );\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"sample\"),\n                          CXT_Text, szBandId );\n    }\n\n    if( pszRole != nullptr )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"role\"),\n                          CXT_Text, pszRole );\n\n    if( pszDomain != nullptr \u0026\u0026 strlen(pszDomain) \u003e 0 )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"domain\"),\n                          CXT_Text, pszDomain );\n\n    char *pszEscapedItemValue = CPLEscapeString(pszValue,-1,CPLES_XML);\n    CPLCreateXMLNode( psItem, CXT_Text, pszEscapedItemValue );\n    CPLFree( pszEscapedItemValue );\n\n/* -------------------------------------------------------------------- */\n/*      Create root, if missing.                                        */\n/* -------------------------------------------------------------------- */\n    if( *ppsRoot == nullptr )\n        *ppsRoot = CPLCreateXMLNode( nullptr, CXT_Element, \"GDALMetadata\" );\n\n/* -------------------------------------------------------------------- */\n/*      Append item to tail.  We keep track of the tail to avoid        */\n/*      O(nsquared) time as the list gets longer.                       */\n/* -------------------------------------------------------------------- */\n    if( *ppsTail == nullptr )\n        CPLAddXMLChild( *ppsRoot, psItem );\n    else\n        CPLAddXMLSibling( *ppsTail, psItem );\n\n    *ppsTail = psItem;\n}\n\n/************************************************************************/\n/*                         WriteMDMetadata()                            */\n/************************************************************************/\n\nstatic void WriteMDMetadata( GDALMultiDomainMetadata *poMDMD, TIFF *hTIFF,\n                             CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                             int nBand, const char * pszProfile )\n\n{\n\n/* ==================================================================== */\n/*      Process each domain.                                            */\n/* ==================================================================== */\n    char **papszDomainList = poMDMD-\u003eGetDomainList();\n    for( int iDomain = 0;\n         papszDomainList \u0026\u0026 papszDomainList[iDomain];\n         ++iDomain )\n    {\n        char **papszMD = poMDMD-\u003eGetMetadata( papszDomainList[iDomain] );\n        bool bIsXML = false;\n\n        if( EQUAL(papszDomainList[iDomain], \"IMAGE_STRUCTURE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], \"COLOR_PROFILE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], MD_DOMAIN_RPC) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:ESRI\")\n            \u0026\u0026 CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:XMP\") )\n            continue;  // Handled in SetMetadata.\n\n        if( STARTS_WITH_CI(papszDomainList[iDomain], \"xml:\") )\n            bIsXML = true;\n\n/* -------------------------------------------------------------------- */\n/*      Process each item in this domain.                               */\n/* -------------------------------------------------------------------- */\n        for( int iItem = 0; papszMD \u0026\u0026 papszMD[iItem]; ++iItem )\n        {\n            const char *pszItemValue = nullptr;\n            char *pszItemName = nullptr;\n\n            if( bIsXML )\n            {\n                pszItemName = CPLStrdup(\"doc\");\n                pszItemValue = papszMD[iItem];\n            }\n            else\n            {\n                pszItemValue = CPLParseNameValue( papszMD[iItem], \u0026pszItemName);\n                if( pszItemName == nullptr )\n                {\n                    CPLDebug( \"GTiff\",\n                              \"Invalid metadata item : %s\", papszMD[iItem] );\n                    continue;\n                }\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Convert into XML item or handle as a special TIFF tag.          */\n/* -------------------------------------------------------------------- */\n            if( strlen(papszDomainList[iDomain]) == 0\n                \u0026\u0026 nBand == 0 \u0026\u0026\n                (STARTS_WITH_CI(pszItemName, \"TIFFTAG_\") ||\n                 (EQUAL(pszItemName, \"GEO_METADATA\") \u0026\u0026\n                  EQUAL(pszProfile, szPROFILE_GDALGeoTIFF)) ||\n                 (EQUAL(pszItemName, \"TIFF_RSID\") \u0026\u0026\n                  EQUAL(pszProfile, szPROFILE_GDALGeoTIFF))) )\n            {\n                if( EQUAL(pszItemName, \"TIFFTAG_RESOLUTIONUNIT\") )\n                {\n                    // ResolutionUnit can't be 0, which is the default if\n                    // atoi() fails.  Set to 1=Unknown.\n                    int v = atoi(pszItemValue);\n                    if( !v ) v = RESUNIT_NONE;\n                    TIFFSetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, v);\n                }\n                else\n                {\n                    bool bFoundTag = false;\n                    size_t iTag = 0;  // Used after for.\n                    for( ;\n                         iTag \u003c sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                         ++iTag )\n                    {\n                        if( EQUAL(pszItemName, asTIFFTags[iTag].pszTagName) )\n                        {\n                            bFoundTag = true;\n                            break;\n                        }\n                    }\n\n                    if( bFoundTag \u0026\u0026\n                        asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      pszItemValue );\n                    else if( bFoundTag \u0026\u0026\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      CPLAtof(pszItemValue) );\n                    else if( bFoundTag \u0026\u0026\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      atoi(pszItemValue) );\n                    else if( bFoundTag \u0026\u0026\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n                    {\n                        int nLen = static_cast\u003cint\u003e(strlen(pszItemValue));\n                        if( nLen )\n                        {\n                            TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                          nLen,\n                                          pszItemValue );\n                        }\n                    }\n                    else\n                        CPLError(\n                            CE_Warning, CPLE_NotSupported,\n                            \"%s metadata item is unhandled and \"\n                            \"will not be written\",\n                            pszItemName);\n                }\n            }\n            else if( nBand == 0 \u0026\u0026 EQUAL(pszItemName,GDALMD_AREA_OR_POINT) )\n            {\n                /* Do nothing, handled elsewhere. */;\n            }\n            else\n            {\n                AppendMetadataItem( ppsRoot, ppsTail,\n                                    pszItemName, pszItemValue,\n                                    nBand, nullptr, papszDomainList[iDomain] );\n            }\n\n            CPLFree( pszItemName );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Remove TIFFTAG_xxxxxx that are already set but no longer in     */\n/*      the metadata list (#5619)                                       */\n/* -------------------------------------------------------------------- */\n        if( strlen(papszDomainList[iDomain]) == 0 \u0026\u0026 nBand == 0 )\n        {\n            for( size_t iTag = 0;\n                 iTag \u003c sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                 ++iTag )\n            {\n                uint32 nCount = 0;\n                char* pszText = nullptr;\n                int16 nVal = 0;\n                float fVal = 0.0f;\n                const char* pszVal =\n                    CSLFetchNameValue(papszMD, asTIFFTags[iTag].pszTagName);\n                if( pszVal == nullptr \u0026\u0026\n                    ((asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING \u0026\u0026\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                    \u0026pszText )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT \u0026\u0026\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, \u0026nVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT \u0026\u0026\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, \u0026fVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING \u0026\u0026\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, \u0026nCount, \u0026pszText ))) )\n                {\n#ifdef HAVE_UNSETFIELD\n                    TIFFUnsetField( hTIFF, asTIFFTags[iTag].nTagVal );\n#else\n                    if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                    {\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal, \"\" );\n                    }\n#endif\n                }\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                           WriteRPC()                                 */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRPC( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                             int bSrcIsGeoTIFF,\n                             const char *pszProfile,\n                             const char *pszTIFFFilename,\n                             char **l_papszCreationOptions,\n                             bool bWriteOnlyInPAMIfNeeded )\n{\n/* -------------------------------------------------------------------- */\n/*      Handle RPC data written to TIFF RPCCoefficient tag, RPB file,   */\n/*      RPCTEXT file or PAM.                                            */\n/* -------------------------------------------------------------------- */\n    char **papszRPCMD = poSrcDS-\u003eGetMetadata(MD_DOMAIN_RPC);\n    if( papszRPCMD != nullptr )\n    {\n        bool bRPCSerializedOtherWay = false;\n\n        if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GTiffDatasetWriteRPCTag( l_hTIFF, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        // Write RPB file if explicitly asked, or if a non GDAL specific\n        // profile is selected and RPCTXT is not asked.\n        bool bRPBExplicitlyAsked =\n            CPLFetchBool( l_papszCreationOptions, \"RPB\", false );\n        bool bRPBExplicitlyDenied =\n            !CPLFetchBool( l_papszCreationOptions, \"RPB\", true );\n        if( (!EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) \u0026\u0026\n             !CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) \u0026\u0026\n             !bRPBExplicitlyDenied )\n            || bRPBExplicitlyAsked )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPBFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPCTXTFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( !bRPCSerializedOtherWay \u0026\u0026 bWriteOnlyInPAMIfNeeded \u0026\u0026\n            bSrcIsGeoTIFF )\n            cpl::down_cast\u003cGTiffDataset*\u003e(poSrcDS)-\u003e\n                GDALPamDataset::SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n    }\n}\n\n/************************************************************************/\n/*                  IsStandardColorInterpretation()                     */\n/************************************************************************/\n\nstatic bool IsStandardColorInterpretation(GDALDataset* poSrcDS,\n                                          uint16 nPhotometric,\n                                          char** papszCreationOptions)\n{\n    bool bStardardColorInterp = true;\n    if( nPhotometric == PHOTOMETRIC_MINISBLACK )\n    {\n        for( int i = 0; i \u003c poSrcDS-\u003eGetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS-\u003eGetRasterBand(i + 1)-\u003eGetColorInterpretation();\n            if( !(eInterp == GCI_GrayIndex || eInterp == GCI_Undefined ||\n                    (i \u003e 0 \u0026\u0026 eInterp == GCI_AlphaBand)) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        bStardardColorInterp =\n            poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorInterpretation() ==\n                GCI_PaletteIndex;\n    }\n    else if( nPhotometric == PHOTOMETRIC_RGB )\n    {\n        int iStart = 0;\n        if( EQUAL(CSLFetchNameValueDef(papszCreationOptions,\n                                       \"PHOTOMETRIC\", \"\"), \"RGB\") )\n        {\n            iStart = 3;\n            if( poSrcDS-\u003eGetRasterCount() == 4 \u0026\u0026\n                CSLFetchNameValue(papszCreationOptions, \"ALPHA\") != nullptr )\n            {\n                iStart = 4;\n            }\n        }\n        for( int i = iStart; i \u003c poSrcDS-\u003eGetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS-\u003eGetRasterBand(i+1)-\u003eGetColorInterpretation();\n            if( !((i == 0 \u0026\u0026 eInterp == GCI_RedBand) ||\n                    (i == 1 \u0026\u0026 eInterp == GCI_GreenBand) ||\n                    (i == 2 \u0026\u0026 eInterp == GCI_BlueBand) ||\n                    (i \u003e= 3 \u0026\u0026 (eInterp == GCI_Undefined ||\n                                eInterp == GCI_AlphaBand))) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_YCBCR \u0026\u0026\n             poSrcDS-\u003eGetRasterCount() == 3 )\n    {\n        // do nothing\n    }\n    else\n    {\n        bStardardColorInterp = false;\n    }\n    return bStardardColorInterp;\n}\n\n/************************************************************************/\n/*                           WriteMetadata()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteMetadata( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                                  bool bSrcIsGeoTIFF,\n                                  const char *pszProfile,\n                                  const char *pszTIFFFilename,\n                                  char **l_papszCreationOptions,\n                                  bool bExcludeRPBandIMGFileWriting)\n\n{\n/* -------------------------------------------------------------------- */\n/*      Convert all the remaining metadata into a simple XML            */\n/*      format.                                                         */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = nullptr;\n    CPLXMLNode *psTail = nullptr;\n\n    if( bSrcIsGeoTIFF )\n    {\n        GTiffDataset* poSrcDSGTiff = cpl::down_cast\u003cGTiffDataset *\u003e(poSrcDS);\n        assert(poSrcDSGTiff);\n        WriteMDMetadata(\n            \u0026poSrcDSGTiff-\u003eoGTiffMDMD,\n            l_hTIFF, \u0026psRoot, \u0026psTail, 0, pszProfile );\n    }\n    else\n    {\n        char **papszMD = poSrcDS-\u003eGetMetadata();\n\n        if( CSLCount(papszMD) \u003e 0 )\n        {\n            GDALMultiDomainMetadata l_oMDMD;\n            l_oMDMD.SetMetadata( papszMD );\n\n            WriteMDMetadata( \u0026l_oMDMD, l_hTIFF, \u0026psRoot, \u0026psTail,\n                             0, pszProfile );\n        }\n    }\n\n    if( !bExcludeRPBandIMGFileWriting )\n    {\n        WriteRPC(poSrcDS, l_hTIFF, bSrcIsGeoTIFF,\n                 pszProfile, pszTIFFFilename,\n                 l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      Handle metadata data written to an IMD file.                    */\n/* -------------------------------------------------------------------- */\n        char **papszIMDMD = poSrcDS-\u003eGetMetadata(MD_DOMAIN_IMD);\n        if( papszIMDMD != nullptr )\n        {\n            GDALWriteIMDFile( pszTIFFFilename, papszIMDMD );\n        }\n    }\n\n    uint16 nPhotometric = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, \u0026(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(poSrcDS, nPhotometric,\n                                      l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      We also need to address band specific metadata, and special     */\n/*      \"role\" metadata.                                                */\n/* -------------------------------------------------------------------- */\n    for( int nBand = 1; nBand \u003c= poSrcDS-\u003eGetRasterCount(); ++nBand )\n    {\n        GDALRasterBand *poBand = poSrcDS-\u003eGetRasterBand( nBand );\n\n        if( bSrcIsGeoTIFF )\n        {\n            GTiffRasterBand* poSrcBandGTiff = cpl::down_cast\u003cGTiffRasterBand *\u003e(poBand);\n            assert(poSrcBandGTiff);\n            WriteMDMetadata(\n                \u0026poSrcBandGTiff-\u003eoGTiffMDMD,\n                l_hTIFF, \u0026psRoot, \u0026psTail, nBand, pszProfile );\n        }\n        else\n        {\n            char **papszMD = poBand-\u003eGetMetadata();\n\n            if( CSLCount(papszMD) \u003e 0 )\n            {\n                GDALMultiDomainMetadata l_oMDMD;\n                l_oMDMD.SetMetadata( papszMD );\n\n                WriteMDMetadata( \u0026l_oMDMD, l_hTIFF, \u0026psRoot, \u0026psTail, nBand,\n                                 pszProfile );\n            }\n        }\n\n        const double dfOffset = poBand-\u003eGetOffset();\n        const double dfScale = poBand-\u003eGetScale();\n        bool bGeoTIFFScaleOffsetInZ = false;\n        double adfGeoTransform[6];\n        // Check if we have already encoded scale/offset in the GeoTIFF tags\n        if( poSrcDS-\u003eGetGeoTransform(adfGeoTransform) == CE_None \u0026\u0026\n            adfGeoTransform[2] == 0.0 \u0026\u0026 adfGeoTransform[4] == 0.0\n            \u0026\u0026 adfGeoTransform[5] \u003c 0.0 \u0026\u0026\n            HasVerticalCS(poSrcDS-\u003eGetProjectionRef()) \u0026\u0026\n            poSrcDS-\u003eGetRasterCount() == 1 )\n        {\n            bGeoTIFFScaleOffsetInZ = true;\n        }\n\n        if( (dfOffset != 0.0 || dfScale != 1.0) \u0026\u0026 !bGeoTIFFScaleOffsetInZ )\n        {\n            char szValue[128] = {};\n\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfOffset );\n            AppendMetadataItem( \u0026psRoot, \u0026psTail, \"OFFSET\", szValue, nBand,\n                                \"offset\", \"\" );\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfScale );\n            AppendMetadataItem( \u0026psRoot, \u0026psTail, \"SCALE\", szValue, nBand,\n                                \"scale\", \"\" );\n        }\n\n        const char* pszUnitType = poBand-\u003eGetUnitType();\n        if( pszUnitType != nullptr \u0026\u0026 pszUnitType[0] != '\\0' )\n            AppendMetadataItem( \u0026psRoot, \u0026psTail, \"UNITTYPE\",\n                                pszUnitType, nBand,\n                                \"unittype\", \"\" );\n\n        if( strlen(poBand-\u003eGetDescription()) \u003e 0 )\n        {\n            AppendMetadataItem( \u0026psRoot, \u0026psTail, \"DESCRIPTION\",\n                                poBand-\u003eGetDescription(), nBand,\n                                \"description\", \"\" );\n        }\n\n        if( !bStardardColorInterp \u0026\u0026\n            !(nBand \u003c= 3 \u0026\u0026  EQUAL(CSLFetchNameValueDef(\n                l_papszCreationOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") ) )\n        {\n            AppendMetadataItem( \u0026psRoot, \u0026psTail, \"COLORINTERP\",\n                                GDALGetColorInterpretationName(\n                                    poBand-\u003eGetColorInterpretation()),\n                                nBand,\n                                \"colorinterp\", \"\" );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the generic XML metadata if there is any.             */\n/* -------------------------------------------------------------------- */\n    if( psRoot != nullptr )\n    {\n        bool bRet = true;\n\n        if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n        {\n            char *pszXML_MD = CPLSerializeXMLTree( psRoot );\n            if( strlen(pszXML_MD) \u003e 32000 )\n            {\n                if( bSrcIsGeoTIFF )\n                {\n                    if( cpl::down_cast\u003cGTiffDataset *\u003e(\n                           poSrcDS)-\u003eGetPamFlags() \u0026 GPF_DISABLED )\n                    {\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF.\" );\n                    }\n                    else\n                    {\n                        cpl::down_cast\u003cGTiffDataset *\u003e(poSrcDS)-\u003e\n                            PushMetadataToPam();\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF. Transferred to PAM instead.\" );\n                    }\n                }\n                else\n                {\n                    bRet = false;\n                }\n            }\n            else\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD );\n            }\n            CPLFree( pszXML_MD );\n        }\n        else\n        {\n            if( bSrcIsGeoTIFF )\n                cpl::down_cast\u003cGTiffDataset *\u003e(poSrcDS)-\u003ePushMetadataToPam();\n            else\n                bRet = false;\n        }\n\n        CPLDestroyXMLNode( psRoot );\n\n        return bRet;\n    }\n\n    // If we have no more metadata but it existed before,\n    // remove the GDAL_METADATA tag.\n    if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n    {\n        char* pszText = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_GDAL_METADATA, \u0026pszText ) )\n        {\n#ifdef HAVE_UNSETFIELD\n            TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_METADATA );\n#else\n            TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, \"\" );\n#endif\n        }\n    }\n\n    return true;\n}\n\n/************************************************************************/\n/*                         PushMetadataToPam()                          */\n/*                                                                      */\n/*      When producing a strict profile TIFF or if our aggregate        */\n/*      metadata is too big for a single tiff tag we may end up         */\n/*      needing to write it via the PAM mechanisms.  This method        */\n/*      copies all the appropriate metadata into the PAM level          */\n/*      metadata object but with special care to avoid copying          */\n/*      metadata handled in other ways in TIFF format.                  */\n/************************************************************************/\n\nvoid GTiffDataset::PushMetadataToPam()\n\n{\n    if( GetPamFlags() \u0026 GPF_DISABLED )\n        return;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(this, nPhotometric, papszCreationOptions);\n\n    for( int nBand = 0; nBand \u003c= GetRasterCount(); ++nBand )\n    {\n        GDALMultiDomainMetadata *poSrcMDMD = nullptr;\n        GTiffRasterBand *poBand = nullptr;\n\n        if( nBand == 0 )\n        {\n            poSrcMDMD = \u0026(this-\u003eoGTiffMDMD);\n        }\n        else\n        {\n            poBand = cpl::down_cast\u003cGTiffRasterBand *\u003e(GetRasterBand(nBand));\n            poSrcMDMD = \u0026(poBand-\u003eoGTiffMDMD);\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Loop over the available domains.                                */\n/* -------------------------------------------------------------------- */\n        char **papszDomainList = poSrcMDMD-\u003eGetDomainList();\n        for( int iDomain = 0;\n             papszDomainList \u0026\u0026 papszDomainList[iDomain];\n             ++iDomain )\n        {\n            char **papszMD = poSrcMDMD-\u003eGetMetadata( papszDomainList[iDomain] );\n\n            if( EQUAL(papszDomainList[iDomain],MD_DOMAIN_RPC)\n                || EQUAL(papszDomainList[iDomain],MD_DOMAIN_IMD)\n                || EQUAL(papszDomainList[iDomain],\"_temporary_\")\n                || EQUAL(papszDomainList[iDomain],\"IMAGE_STRUCTURE\")\n                || EQUAL(papszDomainList[iDomain],\"COLOR_PROFILE\") )\n                continue;\n\n            papszMD = CSLDuplicate(papszMD);\n\n            for( int i = CSLCount(papszMD)-1; i \u003e= 0; --i )\n            {\n                if( STARTS_WITH_CI(papszMD[i], \"TIFFTAG_\")\n                    || EQUALN(papszMD[i],GDALMD_AREA_OR_POINT,\n                              strlen(GDALMD_AREA_OR_POINT)) )\n                    papszMD = CSLRemoveStrings( papszMD, i, 1, nullptr );\n            }\n\n            if( nBand == 0 )\n                GDALPamDataset::SetMetadata( papszMD, papszDomainList[iDomain]);\n            else\n                poBand-\u003e\n                    GDALPamRasterBand::SetMetadata( papszMD,\n                                                    papszDomainList[iDomain]);\n\n            CSLDestroy( papszMD );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Handle some \"special domain\" stuff.                             */\n/* -------------------------------------------------------------------- */\n        if( poBand != nullptr )\n        {\n            poBand-\u003eGDALPamRasterBand::SetOffset( poBand-\u003eGetOffset() );\n            poBand-\u003eGDALPamRasterBand::SetScale( poBand-\u003eGetScale() );\n            poBand-\u003eGDALPamRasterBand::SetUnitType( poBand-\u003eGetUnitType() );\n            poBand-\u003e\n                GDALPamRasterBand::SetDescription( poBand-\u003eGetDescription() );\n            if( !bStardardColorInterp )\n            {\n                poBand-\u003eGDALPamRasterBand::SetColorInterpretation(\n                                        poBand-\u003eGetColorInterpretation() );\n            }\n        }\n    }\n    MarkPamDirty();\n}\n\n/************************************************************************/\n/*                     GTiffDatasetWriteRPCTag()                        */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nvoid GTiffDatasetWriteRPCTag( TIFF *hTIFF, char **papszRPCMD )\n\n{\n    GDALRPCInfo sRPC;\n\n    if( !GDALExtractRPCInfo( papszRPCMD, \u0026sRPC ) )\n        return;\n\n    double adfRPCTag[92] = {};\n    adfRPCTag[0] = -1.0;  // Error Bias\n    adfRPCTag[1] = -1.0;  // Error Random\n\n    adfRPCTag[2] = sRPC.dfLINE_OFF;\n    adfRPCTag[3] = sRPC.dfSAMP_OFF;\n    adfRPCTag[4] = sRPC.dfLAT_OFF;\n    adfRPCTag[5] = sRPC.dfLONG_OFF;\n    adfRPCTag[6] = sRPC.dfHEIGHT_OFF;\n    adfRPCTag[7] = sRPC.dfLINE_SCALE;\n    adfRPCTag[8] = sRPC.dfSAMP_SCALE;\n    adfRPCTag[9] = sRPC.dfLAT_SCALE;\n    adfRPCTag[10] = sRPC.dfLONG_SCALE;\n    adfRPCTag[11] = sRPC.dfHEIGHT_SCALE;\n\n    memcpy( adfRPCTag + 12, sRPC.adfLINE_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 32, sRPC.adfLINE_DEN_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 52, sRPC.adfSAMP_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 72, sRPC.adfSAMP_DEN_COEFF, sizeof(double) * 20 );\n\n    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, adfRPCTag );\n}\n\n/************************************************************************/\n/*                             ReadRPCTag()                             */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nchar** GTiffDatasetReadRPCTag(TIFF* hTIFF)\n\n{\n    double *padfRPCTag = nullptr;\n    uint16 nCount;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, \u0026nCount, \u0026padfRPCTag )\n        || nCount != 92 )\n        return nullptr;\n\n    CPLStringList asMD;\n    asMD.SetNameValue(RPC_LINE_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[2]));\n    asMD.SetNameValue(RPC_SAMP_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[3]));\n    asMD.SetNameValue(RPC_LAT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[4]));\n    asMD.SetNameValue(RPC_LONG_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[5]));\n    asMD.SetNameValue(RPC_HEIGHT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[6]));\n    asMD.SetNameValue(RPC_LINE_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[7]));\n    asMD.SetNameValue(RPC_SAMP_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[8]));\n    asMD.SetNameValue(RPC_LAT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[9]));\n    asMD.SetNameValue(RPC_LONG_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[10]));\n    asMD.SetNameValue(RPC_HEIGHT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[11]));\n\n    CPLString osField;\n    CPLString osMultiField;\n\n    for( int i = 0; i \u003c 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[12+i] );\n        if( i \u003e 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue(RPC_LINE_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i \u003c 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[32+i] );\n        if( i \u003e 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_LINE_DEN_COEFF, osMultiField );\n\n    for( int i = 0; i \u003c 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[52+i] );\n        if( i \u003e 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i \u003c 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[72+i] );\n        if( i \u003e 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_DEN_COEFF, osMultiField );\n\n    return asMD.StealList();\n}\n\n/************************************************************************/\n/*                  GTiffFormatGDALNoDataTagValue()                     */\n/************************************************************************/\n\nCPLString GTiffFormatGDALNoDataTagValue( double dfNoData )\n{\n    CPLString osVal;\n    if( CPLIsNan(dfNoData) )\n        osVal = \"nan\";\n    else\n        osVal.Printf(\"%.18g\", dfNoData);\n    return osVal;\n}\n\n/************************************************************************/\n/*                         WriteNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::WriteNoDataValue( TIFF *l_hTIFF, double dfNoData )\n\n{\n    CPLString osVal( GTiffFormatGDALNoDataTagValue(dfNoData) );\n    TIFFSetField( l_hTIFF, TIFFTAG_GDAL_NODATA, osVal.c_str() );\n}\n\n/************************************************************************/\n/*                         UnsetNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::UnsetNoDataValue( TIFF *l_hTIFF )\n\n{\n#ifdef HAVE_UNSETFIELD\n    TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_NODATA );\n#else\n    TIFFSetField( l_hTIFF, TIFFTAG_GDAL_NODATA, \"\" );\n#endif\n}\n\n/************************************************************************/\n/*                            SetDirectory()                            */\n/************************************************************************/\n\nbool GTiffDataset::SetDirectory( toff_t nNewOffset )\n\n{\n    Crystalize();\n\n    if( nNewOffset == 0 )\n        nNewOffset = nDirOffset;\n\n    if( TIFFCurrentDirOffset(hTIFF) == nNewOffset )\n    {\n        CPLAssert( *ppoActiveDSRef == this || *ppoActiveDSRef == nullptr );\n        *ppoActiveDSRef = this;\n        return true;\n    }\n\n    if( GetAccess() == GA_Update )\n    {\n        if( *ppoActiveDSRef != nullptr )\n            (*ppoActiveDSRef)-\u003eFlushDirectory();\n    }\n\n    if( nNewOffset == 0)\n        return true;\n\n    (*ppoActiveDSRef) = this;\n\n    const int nSetDirResult = TIFFSetSubDirectory( hTIFF, nNewOffset );\n    if( !nSetDirResult )\n        return false;\n\n    RestoreVolatileParameters( hTIFF );\n\n    return true;\n}\n\n/************************************************************************/\n/*                     RestoreVolatileParameters()                      */\n/************************************************************************/\n\nvoid GTiffDataset::RestoreVolatileParameters(TIFF* l_hTIFF)\n{\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG\n        \u0026\u0026 nPhotometric == PHOTOMETRIC_YCBCR\n        \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode = JPEGCOLORMODE_RAW;  // Initialize to 0;\n\n        TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, \u0026nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propagate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality.\n        if(nJpegQuality \u003e 0 \u0026\u0026 nCompression == COMPRESSION_JPEG)\n        {\n#ifdef DEBUG_VERBOSE\n            CPLDebug( \"GTiff\", \"Propagate JPEG_QUALITY(%d) in SetDirectory()\",\n                      nJpegQuality );\n#endif\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality);\n        }\n        if(nJpegTablesMode \u003e= 0 \u0026\u0026 nCompression == COMPRESSION_JPEG)\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGTABLESMODE, nJpegTablesMode);\n        if(nZLevel \u003e 0 \u0026\u0026 (nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                           nCompression == COMPRESSION_LERC) )\n            TIFFSetField(l_hTIFF, TIFFTAG_ZIPQUALITY, nZLevel);\n        if(nLZMAPreset \u003e 0 \u0026\u0026 nCompression == COMPRESSION_LZMA)\n            TIFFSetField(l_hTIFF, TIFFTAG_LZMAPRESET, nLZMAPreset);\n        if( nZSTDLevel \u003e 0 \u0026\u0026 (nCompression == COMPRESSION_ZSTD ||\n                               nCompression == COMPRESSION_LERC) )\n            TIFFSetField(l_hTIFF, TIFFTAG_ZSTD_LEVEL, nZSTDLevel);\n#if HAVE_LERC\n        if( nCompression == COMPRESSION_LERC )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_LERC_MAXZERROR, dfMaxZError);\n            TIFFSetField(l_hTIFF, TIFFTAG_LERC_PARAMETERS, 2,\n                         anLercAddCompressionAndVersion);\n        }\n#endif\n        if( nWebPLevel \u003e 0 \u0026\u0026 nCompression == COMPRESSION_WEBP)\n            TIFFSetField(l_hTIFF, TIFFTAG_WEBP_LEVEL, nWebPLevel);\n        if( bWebPLossless \u0026\u0026 nCompression == COMPRESSION_WEBP)\n            TIFFSetField(l_hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n    }\n}\n\n/************************************************************************/\n/*                              Identify()                              */\n/************************************************************************/\n\nint GTiffDataset::Identify( GDALOpenInfo *poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo-\u003epszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        pszFilename += strlen(\"GTIFF_RAW:\");\n        GDALOpenInfo oOpenInfo( pszFilename, poOpenInfo-\u003eeAccess );\n        return Identify(\u0026oOpenInfo);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      First we check to see if the file has the expected header       */\n/*      bytes.                                                          */\n/* -------------------------------------------------------------------- */\n    if( poOpenInfo-\u003efpL == nullptr || poOpenInfo-\u003enHeaderBytes \u003c 2 )\n        return FALSE;\n\n    if( (poOpenInfo-\u003epabyHeader[0] != 'I' || poOpenInfo-\u003epabyHeader[1] != 'I')\n        \u0026\u0026 (poOpenInfo-\u003epabyHeader[0] != 'M'\n        || poOpenInfo-\u003epabyHeader[1] != 'M'))\n        return FALSE;\n\n#ifndef BIGTIFF_SUPPORT\n    if( (poOpenInfo-\u003epabyHeader[2] == 0x2B \u0026\u0026 poOpenInfo-\u003epabyHeader[3] == 0) ||\n        (poOpenInfo-\u003epabyHeader[2] == 0 \u0026\u0026 poOpenInfo-\u003epabyHeader[3] == 0x2B) )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"This is a BigTIFF file.  BigTIFF is not supported by this \"\n                  \"version of GDAL and libtiff.\" );\n        return FALSE;\n    }\n#endif\n\n    if( (poOpenInfo-\u003epabyHeader[2] != 0x2A || poOpenInfo-\u003epabyHeader[3] != 0)\n        \u0026\u0026 (poOpenInfo-\u003epabyHeader[3] != 0x2A || poOpenInfo-\u003epabyHeader[2] != 0)\n        \u0026\u0026 (poOpenInfo-\u003epabyHeader[2] != 0x2B || poOpenInfo-\u003epabyHeader[3] != 0)\n        \u0026\u0026 (poOpenInfo-\u003epabyHeader[3] != 0x2B ||\n            poOpenInfo-\u003epabyHeader[2] != 0))\n        return FALSE;\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                          GTIFFExtendMemoryFile()                     */\n/************************************************************************/\n\nstatic bool GTIFFExtendMemoryFile( const CPLString\u0026 osTmpFilename,\n                                   VSILFILE* fpTemp,\n                                   VSILFILE* fpL,\n                                   int nNewLength,\n                                   GByte*\u0026 pabyBuffer,\n                                   vsi_l_offset\u0026 nDataLength )\n{\n    if( nNewLength \u003c= static_cast\u003cint\u003e(nDataLength) )\n        return true;\n    if( VSIFSeekL(fpTemp, nNewLength - 1, SEEK_SET) != 0 )\n        return false;\n    char ch = 0;\n    if( VSIFWriteL(\u0026ch, 1, 1, fpTemp) != 1 )\n        return false;\n    const int nOldDataLength = static_cast\u003cint\u003e(nDataLength);\n    pabyBuffer = static_cast\u003cGByte*\u003e(\n        VSIGetMemFileBuffer( osTmpFilename, \u0026nDataLength, FALSE) );\n    const int nToRead = nNewLength - nOldDataLength;\n    const int nRead = static_cast\u003cint\u003e(\n        VSIFReadL( pabyBuffer + nOldDataLength, 1, nToRead, fpL) );\n    if( nRead != nToRead )\n    {\n        CPLError(CE_Failure, CPLE_FileIO,\n                 \"Needed to read %d bytes. Only %d got\", nToRead, nRead);\n        return false;\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                         GTIFFMakeBufferedStream()                    */\n/************************************************************************/\n\nstatic bool GTIFFMakeBufferedStream(GDALOpenInfo* poOpenInfo)\n{\n    CPLString osTmpFilename;\n    static int nCounter = 0;\n    osTmpFilename.Printf(\"/vsimem/stream_%d.tif\", ++nCounter);\n    VSILFILE* fpTemp = VSIFOpenL(osTmpFilename, \"wb+\");\n    if( fpTemp == nullptr )\n        return false;\n    // The seek is needed for /vsistdin/ that has some rewind capabilities.\n    if( VSIFSeekL(poOpenInfo-\u003efpL, poOpenInfo-\u003enHeaderBytes, SEEK_SET) != 0 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    CPLAssert( static_cast\u003cint\u003e( VSIFTellL(poOpenInfo-\u003efpL) ) ==\n               poOpenInfo-\u003enHeaderBytes );\n    if( VSIFWriteL(poOpenInfo-\u003epabyHeader, poOpenInfo-\u003enHeaderBytes,\n                   1, fpTemp) != 1 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    vsi_l_offset nDataLength = 0;\n    GByte* pabyBuffer =\n        static_cast\u003cGByte*\u003e(\n            VSIGetMemFileBuffer( osTmpFilename, \u0026nDataLength, FALSE) );\n    const bool bLittleEndian = (pabyBuffer[0] == 'I');\n#if CPL_IS_LSB\n    const bool bSwap = !bLittleEndian;\n#else\n    const bool bSwap = bLittleEndian;\n#endif\n    const bool bBigTIFF = pabyBuffer[2] == 43 || pabyBuffer[3] == 43;\n    vsi_l_offset nMaxOffset = 0;\n    if( bBigTIFF )\n    {\n        GUInt64 nTmp = 0;\n        memcpy(\u0026nTmp, pabyBuffer + 8, 8);\n        if( bSwap ) CPL_SWAP64PTR(\u0026nTmp);\n        if( nTmp != 16 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 16 for a streamed BigTIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        memcpy(\u0026nTmp, pabyBuffer + 16, 8);\n        if( bSwap ) CPL_SWAP64PTR(\u0026nTmp);\n        if( nTmp \u003e 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : \" CPL_FRMT_GIB, nTmp);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = static_cast\u003cint\u003e(nTmp);\n        const int nSpaceForTags = nTags * 20;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo-\u003efpL,\n                                    24 + nSpaceForTags,\n                                    pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 24 + nSpaceForTags + 8;\n        for( int i = 0; i \u003c nTags; ++i )\n        {\n            GUInt16 nTmp16 = 0;\n            memcpy(\u0026nTmp16, pabyBuffer + 24 + i * 20, 2);\n            if( bSwap ) CPL_SWAP16PTR(\u0026nTmp16);\n            const int nTag = nTmp16;\n            memcpy(\u0026nTmp16, pabyBuffer + 24 + i * 20 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(\u0026nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(\u0026nTmp, pabyBuffer + 24 + i * 20 + 4, 8);\n            if( bSwap ) CPL_SWAP64PTR(\u0026nTmp);\n            if( nTmp \u003e= 16 * 1024 * 1024 )\n            {\n                CPLError(\n                    CE_Failure, CPLE_NotSupported,\n                    \"Too many elements for tag %d : \" CPL_FRMT_GUIB,\n                    nTag, nTmp );\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = static_cast\u003cGUInt32\u003e(nTmp);\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast\u003cTIFFDataType\u003e(nDataType)) * nCount;\n            if( nTagSize \u003e 8 )\n            {\n                memcpy(\u0026nTmp, pabyBuffer + 24 + i * 20 + 12, 8);\n                if( bSwap ) CPL_SWAP64PTR(\u0026nTmp);\n                if( nTmp \u003e GUINT64_MAX - nTagSize )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( static_cast\u003cvsi_l_offset\u003e(nTmp + nTagSize) \u003e nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    else\n    {\n        GUInt32 nTmp = 0;\n        memcpy(\u0026nTmp, pabyBuffer + 4, 4);\n        if( bSwap ) CPL_SWAP32PTR(\u0026nTmp);\n        if( nTmp != 8 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 8 for a streamed TIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        GUInt16 nTmp16 = 0;\n        memcpy(\u0026nTmp16, pabyBuffer + 8, 2);\n        if( bSwap ) CPL_SWAP16PTR(\u0026nTmp16);\n        if( nTmp16 \u003e 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : %d\", nTmp16);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = nTmp16;\n        const int nSpaceForTags = nTags * 12;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo-\u003efpL,\n                                   10 + nSpaceForTags,\n                                   pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 10 + nSpaceForTags + 4;\n        for( int i = 0; i \u003c nTags; ++i )\n        {\n            memcpy(\u0026nTmp16, pabyBuffer + 10 + i * 12, 2);\n            if( bSwap ) CPL_SWAP16PTR(\u0026nTmp16);\n            const int nTag = nTmp16;\n            memcpy(\u0026nTmp16, pabyBuffer + 10 + i * 12 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(\u0026nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(\u0026nTmp, pabyBuffer + 10 + i * 12 + 4, 4);\n            if( bSwap ) CPL_SWAP32PTR(\u0026nTmp);\n            if( nTmp \u003e= 16 * 1024 * 1024 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Too many elements for tag %d : %u\", nTag, nTmp);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = nTmp;\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast\u003cTIFFDataType\u003e(nDataType)) * nCount;\n            if( nTagSize \u003e 4 )\n            {\n                memcpy(\u0026nTmp, pabyBuffer + 10 + i * 12 + 8, 4);\n                if( bSwap ) CPL_SWAP32PTR(\u0026nTmp);\n                if( nTmp \u003e static_cast\u003cGUInt32\u003e(UINT_MAX - nTagSize) )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( nTmp + nTagSize \u003e nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    if( nMaxOffset \u003e 10 * 1024 * 1024 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    if( !GTIFFExtendMemoryFile(\n           osTmpFilename, fpTemp, poOpenInfo-\u003efpL,\n           static_cast\u003cint\u003e(nMaxOffset), pabyBuffer, nDataLength) )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    CPLAssert(nDataLength == VSIFTellL(poOpenInfo-\u003efpL));\n    poOpenInfo-\u003efpL = reinterpret_cast\u003cVSILFILE *\u003e(\n        VSICreateBufferedReaderHandle(\n            reinterpret_cast\u003cVSIVirtualHandle*\u003e(poOpenInfo-\u003efpL),\n            pabyBuffer,\n            static_cast\u003cvsi_l_offset\u003e(INT_MAX) \u003c\u003c 32 ) );\n    if( VSIFCloseL(fpTemp) != 0 )\n        return false;\n    VSIUnlink(osTmpFilename);\n\n    return true;\n}\n\n/************************************************************************/\n/*                                Open()                                */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Open( GDALOpenInfo * poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo-\u003epszFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Check if it looks like a TIFF file.                             */\n/* -------------------------------------------------------------------- */\n    if( !Identify(poOpenInfo) )\n        return nullptr;\n\n    bool bAllowRGBAInterface = true;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return OpenDir( poOpenInfo );\n\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    // Disable strip chop for now.\n    bool bStreaming = false;\n    const char* pszReadStreaming =\n        CPLGetConfigOption(\"TIFF_READ_STREAMING\", nullptr);\n    if( poOpenInfo-\u003efpL == nullptr )\n    {\n        poOpenInfo-\u003efpL =\n            VSIFOpenL( pszFilename,\n                       poOpenInfo-\u003eeAccess == GA_ReadOnly ? \"rb\" : \"r+b\" );\n        if( poOpenInfo-\u003efpL == nullptr )\n            return nullptr;\n    }\n    else if( !(pszReadStreaming \u0026\u0026 !CPLTestBool(pszReadStreaming)) \u0026\u0026\n             poOpenInfo-\u003enHeaderBytes \u003e= 24 \u0026\u0026\n             // A pipe has no seeking capability, so its position is 0 despite\n             // having read bytes.\n             (static_cast\u003cint\u003e( VSIFTellL(poOpenInfo-\u003efpL) ) ==\n              poOpenInfo-\u003enHeaderBytes ||\n              strcmp(pszFilename, \"/vsistdin/\") == 0 ||\n              // STARTS_WITH(pszFilename, \"/vsicurl_streaming/\") ||\n              (pszReadStreaming \u0026\u0026 CPLTestBool(pszReadStreaming))) )\n    {\n        bStreaming = true;\n        if( !GTIFFMakeBufferedStream(poOpenInfo) )\n            return nullptr;\n    }\n\n    // Store errors/warnings and emit them later.\n    std::vector\u003cGTIFFErrorStruct\u003e aoErrors;\n    CPLPushErrorHandlerEx(GTIFFErrorHandler, \u0026aoErrors);\n    CPLSetCurrentErrorHandlerCatchDebug( FALSE );\n    // Open and disable \"strip chopping\" (c option)\n    TIFF *l_hTIFF =\n        VSI_TIFFOpen( pszFilename,\n                      poOpenInfo-\u003eeAccess == GA_ReadOnly ? \"r\" : \"r+\",\n                      poOpenInfo-\u003efpL );\n    CPLPopErrorHandler();\n\n    // Now emit errors and change their criticality if needed\n    // We only emit failures if we didn't manage to open the file.\n    // Otherwise it makes Python bindings unhappy (#5616).\n    for( size_t iError = 0; iError \u003c aoErrors.size(); ++iError )\n    {\n        CPLError( (l_hTIFF == nullptr \u0026\u0026 aoErrors[iError].type == CE_Failure) ?\n                  CE_Failure : CE_Warning,\n                  aoErrors[iError].no,\n                  \"%s\",\n                  aoErrors[iError].msg.c_str() );\n    }\n    aoErrors.resize(0);\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n    uint32 nXSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, \u0026nXSize );\n    uint32 nYSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGELENGTH, \u0026nYSize );\n\n    if( nXSize \u003e INT_MAX || nYSize \u003e INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        XTIFFClose( l_hTIFF );\n        return nullptr;\n    }\n\n    uint16 l_nCompression = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, \u0026(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS-\u003eSetDescription( pszFilename );\n    poDS-\u003eosFilename = pszFilename;\n    poDS-\u003epoActiveDS = poDS;\n    poDS-\u003efpL = poOpenInfo-\u003efpL;\n    poOpenInfo-\u003efpL = nullptr;\n    poDS-\u003ebStreamingIn = bStreaming;\n    poDS-\u003enCompression = l_nCompression;\n\n    // In the case of GDAL_DISABLE_READDIR_ON_OPEN = NO / EMPTY_DIR\n    if( poOpenInfo-\u003eAreSiblingFilesLoaded() \u0026\u0026\n        CSLCount( poOpenInfo-\u003eGetSiblingFiles() ) \u003c= 1 )\n    {\n        poDS-\u003eoOvManager.TransferSiblingFiles( CSLDuplicate(\n                                            poOpenInfo-\u003eGetSiblingFiles() ) );\n        poDS-\u003em_bHasGotSiblingFiles = true;\n    }\n\n    if( poDS-\u003eOpenOffset( l_hTIFF, \u0026(poDS-\u003epoActiveDS),\n                          TIFFCurrentDirOffset(l_hTIFF), true,\n                          poOpenInfo-\u003eeAccess,\n                          bAllowRGBAInterface, true) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    // Do we want blocks that are set to zero and that haven't yet being\n    // allocated as tile/strip to remain implicit?\n    if( CPLFetchBool( poOpenInfo-\u003epapszOpenOptions, \"SPARSE_OK\", false ) )\n        poDS-\u003ebWriteEmptyTiles = false;\n\n    if( poOpenInfo-\u003eeAccess == GA_Update )\n    {\n        poDS-\u003eInitCreationOrOpenOptions(poOpenInfo-\u003epapszOpenOptions);\n    }\n\n    poDS-\u003em_bLoadPam = true;\n    poDS-\u003ebColorProfileMetadataChanged = false;\n    poDS-\u003ebMetadataChanged = false;\n    poDS-\u003ebGeoTIFFInfoChanged = false;\n    poDS-\u003ebNoDataChanged = false;\n    poDS-\u003ebForceUnsetGTOrGCPs = false;\n    poDS-\u003ebForceUnsetProjection = false;\n\n/* -------------------------------------------------------------------- */\n/*      Initialize info for external overviews.                         */\n/* -------------------------------------------------------------------- */\n    poDS-\u003eoOvManager.Initialize( poDS, pszFilename );\n    if( poOpenInfo-\u003eAreSiblingFilesLoaded() )\n        poDS-\u003eoOvManager.TransferSiblingFiles(\n            poOpenInfo-\u003eStealSiblingFiles() );\n\n    // For backward compatibility, in case GTIFF_POINT_GEO_IGNORE is defined\n    // load georeferencing right now so as to not require it to be defined\n    // at the GetGeoTransform() time.\n    if( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", nullptr) != nullptr )\n    {\n        poDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                      GTiffDatasetSetAreaOrPointMD()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetSetAreaOrPointMD( GTIF* hGTIF,\n                                          GDALMultiDomainMetadata\u0026 oGTiffMDMD )\n{\n    // Is this a pixel-is-point dataset?\n    short nRasterType = 0;\n\n    if( GDALGTIFKeyGetSHORT(hGTIF, GTRasterTypeGeoKey, \u0026nRasterType,\n                    0, 1 ) == 1 )\n    {\n        if( nRasterType == static_cast\u003cshort\u003e(RasterPixelIsPoint) )\n            oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_POINT);\n        else\n            oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_AREA);\n    }\n}\n\n/************************************************************************/\n/*                         LoadMDAreaOrPoint()                          */\n/************************************************************************/\n\n// This is a light version of LookForProjection(), which saves the\n// potential costly cost of GTIFGetOGISDefn(), since we just need to\n// access to a raw GeoTIFF key, and not build the full projection object.\n\nvoid GTiffDataset::LoadMDAreaOrPoint()\n{\n    if( bLookedForProjection || bLookedForMDAreaOrPoint ||\n        oGTiffMDMD.GetMetadataItem( GDALMD_AREA_OR_POINT ) != nullptr )\n        return;\n\n    bLookedForMDAreaOrPoint = true;\n\n    if( !SetDirectory() )\n        return;\n\n    GTIF* hGTIF = GTiffDatasetGTIFNew(hTIFF);\n\n    if( !hGTIF )\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n        GTiffDatasetSetAreaOrPointMD( hGTIF, oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         LookForProjection()                          */\n/************************************************************************/\n\nvoid GTiffDataset::LookForProjection()\n\n{\n    if( bLookedForProjection )\n        return;\n\n    bLookedForProjection = true;\n\n    IdentifyAuthorizedGeoreferencingSources();\n    if( m_nINTERNALGeorefSrcIndex \u003c 0 )\n        return;\n\n    if( !SetDirectory() )\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the GeoTIFF projection, if available.                   */\n/* -------------------------------------------------------------------- */\n    CPLFree( pszProjection );\n    pszProjection = nullptr;\n\n    GTIF *hGTIF = GTiffDatasetGTIFNew(hTIFF);\n\n    if( !hGTIF )\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n#if LIBGEOTIFF_VERSION \u003e= 1410\n        GTIFDefn *psGTIFDefn = GTIFAllocDefn();\n#else\n        GTIFDefn *psGTIFDefn =\n            static_cast\u003cGTIFDefn *\u003e(CPLCalloc(1, sizeof(GTIFDefn)));\n#endif\n\n        if( GTIFGetDefn( hGTIF, psGTIFDefn ) )\n        {\n            pszProjection = GTIFGetOGISDefn( hGTIF, psGTIFDefn );\n\n            if( STARTS_WITH_CI(pszProjection, \"COMPD_CS\") )\n            {\n                OGRSpatialReference oSRS;\n\n                oSRS.importFromWkt( pszProjection );\n\n                const char* pszVertUnit = nullptr;\n                oSRS.GetTargetLinearUnits(\"COMPD_CS|VERT_CS\", \u0026pszVertUnit);\n                if( pszVertUnit \u0026\u0026 !EQUAL(pszVertUnit, \"unknown\") )\n                {\n                    m_osVertUnit = pszVertUnit;\n                }\n\n                // Should we simplify away vertical CS stuff?\n                if( !CPLTestBool( CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\",\n                                                    \"NO\") ) )\n                {\n                    CPLDebug( \"GTiff\", \"Got COMPD_CS, but stripping it.\" );\n\n                    oSRS.StripVertical();\n                    CPLFree( pszProjection );\n                    oSRS.exportToWkt( \u0026pszProjection );\n                }\n            }\n        }\n\n        // Check the tif linear unit and the CS linear unit.\n#ifdef ESRI_BUILD\n        AdjustLinearUnit(psGTIFDefn.UOMLength);\n#endif\n\n#if LIBGEOTIFF_VERSION \u003e= 1410\n        GTIFFreeDefn(psGTIFDefn);\n#else\n        CPLFree(psGTIFDefn);\n#endif\n\n        GTiffDatasetSetAreaOrPointMD( hGTIF, oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n\n    if( pszProjection == nullptr )\n    {\n        pszProjection = CPLStrdup( \"\" );\n    }\n    // else if( !EQUAL(pszProjection, \"\") )\n    // {\n    //     m_nProjectionGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n    // }\n\n    bGeoTIFFInfoChanged = false;\n    bForceUnsetGTOrGCPs = false;\n    bForceUnsetProjection = false;\n}\n\n/************************************************************************/\n/*                          AdjustLinearUnit()                          */\n/*                                                                      */\n/*      The following code is only used in ESRI Builds and there is     */\n/*      outstanding discussion on whether it is even appropriate        */\n/*      then.                                                           */\n/************************************************************************/\n#ifdef ESRI_BUILD\n\nvoid GTiffDataset::AdjustLinearUnit( short UOMLength )\n{\n    if( !pszProjection || strlen(pszProjection) == 0 )\n        return;\n    if( UOMLength == 9001 )\n    {\n        char* pstr = strstr(pszProjection, \"PARAMETER\");\n        if( !pstr )\n            return;\n        pstr = strstr(pstr, \"UNIT[\");\n        if( !pstr )\n            return;\n        pstr = strchr(pstr, ',') + 1;\n        if( !pstr )\n            return;\n        char* pstr1 = strchr(pstr, ']');\n        if( !pstr1 || pstr1 - pstr \u003e= 128 )\n            return;\n        char csUnitStr[128];\n        strncpy(csUnitStr, pstr, pstr1 - pstr);\n        csUnitStr[pstr1-pstr] = '\\0';\n        const double csUnit = CPLAtof(csUnitStr);\n        if( fabs(csUnit - 1.0) \u003e 0.000001 )\n        {\n            for( long i = 0; i \u003c 6; ++i )\n                adfGeoTransform[i] /= csUnit;\n        }\n    }\n}\n\n#endif  // def ESRI_BUILD\n\n/************************************************************************/\n/*                            ApplyPamInfo()                            */\n/*                                                                      */\n/*      PAM Information, if available, overrides the GeoTIFF            */\n/*      geotransform and projection definition.  Check for them         */\n/*      now.                                                            */\n/************************************************************************/\n\nvoid GTiffDataset::ApplyPamInfo()\n\n{\n    if( m_nPAMGeorefSrcIndex \u003e= 0 \u0026\u0026\n        ((bGeoTransformValid \u0026\u0026\n          m_nPAMGeorefSrcIndex \u003c m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex \u003c 0 || !bGeoTransformValid) )\n    {\n        double adfPamGeoTransform[6] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n        if( GDALPamDataset::GetGeoTransform( adfPamGeoTransform ) == CE_None )\n        {\n            if( m_nGeoTransformGeorefSrcIndex == m_nWORLDFILEGeorefSrcIndex )\n                osGeorefFilename.clear();\n            memcpy(adfGeoTransform, adfPamGeoTransform, sizeof(double) * 6);\n            bGeoTransformValid = true;\n        }\n    }\n\n    if( m_nPAMGeorefSrcIndex \u003e= 0 )\n    {\n        if( (m_nTABFILEGeorefSrcIndex \u003c 0 ||\n             m_nPAMGeorefSrcIndex \u003c m_nTABFILEGeorefSrcIndex) \u0026\u0026\n            (m_nINTERNALGeorefSrcIndex \u003c 0 ||\n             m_nPAMGeorefSrcIndex \u003c m_nINTERNALGeorefSrcIndex) )\n        {\n            const char *pszPamSRS = GDALPamDataset::GetProjectionRef();\n            if( pszPamSRS != nullptr \u0026\u0026 strlen(pszPamSRS) \u003e 0 )\n            {\n                CPLFree( pszProjection );\n                pszProjection = CPLStrdup( pszPamSRS );\n                bLookedForProjection = true;\n                // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n            }\n        }\n        else\n        {\n            if( m_nINTERNALGeorefSrcIndex \u003e= 0 )\n                LookForProjection();\n            if( pszProjection == nullptr || strlen(pszProjection) == 0 )\n            {\n                const char *pszPamSRS = GDALPamDataset::GetProjectionRef();\n                if( pszPamSRS != nullptr \u0026\u0026 strlen(pszPamSRS) \u003e 0 )\n                {\n                    CPLFree( pszProjection );\n                    pszProjection = CPLStrdup( pszPamSRS );\n                    bLookedForProjection = true;\n                    // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n                }\n            }\n        }\n    }\n\n    int nPamGCPCount;\n    if( m_nPAMGeorefSrcIndex \u003e= 0 \u0026\u0026\n        (nPamGCPCount = GDALPamDataset::GetGCPCount()) \u003e 0 \u0026\u0026\n        ( (nGCPCount \u003e 0 \u0026\u0026\n           m_nPAMGeorefSrcIndex \u003c m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex \u003c 0 || nGCPCount == 0 ) )\n    {\n        if( nGCPCount \u003e 0 )\n        {\n            GDALDeinitGCPs( nGCPCount, pasGCPList );\n            CPLFree( pasGCPList );\n            pasGCPList = nullptr;\n        }\n\n        nGCPCount = nPamGCPCount;\n        pasGCPList = GDALDuplicateGCPs(nGCPCount, GDALPamDataset::GetGCPs());\n\n        CPLFree( pszProjection );\n        pszProjection = nullptr;\n        // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n\n        const char *pszPamGCPProjection = GDALPamDataset::GetGCPProjection();\n        if( pszPamGCPProjection != nullptr \u0026\u0026 strlen(pszPamGCPProjection) \u003e 0 )\n            pszProjection = CPLStrdup(pszPamGCPProjection);\n        else\n            pszProjection = CPLStrdup(\"\");\n\n        bLookedForProjection = true;\n    }\n\n    if( m_nPAMGeorefSrcIndex \u003e= 0 \u0026\u0026 nGCPCount == 0 )\n    {\n        CPLXMLNode *psValueAsXML = nullptr;\n        CPLXMLNode *psGeodataXform = nullptr;\n        char** papszXML = oMDMD.GetMetadata( \"xml:ESRI\" );\n        if (CSLCount(papszXML) == 1)\n        {\n            psValueAsXML = CPLParseXMLString( papszXML[0] );\n            if( psValueAsXML )\n                psGeodataXform = CPLGetXMLNode(psValueAsXML, \"=GeodataXform\");\n        }\n\n        const char* pszTIFFTagResUnit = GetMetadataItem(\"TIFFTAG_RESOLUTIONUNIT\");\n        const char* pszTIFFTagXRes = GetMetadataItem(\"TIFFTAG_XRESOLUTION\");\n        const char* pszTIFFTagYRes = GetMetadataItem(\"TIFFTAG_YRESOLUTION\");\n        if (psGeodataXform \u0026\u0026 pszTIFFTagResUnit \u0026\u0026pszTIFFTagXRes \u0026\u0026\n            pszTIFFTagYRes \u0026\u0026 atoi(pszTIFFTagResUnit) == 2 )\n        {\n            CPLXMLNode* psSourceGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"SourceGCPs\");\n            CPLXMLNode* psTargetGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"TargetGCPs\");\n            if( psSourceGCPs \u0026\u0026 psTargetGCPs )\n            {\n                std::vector\u003cdouble\u003e adfSourceGCPs, adfTargetGCPs;\n                for( CPLXMLNode* psIter = psSourceGCPs-\u003epsChild;\n                                    psIter != nullptr;\n                                    psIter = psIter-\u003epsNext )\n                {\n                    if( psIter-\u003eeType == CXT_Element \u0026\u0026\n                        EQUAL(psIter-\u003epszValue, \"Double\") )\n                    {\n                        adfSourceGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                for( CPLXMLNode* psIter = psTargetGCPs-\u003epsChild;\n                                    psIter != nullptr;\n                                    psIter = psIter-\u003epsNext )\n                {\n                    if( psIter-\u003eeType == CXT_Element \u0026\u0026\n                        EQUAL(psIter-\u003epszValue, \"Double\") )\n                    {\n                        adfTargetGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                if( adfSourceGCPs.size() == adfTargetGCPs.size() \u0026\u0026\n                    (adfSourceGCPs.size() % 2) == 0 )\n                {\n                    nGCPCount = static_cast\u003cint\u003e(\n                                            adfSourceGCPs.size() / 2);\n                    pasGCPList = static_cast\u003cGDAL_GCP *\u003e(\n                            CPLCalloc(sizeof(GDAL_GCP), nGCPCount) );\n                    for( int i = 0; i \u003c nGCPCount; ++i )\n                    {\n                        pasGCPList[i].pszId = CPLStrdup(\"\");\n                        pasGCPList[i].pszInfo = CPLStrdup(\"\");\n                        // The origin used is the bottom left corner,\n                        // and raw values are in inches!\n                        pasGCPList[i].dfGCPPixel = adfSourceGCPs[2*i] *\n                                                        CPLAtof(pszTIFFTagXRes);\n                        pasGCPList[i].dfGCPLine = nRasterYSize -\n                                adfSourceGCPs[2*i+1] * CPLAtof(pszTIFFTagYRes);\n                        pasGCPList[i].dfGCPX = adfTargetGCPs[2*i];\n                        pasGCPList[i].dfGCPY = adfTargetGCPs[2*i+1];\n                    }\n                }\n            }\n        }\n        if( psValueAsXML )\n            CPLDestroyXMLNode(psValueAsXML);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy any PAM metadata into our GeoTIFF context, and with        */\n/*      the PAM info overriding the GeoTIFF context.                    */\n/* -------------------------------------------------------------------- */\n    char **papszPamDomains = oMDMD.GetDomainList();\n\n    for( int iDomain = 0;\n         papszPamDomains \u0026\u0026 papszPamDomains[iDomain] != nullptr;\n         ++iDomain )\n    {\n        const char *pszDomain = papszPamDomains[iDomain];\n        char **papszGT_MD = CSLDuplicate(oGTiffMDMD.GetMetadata( pszDomain ));\n        char **papszPAM_MD = oMDMD.GetMetadata( pszDomain );\n\n        papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n        oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n        CSLDestroy( papszGT_MD );\n    }\n\n    for( int i = 1; i \u003c= GetRasterCount(); ++i )\n    {\n        GTiffRasterBand* poBand =\n            cpl::down_cast\u003cGTiffRasterBand *\u003e(GetRasterBand(i));\n        papszPamDomains = poBand-\u003eoMDMD.GetDomainList();\n\n        for( int iDomain = 0;\n             papszPamDomains \u0026\u0026 papszPamDomains[iDomain] != nullptr;\n             ++iDomain )\n        {\n            const char *pszDomain = papszPamDomains[iDomain];\n            char **papszGT_MD =\n                CSLDuplicate(poBand-\u003eoGTiffMDMD.GetMetadata( pszDomain ));\n            char **papszPAM_MD = poBand-\u003eoMDMD.GetMetadata( pszDomain );\n\n            papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n            poBand-\u003eoGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n            CSLDestroy( papszGT_MD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                              OpenDir()                               */\n/*                                                                      */\n/*      Open a specific directory as encoded into a filename.           */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    bool bAllowRGBAInterface = true;\n    const char* pszFilename = poOpenInfo-\u003epszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") ||\n        pszFilename[strlen(\"GTIFF_DIR:\")] == '\\0' )\n    {\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    bool bAbsolute = false;\n\n    if( STARTS_WITH_CI(pszFilename, \"off:\") )\n    {\n        bAbsolute = true;\n        pszFilename += 4;\n    }\n\n    toff_t nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' \u0026\u0026 pszFilename[-1] != ':' )\n        ++pszFilename;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        CPLError(\n            CE_Failure, CPLE_OpenFailed,\n            \"Unable to extract offset or filename, should take the form:\\n\"\n            \"GTIFF_DIR:\u003cdir\u003e:filename or GTIFF_DIR:off:\u003cdir_offset\u003e:filename\" );\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n    VSILFILE* l_fpL = VSIFOpenL(pszFilename, \"r\");\n    if( l_fpL == nullptr )\n        return nullptr;\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, \"r\", l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        const toff_t nOffsetRequested = nOffset;\n        while( nOffset \u003e 1 )\n        {\n            if( TIFFReadDirectory( l_hTIFF ) == 0 )\n            {\n                XTIFFClose( l_hTIFF );\n                CPLError(\n                    CE_Failure, CPLE_OpenFailed,\n                    \"Requested directory %lu not found.\",\n                    static_cast\u003clong unsigned int\u003e(nOffsetRequested));\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS-\u003eSetDescription( poOpenInfo-\u003epszFilename );\n    poDS-\u003eosFilename = poOpenInfo-\u003epszFilename;\n    poDS-\u003epoActiveDS = poDS;\n    poDS-\u003efpL = l_fpL;\n    poDS-\u003ehTIFF = l_hTIFF;\n    poDS-\u003ebCloseTIFFHandle = true;\n\n    if( !EQUAL(pszFilename,poOpenInfo-\u003epszFilename)\n        \u0026\u0026 !STARTS_WITH_CI(poOpenInfo-\u003epszFilename, \"GTIFF_RAW:\") )\n    {\n        poDS-\u003eSetPhysicalFilename( pszFilename );\n        poDS-\u003eSetSubdatasetName( poOpenInfo-\u003epszFilename );\n        poDS-\u003eosFilename = pszFilename;\n    }\n\n    if( poOpenInfo-\u003eeAccess == GA_Update )\n    {\n        CPLError(\n            CE_Warning, CPLE_AppDefined,\n            \"Opening a specific TIFF directory is not supported in \"\n            \"update mode. Switching to read-only\" );\n    }\n\n    if( poOpenInfo-\u003eAreSiblingFilesLoaded() )\n        poDS-\u003eoOvManager.TransferSiblingFiles(\n            poOpenInfo-\u003eStealSiblingFiles() );\n\n    if( poDS-\u003eOpenOffset( l_hTIFF, \u0026(poDS-\u003epoActiveDS),\n                          nOffset, false, GA_ReadOnly,\n                          bAllowRGBAInterface, true ) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                   ConvertTransferFunctionToString()                  */\n/*                                                                      */\n/*      Convert a transfer function table into a string.                */\n/*      Used by LoadICCProfile().                                       */\n/************************************************************************/\nstatic CPLString ConvertTransferFunctionToString( const uint16 *pTable,\n                                                  uint32 nTableEntries )\n{\n    CPLString sValue;\n\n    for( uint32 i = 0; i \u003c nTableEntries; ++i )\n    {\n        if( i == 0 )\n            sValue = sValue.Printf(\"%d\", static_cast\u003cuint32\u003e(pTable[i]));\n        else\n            sValue = sValue.Printf( \"%s, %d\",\n                                    sValue.c_str(),\n                                    static_cast\u003cuint32\u003e(pTable[i]));\n    }\n\n    return sValue;\n}\n\n/************************************************************************/\n/*                             LoadICCProfile()                         */\n/*                                                                      */\n/*      Load ICC Profile or colorimetric data into metadata             */\n/************************************************************************/\n\nvoid GTiffDataset::LoadICCProfile()\n{\n    if( bICCMetadataLoaded )\n        return;\n    bICCMetadataLoaded = true;\n\n    if( !SetDirectory() )\n        return;\n\n    uint32 nEmbedLen = 0;\n    uint8* pEmbedBuffer = nullptr;\n\n\n    if( TIFFGetField(hTIFF, TIFFTAG_ICCPROFILE, \u0026nEmbedLen, \u0026pEmbedBuffer) )\n    {\n        char *pszBase64Profile =\n            CPLBase64Encode(nEmbedLen, reinterpret_cast\u003cconst GByte*\u003e(pEmbedBuffer));\n\n        oGTiffMDMD.SetMetadataItem( \"SOURCE_ICC_PROFILE\", pszBase64Profile,\n                                    \"COLOR_PROFILE\" );\n\n        CPLFree(pszBase64Profile);\n\n        return;\n    }\n\n    // Check for colorimetric tiff.\n    float* pCHR = nullptr;\n    float* pWP = nullptr;\n    uint16 *pTFR = nullptr;\n    uint16 *pTFG = nullptr;\n    uint16 *pTFB = nullptr;\n    uint16 *pTransferRange = nullptr;\n\n    if( TIFFGetField(hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, \u0026pCHR) )\n    {\n        if( TIFFGetField(hTIFF, TIFFTAG_WHITEPOINT, \u0026pWP) )\n        {\n            if( !TIFFGetFieldDefaulted( hTIFF, TIFFTAG_TRANSFERFUNCTION, \u0026pTFR,\n                                        \u0026pTFG, \u0026pTFB) )\n                return;\n\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFGetFieldDefaulted( hTIFF, TIFFTAG_TRANSFERRANGE,\n                                   \u0026pTransferRange);\n\n            // Set all the colorimetric metadata.\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_RED\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast\u003cdouble\u003e(pCHR[0]),\n                                    static_cast\u003cdouble\u003e(pCHR[1]) ),\n                \"COLOR_PROFILE\" );\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_GREEN\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast\u003cdouble\u003e(pCHR[2]),\n                                    static_cast\u003cdouble\u003e(pCHR[3]) ),\n                \"COLOR_PROFILE\" );\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_BLUE\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast\u003cdouble\u003e(pCHR[4]),\n                                    static_cast\u003cdouble\u003e(pCHR[5]) ),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_WHITEPOINT\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast\u003cdouble\u003e(pWP[0]),\n                                    static_cast\u003cdouble\u003e(pWP[1]) ),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer function metadata.\n\n            // Get length of table.\n            const uint32 nTransferFunctionLength = 1 \u003c\u003c nBitsPerSample;\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                ConvertTransferFunctionToString( pTFR, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                ConvertTransferFunctionToString( pTFG, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                ConvertTransferFunctionToString( pTFB, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer range.\n            if( pTransferRange )\n            {\n                oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_BLACK\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast\u003cint\u003e(pTransferRange[0]),\n                                        static_cast\u003cint\u003e(pTransferRange[2]),\n                                        static_cast\u003cint\u003e(pTransferRange[4])),\n                    \"COLOR_PROFILE\" );\n                oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_WHITE\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast\u003cint\u003e(pTransferRange[1]),\n                                        static_cast\u003cint\u003e(pTransferRange[3]),\n                                        static_cast\u003cint\u003e(pTransferRange[5])),\n                    \"COLOR_PROFILE\" );\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                             SaveICCProfile()                         */\n/*                                                                      */\n/*      Save ICC Profile or colorimetric data into file                 */\n/* pDS:                                                                 */\n/*      Dataset that contains the metadata with the ICC or colorimetric */\n/*      data. If this argument is specified, all other arguments are    */\n/*      ignored. Set them to NULL or 0.                                 */\n/* hTIFF:                                                               */\n/*      Pointer to TIFF handle. Only needed if pDS is NULL or           */\n/*      pDS-\u003ehTIFF is NULL.                                             */\n/* papszParmList:                                                       */\n/*      Options containing the ICC profile or colorimetric metadata.    */\n/*      Ignored if pDS is not NULL.                                     */\n/* nBitsPerSample:                                                      */\n/*      Bits per sample. Ignored if pDS is not NULL.                    */\n/************************************************************************/\n\nvoid GTiffDataset::SaveICCProfile( GTiffDataset *pDS, TIFF *l_hTIFF,\n                                   char **papszParmList,\n                                   uint32 l_nBitsPerSample )\n{\n    if( (pDS != nullptr) \u0026\u0026 (pDS-\u003eeAccess != GA_Update) )\n        return;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( pDS == nullptr )\n            return;\n\n        l_hTIFF = pDS-\u003ehTIFF;\n        if( l_hTIFF == nullptr )\n            return;\n    }\n\n    if( (papszParmList == nullptr) \u0026\u0026 (pDS == nullptr) )\n        return;\n\n    const char *pszValue = nullptr;\n    if( pDS != nullptr )\n        pszValue = pDS-\u003eGetMetadataItem(\"SOURCE_ICC_PROFILE\", \"COLOR_PROFILE\");\n    else\n        pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_ICC_PROFILE\");\n    if( pszValue != nullptr )\n    {\n        char *pEmbedBuffer = CPLStrdup(pszValue);\n        int32 nEmbedLen =\n            CPLBase64DecodeInPlace(reinterpret_cast\u003cGByte *\u003e(pEmbedBuffer));\n\n        TIFFSetField(l_hTIFF, TIFFTAG_ICCPROFILE, nEmbedLen, pEmbedBuffer);\n\n        CPLFree(pEmbedBuffer);\n    }\n    else\n    {\n        // Output colorimetric data.\n        float pCHR[6] = {};  // Primaries.\n        uint16 pTXR[6] = {};  // Transfer range.\n        const char* pszCHRNames[] = {\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\"\n        };\n        const char* pszTXRNames[] = {\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\"\n        };\n\n        // Output chromacities.\n        bool bOutputCHR = true;\n        for( int i = 0; i \u003c 3 \u0026\u0026 bOutputCHR; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue =\n                    pDS-\u003eGetMetadataItem(pszCHRNames[i], \"COLOR_PROFILE\");\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszCHRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputCHR = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputCHR = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j \u003c 3; ++j )\n            {\n                float v = static_cast\u003cfloat\u003e(CPLAtof(papszTokens[j]));\n\n                if( j == 2 )\n                {\n                    // Last term of xyY color must be 1.0.\n                    if( v != 1.0 )\n                    {\n                        bOutputCHR = false;\n                        break;\n                    }\n                }\n                else\n                {\n                    pCHR[i * 2 + j] = v;\n                }\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputCHR )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, pCHR);\n        }\n\n        // Output whitepoint.\n        if( pDS != nullptr )\n            pszValue =\n                pDS-\u003eGetMetadataItem(\"SOURCE_WHITEPOINT\", \"COLOR_PROFILE\");\n        else\n            pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_WHITEPOINT\");\n        if( pszValue != nullptr )\n        {\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            bool bOutputWhitepoint = true;\n            float pWP[2] = { 0.0f, 0.0f };  // Whitepoint\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputWhitepoint = false;\n            }\n            else\n            {\n                for( int j = 0; j \u003c 3; ++j )\n                {\n                    const float v = static_cast\u003cfloat\u003e(CPLAtof(papszTokens[j]));\n\n                    if( j == 2 )\n                    {\n                        // Last term of xyY color must be 1.0.\n                        if( v != 1.0 )\n                        {\n                            bOutputWhitepoint = false;\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        pWP[j] = v;\n                    }\n                }\n            }\n            CSLDestroy( papszTokens );\n\n            if( bOutputWhitepoint )\n            {\n                TIFFSetField(l_hTIFF, TIFFTAG_WHITEPOINT, pWP);\n            }\n        }\n\n        // Set transfer function metadata.\n        char const *pszTFRed = nullptr;\n        if( pDS != nullptr )\n            pszTFRed =\n                pDS-\u003eGetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFRed =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_RED\" );\n\n        char const *pszTFGreen = nullptr;\n        if( pDS != nullptr )\n            pszTFGreen =\n                pDS-\u003eGetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFGreen =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_GREEN\" );\n\n        char const *pszTFBlue = nullptr;\n        if( pDS != nullptr )\n            pszTFBlue =\n                pDS-\u003eGetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFBlue =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_BLUE\" );\n\n        if( (pszTFRed != nullptr) \u0026\u0026 (pszTFGreen != nullptr) \u0026\u0026 (pszTFBlue != nullptr) )\n        {\n            // Get length of table.\n            const int nTransferFunctionLength =\n                1 \u003c\u003c ((pDS!=nullptr)?pDS-\u003enBitsPerSample:l_nBitsPerSample);\n\n            char** papszTokensRed =\n                CSLTokenizeString2(\n                    pszTFRed, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensGreen =\n                CSLTokenizeString2(\n                    pszTFGreen, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensBlue =\n                CSLTokenizeString2(\n                    pszTFBlue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( (CSLCount( papszTokensRed ) == nTransferFunctionLength) \u0026\u0026\n                (CSLCount( papszTokensGreen ) == nTransferFunctionLength) \u0026\u0026\n                (CSLCount( papszTokensBlue ) == nTransferFunctionLength) )\n            {\n                uint16 *pTransferFuncRed =\n                    static_cast\u003cuint16*\u003e( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncGreen =\n                    static_cast\u003cuint16*\u003e( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncBlue =\n                    static_cast\u003cuint16*\u003e( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n\n                // Convert our table in string format into int16 format.\n                for( int i = 0; i \u003c nTransferFunctionLength; ++i )\n                {\n                    pTransferFuncRed[i] =\n                        static_cast\u003cuint16\u003e(atoi(papszTokensRed[i]));\n                    pTransferFuncGreen[i] =\n                        static_cast\u003cuint16\u003e(atoi(papszTokensGreen[i]));\n                    pTransferFuncBlue[i] =\n                        static_cast\u003cuint16\u003e(atoi(papszTokensBlue[i]));\n                }\n\n                TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERFUNCTION,\n                    pTransferFuncRed, pTransferFuncGreen, pTransferFuncBlue);\n\n                CPLFree(pTransferFuncRed);\n                CPLFree(pTransferFuncGreen);\n                CPLFree(pTransferFuncBlue);\n            }\n\n            CSLDestroy( papszTokensRed );\n            CSLDestroy( papszTokensGreen );\n            CSLDestroy( papszTokensBlue );\n        }\n\n        // Output transfer range.\n        bool bOutputTransferRange = true;\n        for( int i = 0; (i \u003c 2) \u0026\u0026 bOutputTransferRange; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue = pDS-\u003eGetMetadataItem( pszTXRNames[i],\n                                                 \"COLOR_PROFILE\" );\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszTXRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputTransferRange = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputTransferRange = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j \u003c 3; ++j )\n            {\n                pTXR[i + j * 2] = static_cast\u003cuint16\u003e(atoi(papszTokens[j]));\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputTransferRange )\n        {\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERRANGE, pTXR);\n        }\n    }\n}\n\n/************************************************************************/\n/*                             OpenOffset()                             */\n/*                                                                      */\n/*      Initialize the GTiffDataset based on a passed in file           */\n/*      handle, and directory offset to utilize.  This is called for    */\n/*      full res, and overview pages.                                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn,\n                                 GTiffDataset **ppoActiveDSRefIn,\n                                 toff_t nDirOffsetIn,\n                                 bool bBaseIn, GDALAccess eAccessIn,\n                                 bool bAllowRGBAInterface,\n                                 bool bReadGeoTransform )\n\n{\n    eAccess = eAccessIn;\n\n    hTIFF = hTIFFIn;\n    ppoActiveDSRef = ppoActiveDSRefIn;\n\n    nDirOffset = nDirOffsetIn;\n\n    if( !SetDirectory( nDirOffsetIn ) )\n        return CE_Failure;\n\n    bBase = bBaseIn;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, \u0026nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, \u0026nYSize );\n    if( nXSize \u003e INT_MAX || nYSize \u003e INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        return CE_Failure;\n    }\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, \u0026nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = nSamplesPerPixel;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, \u0026(nBitsPerSample)) )\n        nBitsPerSample = 1;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, \u0026(nPlanarConfig) ) )\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, \u0026(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, \u0026(nSampleFormat) ) )\n        nSampleFormat = SAMPLEFORMAT_UINT;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, \u0026(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n#if defined(TIFFLIB_VERSION) \u0026\u0026 TIFFLIB_VERSION \u003e 20031007 // 3.6.0\n    if( nCompression != COMPRESSION_NONE \u0026\u0026\n        !TIFFIsCODECConfigured(nCompression) )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG\n        \u0026\u0026 nPhotometric == PHOTOMETRIC_YCBCR\n        \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\",\n                                    \"IMAGE_STRUCTURE\" );\n        int nColorMode = 0;\n        if( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, \u0026nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n    {\n        uint32 l_nBlockXSize = 0;\n        uint32 l_nBlockYSize = 0;\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, \u0026(l_nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, \u0026(l_nBlockYSize) );\n        if( l_nBlockXSize \u003e INT_MAX || l_nBlockYSize \u003e INT_MAX )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too large block size: %u x %u\",\n                     l_nBlockXSize, l_nBlockYSize);\n            return CE_Failure;\n        }\n        nBlockXSize = static_cast\u003cint\u003e(l_nBlockXSize);\n        nBlockYSize = static_cast\u003cint\u003e(l_nBlockYSize);\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           \u0026(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if( nRowsPerStrip \u003e static_cast\u003cuint32\u003e(nRasterYSize) )\n            nRowsPerStrip = nRasterYSize;\n\n        nBlockXSize = nRasterXSize;\n        nBlockYSize = nRowsPerStrip;\n    }\n\n    const int l_nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n    const int l_nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    if( l_nBlocksPerColumn \u003e INT_MAX / l_nBlocksPerRow )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn );\n        return CE_Failure;\n    }\n\n    // Note: we could potentially go up to UINT_MAX blocks, but currently\n    // we use a int nBlockId\n    nBlocksPerBand = l_nBlocksPerColumn * l_nBlocksPerRow;\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE \u0026\u0026\n        nBlocksPerBand \u003e INT_MAX / nBands )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d x %d bands\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn, nBands );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsBitmap = false;\n\n    if( nBitsPerSample == 1 \u0026\u0026 nBands == 1 )\n    {\n        bTreatAsBitmap = true;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(hTIFF)\n            \u0026\u0026 nBlockYSize == nRasterYSize\n            \u0026\u0026 nRasterYSize \u003e 2000\n            // libtiff does not support reading JBIG files with\n            // TIFFReadScanline().\n            \u0026\u0026 nCompression != COMPRESSION_JBIG )\n        {\n            bTreatAsSplitBitmap = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    if(\n#ifdef DEBUG\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_FORCE_RGBA\", \"NO\")) ||\n#endif\n        (bAllowRGBAInterface \u0026\u0026\n        !bTreatAsBitmap \u0026\u0026 !(nBitsPerSample \u003e 8)\n        \u0026\u0026 (nPhotometric == PHOTOMETRIC_CIELAB ||\n            nPhotometric == PHOTOMETRIC_LOGL ||\n            nPhotometric == PHOTOMETRIC_LOGLUV ||\n            nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( nPhotometric == PHOTOMETRIC_YCBCR\n              \u0026\u0026 nCompression != COMPRESSION_JPEG ))) )\n    {\n        char szMessage[1024] = {};\n\n        if( TIFFRGBAImageOK( hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = nullptr;\n            nBands = 4;\n            switch( nPhotometric )\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    nBands = 3; // probably true for other photometric values\n                    break;\n            }\n            if( pszSourceColorSpace )\n                oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\",\n                                            pszSourceColorSpace,\n                                            \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = true;\n\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n\n    // libtiff has various issues with OJPEG compression and chunky-strip\n    // support with the \"classic\" scanline/strip/tile interfaces, and that\n    // wouldn't work either, so better bail out.\n    if( nCompression == COMPRESSION_OJPEG \u0026\u0026\n        !bTreatAsRGBA )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Old-JPEG compression only supported through RGBA interface, \"\n                 \"which cannot be used probably because the file is corrupted\");\n        return CE_Failure;\n    }\n\n    // If photometric is YCbCr, scanline/strip/tile interfaces assumes that\n    // we are ready with downsampled data. And we are not.\n    if( nCompression != COMPRESSION_JPEG \u0026\u0026\n        nCompression != COMPRESSION_OJPEG \u0026\u0026\n        nPhotometric == PHOTOMETRIC_YCBCR \u0026\u0026\n        nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        !bTreatAsRGBA )\n    {\n        uint16 nF1, nF2;\n        TIFFGetFieldDefaulted(hTIFF,TIFFTAG_YCBCRSUBSAMPLING,\u0026nF1,\u0026nF2);\n        if( nF1 != 1 || nF2 != 1 )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Cannot open TIFF file with YCbCr, subsampling and \"\n                      \"BitsPerSample \u003e 8 that is not JPEG compressed\" );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(hTIFF)\n        \u0026\u0026 nBitsPerSample == 8\n        \u0026\u0026 nBlockYSize == nRasterYSize\n        \u0026\u0026 nRasterYSize \u003e 2000\n        \u0026\u0026 !bTreatAsRGBA\n        \u0026\u0026 CPLTestBool(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")) )\n    {\n        // libtiff 3.9.2 (20091104) and older, libtiff 4.0.0beta5 (also\n        // 20091104) and older will crash when trying to open a\n        // all-in-one-strip YCbCr JPEG compressed TIFF (see #3259).\n#if (TIFFLIB_VERSION \u003c= 20091104 \u0026\u0026 !defined(BIGTIFF_SUPPORT)) || \\\n    (TIFFLIB_VERSION \u003c= 20091104 \u0026\u0026 defined(BIGTIFF_SUPPORT))\n        if( nPhotometric == PHOTOMETRIC_YCBCR \u0026\u0026\n            nCompression == COMPRESSION_JPEG )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"Avoid using split band to open all-in-one-strip \"\n                \"YCbCr JPEG compressed TIFF because of older libtiff\" );\n        }\n        else\n#endif\n        {\n            bTreatAsSplit = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsOdd = false;\n    if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if( nBitsPerSample == 16 || nBitsPerSample == 24 )\n            bTreatAsOdd = true;\n    }\n    else if( !bTreatAsRGBA \u0026\u0026 !bTreatAsBitmap\n             \u0026\u0026 nBitsPerSample != 8\n             \u0026\u0026 nBitsPerSample != 16\n             \u0026\u0026 nBitsPerSample != 32\n             \u0026\u0026 nBitsPerSample != 64\n             \u0026\u0026 nBitsPerSample != 128 )\n    {\n        bTreatAsOdd = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We don't support 'chunks' bigger than 2GB although libtiff v4   */\n/*      can.                                                            */\n/* -------------------------------------------------------------------- */\n#if defined(BIGTIFF_SUPPORT)\n    uint64 nChunkSize = 0;\n    if( bTreatAsSplit || bTreatAsSplitBitmap )\n    {\n        nChunkSize = TIFFScanlineSize64( hTIFF );\n    }\n    else\n    {\n        if( TIFFIsTiled(hTIFF) )\n            nChunkSize = TIFFTileSize64( hTIFF );\n        else\n            nChunkSize = TIFFStripSize64( hTIFF );\n    }\n    if( bTreatAsRGBA )\n    {\n        nChunkSize = std::max(nChunkSize,\n                        4 * static_cast\u003cuint64\u003e(nBlockXSize) * nBlockYSize);\n    }\n    if( nChunkSize \u003e static_cast\u003cuint64\u003e(INT_MAX) )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Scanline/tile/strip size bigger than 2GB.\" );\n        return CE_Failure;\n    }\n#endif\n\n    const bool bMinIsWhite = nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    char *pszText = nullptr;\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_NODATA, \u0026pszText ) \u0026\u0026\n        !EQUAL(pszText, \"\") )\n    {\n        bNoDataSet = true;\n        dfNoDataValue = CPLAtofM( pszText );\n        if( nBitsPerSample == 32 \u0026\u0026 nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        {\n            dfNoDataValue = GDALAdjustNoDataCloseToFloatMax(dfNoDataValue);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( bTreatAsRGBA || nBitsPerSample \u003e 16\n        || TIFFGetField( hTIFF, TIFFTAG_COLORMAP,\n                         \u0026panRed, \u0026panGreen, \u0026panBlue) == 0 )\n    {\n        // Build inverted palette if we have inverted photometric.\n        // Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n        if( nBitsPerSample \u003c= 16 \u0026\u0026 nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            poColorTable = new GDALColorTable();\n            const int nColorCount = 1 \u003c\u003c nBitsPerSample;\n\n            for( int iColor = 0; iColor \u003c nColorCount; ++iColor )\n            {\n                const short nValue =\n                    static_cast\u003cshort\u003e(((255 * (nColorCount - 1 - iColor)) /\n                                        (nColorCount - 1)));\n                const GDALColorEntry oEntry =\n                    { nValue, nValue, nValue, static_cast\u003cshort\u003e(255) };\n                poColorTable-\u003eSetColorEntry( iColor, \u0026oEntry );\n            }\n\n            nPhotometric = PHOTOMETRIC_PALETTE;\n        }\n        else\n        {\n            poColorTable = nullptr;\n        }\n    }\n    else\n    {\n        unsigned short nMaxColor = 0;\n\n        poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 \u003c\u003c nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor \u003e= 0; iColor-- )\n        {\n            // TODO(schwehr): Ensure the color entries are never negative?\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast\u003cshort\u003e(panRed[iColor] / divisor),\n                static_cast\u003cshort\u003e(panGreen[iColor] / divisor),\n                static_cast\u003cshort\u003e(panBlue[iColor] / divisor),\n                static_cast\u003cshort\u003e(\n                    bNoDataSet \u0026\u0026 static_cast\u003cint\u003e(dfNoDataValue) == iColor\n                    ? 0\n                    : 255)\n            };\n\n            poColorTable-\u003eSetColorEntry( iColor, \u0026oEntry );\n\n            nMaxColor = std::max(nMaxColor, panRed[iColor]);\n            nMaxColor = std::max(nMaxColor, panGreen[iColor]);\n            nMaxColor = std::max(nMaxColor, panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor \u003e 0 \u0026\u0026 nMaxColor \u003c 256 )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n\n            for( int iColor = nColorCount - 1; iColor \u003e= 0; iColor-- )\n            {\n                // TODO(schwehr): Ensure the color entries are never negative?\n                const GDALColorEntry oEntry = {\n                    static_cast\u003cshort\u003e(panRed[iColor]),\n                    static_cast\u003cshort\u003e(panGreen[iColor]),\n                    static_cast\u003cshort\u003e(panBlue[iColor]),\n                    bNoDataSet \u0026\u0026\n                    static_cast\u003cint\u003e(dfNoDataValue) == iColor\n                    ? static_cast\u003cshort\u003e(0)\n                    : static_cast\u003cshort\u003e(255)\n                };\n\n                poColorTable-\u003eSetColorEntry( iColor, \u0026oEntry );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand \u003c nBands; ++iBand )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand + 1, new GTiffRGBABand( this, iBand + 1 ) );\n        else if( bTreatAsSplitBitmap )\n            SetBand( iBand + 1, new GTiffSplitBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsSplit )\n            SetBand( iBand + 1, new GTiffSplitBand( this, iBand + 1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand + 1, new GTiffBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand + 1, new GTiffOddBitsBand( this, iBand + 1 ) );\n        else\n            SetBand( iBand + 1, new GTiffRasterBand( this, iBand + 1 ) );\n    }\n\n    if( GetRasterBand(1)-\u003eGetRasterDataType() == GDT_Unknown )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Unsupported TIFF configuration: BitsPerSample(=%d) and \"\n                 \"SampleType(=%d)\",\n                 nBitsPerSample,\n                 nSampleFormat);\n        return CE_Failure;\n    }\n\n    m_bReadGeoTransform = bReadGeoTransform;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char szWorkMDI[200] = {};\n    uint16 nShort = 0;\n\n    for( size_t iTag = 0;\n         iTag \u003c sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n         ++iTag )\n    {\n        if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n        {\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, \u0026pszText ) )\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            pszText );\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n        {\n            float fVal = 0.0;\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, \u0026fVal ) )\n            {\n                CPLsnprintf( szWorkMDI, sizeof(szWorkMDI), \"%.8g\", fVal );\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT \u0026\u0026\n                 asTIFFTags[iTag].nTagVal != TIFFTAG_RESOLUTIONUNIT )\n        {\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, \u0026nShort ) )\n            {\n                snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n        {\n            uint32 nCount = 0;\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                              \u0026nCount, \u0026pszText ) )\n            {\n                std::string osStr;\n                osStr.assign(pszText, nCount);\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            osStr.c_str() );\n            }\n        }\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, \u0026nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            snprintf( szWorkMDI, sizeof(szWorkMDI),\n                      \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/cm)\", nShort );\n        else\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n        oGTiffMDMD.SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    int nTagSize = 0;\n    void* pData = nullptr;\n    if( TIFFGetField( hTIFF, TIFFTAG_XMLPACKET, \u0026nTagSize, \u0026pData ) )\n    {\n        char* pszXMP =\n            static_cast\u003cchar *\u003e( VSI_MALLOC_VERBOSE(nTagSize + 1) );\n        if( pszXMP )\n        {\n            memcpy(pszXMP, pData, nTagSize);\n            pszXMP[nTagSize] = '\\0';\n\n            char *apszMDList[2] = { pszXMP, nullptr };\n            oGTiffMDMD.SetMetadata(apszMDList, \"xml:XMP\");\n\n            CPLFree(pszXMP);\n        }\n    }\n\n    if( nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( nCompression == COMPRESSION_CCITTRLE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTFAX3 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTFAX4 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LZW )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_OJPEG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nPhotometric == PHOTOMETRIC_YCBCR )\n            oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n        else\n            oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_NEXT )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTRLEW )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PACKBITS )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PACKBITS\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_THUNDERSCAN )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PIXARFILM )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PIXARLOG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_DEFLATE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_ADOBE_DEFLATE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_DCS )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JBIG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_SGILOG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_SGILOG24 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG24\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JP2000 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JP2000\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LZMA )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZMA\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_ZSTD )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"ZSTD\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LERC )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC\", \"IMAGE_STRUCTURE\" );\n#if HAVE_LERC\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_PARAMETERS, \u0026nLercParamCount,\n                          \u0026panLercParms ) \u0026\u0026\n            nLercParamCount == 2 )\n        {\n            memcpy( anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(anLercAddCompressionAndVersion) );\n        }\n\n        uint32 nAddVersion = LERC_ADD_COMPRESSION_NONE;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_ADD_COMPRESSION, \u0026nAddVersion ) \u0026\u0026\n            nAddVersion != LERC_ADD_COMPRESSION_NONE )\n        {\n            if( nAddVersion == LERC_ADD_COMPRESSION_DEFLATE )\n            {\n                oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_DEFLATE\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else if( nAddVersion == LERC_ADD_COMPRESSION_ZSTD )\n            {\n                oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_ZSTD\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n        }\n        uint32 nLercVersion = LERC_VERSION_2_4;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_VERSION, \u0026nLercVersion) )\n        {\n            if( nLercVersion == LERC_VERSION_2_4 )\n            {\n                oGTiffMDMD.SetMetadataItem( \"LERC_VERSION\", \"2.4\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"Unknown Lerc version: %d\", nLercVersion);\n            }\n        }\n#endif\n    }\n    else if( nCompression == COMPRESSION_WEBP )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"WEBP\", \"IMAGE_STRUCTURE\" );\n    }\n    else\n    {\n        CPLString oComp;\n        oComp.Printf( \"%d\", nCompression);\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", oComp.c_str());\n    }\n\n    if( nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 nBands != 1 )\n        oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if( (GetRasterBand(1)-\u003eGetRasterDataType() == GDT_Byte \u0026\u0026\n         nBitsPerSample != 8 ) ||\n        (GetRasterBand(1)-\u003eGetRasterDataType() == GDT_UInt16 \u0026\u0026\n         nBitsPerSample != 16) ||\n        ((GetRasterBand(1)-\u003eGetRasterDataType() == GDT_UInt32 ||\n          GetRasterBand(1)-\u003eGetRasterDataType() == GDT_Float32) \u0026\u0026\n         nBitsPerSample != 32) )\n    {\n        for( int i = 0; i \u003c nBands; ++i )\n            cpl::down_cast\u003cGTiffRasterBand*\u003e(GetRasterBand(i + 1))-\u003e\n                oGTiffMDMD.SetMetadataItem(\n                    \"NBITS\",\n                    CPLString().Printf(\n                        \"%d\", static_cast\u003cint\u003e(nBitsPerSample) ),\n                    \"IMAGE_STRUCTURE\" );\n    }\n\n    if( bMinIsWhite )\n        oGTiffMDMD.SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, \u0026pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = nullptr;\n\n        if( psRoot != nullptr \u0026\u0026 psRoot-\u003eeType == CXT_Element\n            \u0026\u0026 EQUAL(psRoot-\u003epszValue,\"GDALMetadata\") )\n            psItem = psRoot-\u003epsChild;\n\n        for( ; psItem != nullptr; psItem = psItem-\u003epsNext )\n        {\n\n            if( psItem-\u003eeType != CXT_Element\n                || !EQUAL(psItem-\u003epszValue,\"Item\") )\n                continue;\n\n            const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n            const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n            int nBand =\n                atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n            if( nBand \u003c -1 || nBand \u003e 65535 )\n                continue;\n            nBand ++;\n            const char *pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            const char *pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n\n            if( pszKey == nullptr || pszValue == nullptr )\n                continue;\n            if( EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n                continue;\n\n            bool bIsXML = false;\n\n            if( STARTS_WITH_CI(pszDomain, \"xml:\") )\n                bIsXML = TRUE;\n\n            char *pszUnescapedValue =\n                CPLUnescapeString( pszValue, nullptr, CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, nullptr };\n                    oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                }\n                else\n                {\n                    oGTiffMDMD.SetMetadataItem( pszKey, pszUnescapedValue,\n                                                pszDomain );\n                }\n            }\n            else\n            {\n                GTiffRasterBand *poBand =\n                    cpl::down_cast\u003cGTiffRasterBand*\u003e(GetRasterBand(nBand));\n                if( poBand != nullptr )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                    {\n                        poBand-\u003ebHaveOffsetScale = true;\n                        poBand-\u003edfScale = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"offset\") )\n                    {\n                        poBand-\u003ebHaveOffsetScale = true;\n                        poBand-\u003edfOffset = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"unittype\") )\n                    {\n                        poBand-\u003eosUnitType = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole,\"description\") )\n                    {\n                        poBand-\u003eosDescription = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole, \"colorinterp\") )\n                    {\n                        poBand-\u003eeBandInterp =\n                            GDALGetColorInterpretationByName(pszUnescapedValue);\n                    }\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, nullptr };\n                            poBand-\u003eoGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                        {\n                            poBand-\u003eoGTiffMDMD.SetMetadataItem(\n                                pszKey,\n                                pszUnescapedValue,\n                                pszDomain );\n                        }\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    if( bStreamingIn )\n    {\n        toff_t* panOffsets = nullptr;\n        TIFFGetField( hTIFF,\n                      TIFFIsTiled( hTIFF ) ?\n                      TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                      \u0026panOffsets );\n        if( panOffsets )\n        {\n            int nBlockCount =\n                TIFFIsTiled(hTIFF) ?\n                TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n            for( int i = 1; i \u003c nBlockCount; ++i )\n            {\n                if( panOffsets[i] \u003c panOffsets[i-1] )\n                {\n                    oGTiffMDMD.SetMetadataItem( \"UNORDERED_BLOCKS\", \"YES\",\n                                                \"TIFF\");\n                    CPLDebug(\n                        \"GTIFF\",\n                        \"Offset of block %d is lower than previous block. \"\n                        \"Reader must be careful\",\n                        i );\n                    break;\n                }\n            }\n        }\n    }\n\n    if( nCompression == COMPRESSION_JPEG \u0026\u0026 eAccess == GA_Update )\n    {\n        SetJPEGQualityAndTablesModeFromFile();\n    }\n\n    CPLAssert(m_bReadGeoTransform == bReadGeoTransform);\n    CPLAssert(!bMetadataChanged);\n    bMetadataChanged = false;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                         GetSiblingFiles()                            */\n/************************************************************************/\n\nchar** GTiffDataset::GetSiblingFiles()\n{\n    if( m_bHasGotSiblingFiles )\n    {\n        return oOvManager.GetSiblingFiles();\n    }\n\n    m_bHasGotSiblingFiles = true;\n    const int nMaxFiles =\n        atoi(CPLGetConfigOption(\"GDAL_READDIR_LIMIT_ON_OPEN\", \"1000\"));\n    char** papszSiblingFiles =\n        VSIReadDirEx(CPLGetDirname(osFilename), nMaxFiles);\n    if( nMaxFiles \u003e 0 \u0026\u0026 CSLCount(papszSiblingFiles) \u003e nMaxFiles )\n    {\n        CPLDebug(\"GTiff\", \"GDAL_READDIR_LIMIT_ON_OPEN reached on %s\",\n                 CPLGetDirname(osFilename));\n        CSLDestroy(papszSiblingFiles);\n        papszSiblingFiles = nullptr;\n    }\n    oOvManager.TransferSiblingFiles( papszSiblingFiles );\n\n    return papszSiblingFiles;\n}\n\n/************************************************************************/\n/*                   IdentifyAuthorizedGeoreferencingSources()          */\n/************************************************************************/\n\nvoid GTiffDataset::IdentifyAuthorizedGeoreferencingSources()\n{\n    if( m_bHasIdentifiedAuthorizedGeoreferencingSources )\n        return;\n    m_bHasIdentifiedAuthorizedGeoreferencingSources = true;\n    CPLString osGeorefSources = CSLFetchNameValueDef( papszOpenOptions,\n        \"GEOREF_SOURCES\",\n        CPLGetConfigOption(\"GDAL_GEOREF_SOURCES\",\n                           \"PAM,INTERNAL,TABFILE,WORLDFILE\") );\n    char** papszTokens = CSLTokenizeString2(osGeorefSources, \",\", 0);\n    m_nPAMGeorefSrcIndex = CSLFindString(papszTokens, \"PAM\");\n    m_nINTERNALGeorefSrcIndex = CSLFindString(papszTokens, \"INTERNAL\");\n    m_nTABFILEGeorefSrcIndex = CSLFindString(papszTokens, \"TABFILE\");\n    m_nWORLDFILEGeorefSrcIndex = CSLFindString(papszTokens, \"WORLDFILE\");\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                     LoadGeoreferencingAndPamIfNeeded()               */\n/************************************************************************/\n\nvoid GTiffDataset::LoadGeoreferencingAndPamIfNeeded()\n\n{\n    if( !m_bReadGeoTransform \u0026\u0026 !m_bLoadPam )\n        return;\n\n    IdentifyAuthorizedGeoreferencingSources();\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( m_bReadGeoTransform )\n    {\n        m_bReadGeoTransform = false;\n\n        if( !SetDirectory() )\n            return;\n\n        char *pszTabWKT = nullptr;\n        double *padfTiePoints = nullptr;\n        double *padfScale = nullptr;\n        double *padfMatrix = nullptr;\n        uint16 nCount = 0;\n        bool bPixelIsPoint = false;\n        short nRasterType = 0;\n        bool bPointGeoIgnore = false;\n\n        std::set\u003cint\u003e aoSetPriorities;\n        if( m_nINTERNALGeorefSrcIndex \u003e= 0 )\n            aoSetPriorities.insert(m_nINTERNALGeorefSrcIndex);\n        if( m_nTABFILEGeorefSrcIndex \u003e= 0 )\n            aoSetPriorities.insert(m_nTABFILEGeorefSrcIndex);\n        if( m_nWORLDFILEGeorefSrcIndex \u003e= 0 )\n            aoSetPriorities.insert(m_nWORLDFILEGeorefSrcIndex);\n        std::set\u003cint\u003e::iterator oIter = aoSetPriorities.begin();\n        for( ; oIter != aoSetPriorities.end(); ++oIter )\n        {\n            int nIndex = *oIter;\n            if( m_nINTERNALGeorefSrcIndex == nIndex )\n            {\n                GTIF *psGTIF = GTiffDatasetGTIFNew( hTIFF );  // How expensive this is?\n\n                if( psGTIF )\n                {\n                    if( GDALGTIFKeyGetSHORT(psGTIF, GTRasterTypeGeoKey,\n                                            \u0026nRasterType, 0, 1 ) == 1\n                        \u0026\u0026 nRasterType ==\n                           static_cast\u003cshort\u003e(RasterPixelIsPoint) )\n                    {\n                        bPixelIsPoint = true;\n                        bPointGeoIgnore =\n                            CPLTestBool(\n                                CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                                   \"FALSE\") );\n                    }\n\n                    GTIFFree( psGTIF );\n                }\n\n                adfGeoTransform[0] = 0.0;\n                adfGeoTransform[1] = 1.0;\n                adfGeoTransform[2] = 0.0;\n                adfGeoTransform[3] = 0.0;\n                adfGeoTransform[4] = 0.0;\n                adfGeoTransform[5] = 1.0;\n\n                uint16 nCountScale = 0;\n                if( TIFFGetField(hTIFF, TIFFTAG_GEOPIXELSCALE,\n                                 \u0026nCountScale, \u0026padfScale )\n                    \u0026\u0026 nCountScale \u003e= 2\n                    \u0026\u0026 padfScale[0] != 0.0 \u0026\u0026 padfScale[1] != 0.0 )\n                {\n                    adfGeoTransform[1] = padfScale[0];\n                    if( padfScale[1] \u003c 0 )\n                    {\n                        const char* pszOptionVal =\n                            CPLGetConfigOption(\"GTIFF_HONOUR_NEGATIVE_SCALEY\",\n                                               nullptr);\n                        if( pszOptionVal == nullptr )\n                        {\n                            CPLError(CE_Warning, CPLE_AppDefined,\n                                \"File with negative value for ScaleY in \"\n                                \"GeoPixelScale tag. This is rather \"\n                                \"unusual. GDAL, contrary to the GeoTIFF \"\n                                \"specification, assumes that the file \"\n                                \"was intended to be north-up, and will \"\n                                \"treat this file as if ScaleY was \"\n                                \"positive. You may override this behaviour \"\n                                \"by setting the GTIFF_HONOUR_NEGATIVE_SCALEY \"\n                                \"configuration option to YES\");\n                            adfGeoTransform[5] = padfScale[1];\n                        }\n                        else if( CPLTestBool(pszOptionVal) )\n                        {\n                            adfGeoTransform[5] = -padfScale[1];\n                        }\n                        else\n                        {\n                            adfGeoTransform[5] = padfScale[1];\n                        }\n                    }\n                    else\n                    {\n                        adfGeoTransform[5] = -padfScale[1];\n                    }\n\n                    if( TIFFGetField(hTIFF, TIFFTAG_GEOTIEPOINTS,\n                                     \u0026nCount, \u0026padfTiePoints )\n                        \u0026\u0026 nCount \u003e= 6 )\n                    {\n                        adfGeoTransform[0] =\n                            padfTiePoints[3] -\n                            padfTiePoints[0] * adfGeoTransform[1];\n                        adfGeoTransform[3] =\n                            padfTiePoints[4] -\n                            padfTiePoints[1] * adfGeoTransform[5];\n\n                        if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n                        {\n                            adfGeoTransform[0] -=\n                                (adfGeoTransform[1] * 0.5 +\n                                 adfGeoTransform[2] * 0.5);\n                            adfGeoTransform[3] -=\n                                (adfGeoTransform[4] * 0.5 +\n                                 adfGeoTransform[5] * 0.5);\n                        }\n\n                        bGeoTransformValid = true;\n                        m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                        if( nCountScale \u003e= 3 \u0026\u0026 GetRasterCount() == 1 \u0026\u0026\n                            (padfScale[2] != 0.0 ||\n                             padfTiePoints[2] != 0.0 ||\n                             padfTiePoints[5] != 0.0) )\n                        {\n                            LookForProjection();\n                            if( pszProjection \u0026\u0026 HasVerticalCS(pszProjection) )\n                            {\n                                /* modelTiePointTag = (pixel, line, z0, X, Y, Z0) */\n                                /* thus Z(some_point) = (z(some_point) - z0) * scaleZ + Z0 */\n                                /* equivalently written as */\n                                /* Z(some_point) = z(some_point) * scaleZ + offsetZ with */\n                                /* offsetZ = - z0 * scaleZ + Z0 */\n                                double dfScale = padfScale[2];\n                                double dfOffset =\n                                    -padfTiePoints[2] * dfScale + padfTiePoints[5];\n                                GTiffRasterBand* poBand =\n                                    cpl::down_cast\u003cGTiffRasterBand*\u003e(GetRasterBand(1));\n                                poBand-\u003ebHaveOffsetScale = true;\n                                poBand-\u003edfScale = dfScale;\n                                poBand-\u003edfOffset = dfOffset;\n                            }\n                        }\n                    }\n                }\n\n                else if( TIFFGetField(hTIFF, TIFFTAG_GEOTRANSMATRIX,\n                                      \u0026nCount, \u0026padfMatrix )\n                        \u0026\u0026 nCount == 16 )\n                {\n                    adfGeoTransform[0] = padfMatrix[3];\n                    adfGeoTransform[1] = padfMatrix[0];\n                    adfGeoTransform[2] = padfMatrix[1];\n                    adfGeoTransform[3] = padfMatrix[7];\n                    adfGeoTransform[4] = padfMatrix[4];\n                    adfGeoTransform[5] = padfMatrix[5];\n\n                    if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n                    {\n                        adfGeoTransform[0] -=\n                            adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                        adfGeoTransform[3] -=\n                            adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                    }\n\n                    bGeoTransformValid = true;\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tab, .tfw, .tifw or .wld file.     */\n/* -------------------------------------------------------------------- */\n            if( m_nTABFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                // Begin with .tab since it can also have projection info.\n                const int bTabFileOK =\n                    GDALReadTabFile2( osFilename, adfGeoTransform,\n                                        \u0026pszTabWKT, \u0026nGCPCount, \u0026pasGCPList,\n                                        papszSiblingFiles, \u0026pszGeorefFilename );\n\n                if( bTabFileOK )\n                {\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                    // if( pszTabWKT )\n                    // {\n                    //     m_nProjectionGeorefSrcIndex = nIndex;\n                    // }\n                    if( nGCPCount == 0 )\n                    {\n                        bGeoTransformValid = true;\n                    }\n                }\n\n                if( pszGeorefFilename )\n                {\n                    osGeorefFilename = pszGeorefFilename;\n                    CPLFree(pszGeorefFilename);\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n\n            if( m_nWORLDFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                bGeoTransformValid = CPL_TO_BOOL( GDALReadWorldFile2(\n                                osFilename, nullptr, adfGeoTransform,\n                                papszSiblingFiles, \u0026pszGeorefFilename) );\n\n                if( !bGeoTransformValid )\n                {\n                    bGeoTransformValid =\n                        CPL_TO_BOOL( GDALReadWorldFile2(\n                            osFilename, \"wld\", adfGeoTransform,\n                            papszSiblingFiles, \u0026pszGeorefFilename ) );\n                }\n                if( bGeoTransformValid )\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                if( pszGeorefFilename )\n                {\n                    osGeorefFilename = pszGeorefFilename;\n                    CPLFree(pszGeorefFilename);\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.                                                 */\n/* -------------------------------------------------------------------- */\n        if( m_nINTERNALGeorefSrcIndex \u003e= 0 \u0026\u0026\n            TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,\u0026nCount,\u0026padfTiePoints )\n            \u0026\u0026 !bGeoTransformValid )\n        {\n            if( nGCPCount \u003e 0 )\n            {\n                GDALDeinitGCPs( nGCPCount, pasGCPList );\n                CPLFree( pasGCPList );\n            }\n            nGCPCount = nCount / 6;\n            pasGCPList =\n                static_cast\u003cGDAL_GCP *\u003e(CPLCalloc(sizeof(GDAL_GCP), nGCPCount));\n\n            for( int iGCP = 0; iGCP \u003c nGCPCount; ++iGCP )\n            {\n                char szID[32] = {};\n\n                snprintf( szID, sizeof(szID), \"%d\", iGCP + 1 );\n                pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n\n                if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n                {\n                    pasGCPList[iGCP].dfGCPPixel -= 0.5;\n                    pasGCPList[iGCP].dfGCPLine -= 0.5;\n                }\n            }\n            m_nGeoTransformGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use its coordinate       */\n/*      system and give it precedence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != nullptr\n            \u0026\u0026 (pszProjection == nullptr || pszProjection[0] == '\\0') )\n        {\n            CPLFree( pszProjection );\n            pszProjection = pszTabWKT;\n            pszTabWKT = nullptr;\n            bLookedForProjection = true;\n        }\n\n        CPLFree( pszTabWKT );\n    }\n\n    if( m_bLoadPam \u0026\u0026 m_nPAMGeorefSrcIndex \u003e= 0 )\n    {\n/* -------------------------------------------------------------------- */\n/*      Initialize any PAM information.                                 */\n/* -------------------------------------------------------------------- */\n        CPLAssert(!bColorProfileMetadataChanged);\n        CPLAssert(!bMetadataChanged);\n        CPLAssert(!bGeoTIFFInfoChanged);\n        CPLAssert(!bNoDataChanged);\n\n        // We must absolutely unset m_bLoadPam now, otherwise calling\n        // GetFileList() on a .tif with a .aux will result in an (almost)\n        // endless sequence of calls.\n        m_bLoadPam = false;\n\n        TryLoadXML( GetSiblingFiles() );\n        ApplyPamInfo();\n\n        bColorProfileMetadataChanged = false;\n        bMetadataChanged = false;\n        bGeoTIFFInfoChanged = false;\n        bNoDataChanged = false;\n\n        for( int i = 1; i \u003c= nBands; ++i )\n        {\n            GTiffRasterBand* poBand =\n                cpl::down_cast\u003cGTiffRasterBand *\u003e(GetRasterBand(i));\n\n            /* Load scale, offset and unittype from PAM if available */\n            if( !poBand-\u003ebHaveOffsetScale )\n            {\n                int nHaveOffsetScale = FALSE;\n                poBand-\u003edfScale =\n                    poBand-\u003eGDALPamRasterBand::GetScale( \u0026nHaveOffsetScale );\n                poBand-\u003ebHaveOffsetScale = CPL_TO_BOOL(nHaveOffsetScale);\n                poBand-\u003edfOffset = poBand-\u003eGDALPamRasterBand::GetOffset();\n            }\n            if( poBand-\u003eosUnitType.empty() )\n            {\n                const char* pszUnitType =\n                    poBand-\u003eGDALPamRasterBand::GetUnitType();\n                if( pszUnitType )\n                    poBand-\u003eosUnitType = pszUnitType;\n            }\n            if( poBand-\u003eosDescription.empty() )\n                poBand-\u003eosDescription =\n                    poBand-\u003eGDALPamRasterBand::GetDescription();\n\n            GDALColorInterp ePAMColorInterp =\n                poBand-\u003eGDALPamRasterBand::GetColorInterpretation();\n            if( ePAMColorInterp != GCI_Undefined )\n                poBand-\u003eeBandInterp = ePAMColorInterp;\n        }\n    }\n    m_bLoadPam = false;\n}\n\n/************************************************************************/\n/*                          ScanDirectories()                           */\n/*                                                                      */\n/*      Scan through all the directories finding overviews, masks       */\n/*      and subdatasets.                                                */\n/************************************************************************/\n\nvoid GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !bScanDeferred )\n        return;\n\n    bScanDeferred = false;\n\n    if( !bBase )\n        return;\n\n    if( TIFFLastDirectory( hTIFF ) )\n        return;\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n    while( !TIFFLastDirectory( hTIFF )\n           \u0026\u0026 (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nThisDir = TIFFCurrentDirOffset(hTIFF);\n        uint32 nSubType = 0;\n\n        *ppoActiveDSRef = nullptr; // Our directory no longer matches this ds.\n\n        ++iDirIndex;\n\n        if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, \u0026nSubType) )\n            nSubType = 0;\n\n        /* Embedded overview of the main image */\n        if( (nSubType \u0026 FILETYPE_REDUCEDIMAGE) != 0 \u0026\u0026\n            (nSubType \u0026 FILETYPE_MASK) == 0 \u0026\u0026\n            iDirIndex != 1 \u0026\u0026\n            nOverviewCount \u003c 30 /* to avoid DoS */ )\n        {\n            GTiffDataset *poODS = new GTiffDataset();\n            poODS-\u003eosFilename = osFilename;\n            if( poODS-\u003eOpenOffset( hTIFF, ppoActiveDSRef, nThisDir, false,\n                                   eAccess ) != CE_None\n                || poODS-\u003eGetRasterCount() != GetRasterCount() )\n            {\n                delete poODS;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                          poODS-\u003eGetRasterXSize(), poODS-\u003eGetRasterYSize());\n                ++nOverviewCount;\n                papoOverviewDS = static_cast\u003cGTiffDataset **\u003e(\n                    CPLRealloc(papoOverviewDS,\n                               nOverviewCount * (sizeof(void*))) );\n                papoOverviewDS[nOverviewCount-1] = poODS;\n                poODS-\u003epoBaseDS = this;\n                poODS-\u003ebIsOverview_ = true;\n            }\n        }\n        // Embedded mask of the main image.\n        else if( (nSubType \u0026 FILETYPE_MASK) != 0 \u0026\u0026\n                 (nSubType \u0026 FILETYPE_REDUCEDIMAGE) == 0 \u0026\u0026\n                 iDirIndex != 1 \u0026\u0026\n                 poMaskDS == nullptr )\n        {\n            poMaskDS = new GTiffDataset();\n            poMaskDS-\u003eosFilename = osFilename;\n\n            // The TIFF6 specification - page 37 - only allows 1\n            // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n            // 8 bit per sample and we support either 1 sample per pixel or as\n            // many samples as in the main image We don't check the value of\n            // the PhotometricInterpretation tag, which should be set to\n            // \"Transparency mask\" (4) according to the specification (page\n            // 36).  However, the TIFF6 specification allows image masks to\n            // have a higher resolution than the main image, what we don't\n            // support here.\n\n            if( poMaskDS-\u003eOpenOffset( hTIFF, ppoActiveDSRef, nThisDir,\n                                      false, eAccess ) != CE_None\n                || poMaskDS-\u003eGetRasterCount() == 0\n                || !(poMaskDS-\u003eGetRasterCount() == 1\n                     || poMaskDS-\u003eGetRasterCount() == GetRasterCount())\n                || poMaskDS-\u003eGetRasterXSize() != GetRasterXSize()\n                || poMaskDS-\u003eGetRasterYSize() != GetRasterYSize()\n                || poMaskDS-\u003eGetRasterBand(1)-\u003eGetRasterDataType() != GDT_Byte)\n            {\n                delete poMaskDS;\n                poMaskDS = nullptr;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened band mask.\");\n                poMaskDS-\u003epoBaseDS = this;\n\n                poMaskDS-\u003ebPromoteTo8Bits =\n                    CPLTestBool(\n                        CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                            \"YES\" ) );\n            }\n        }\n\n        // Embedded mask of an overview.  The TIFF6 specification allows the\n        // combination of the FILETYPE_xxxx masks.\n        else if( (nSubType \u0026 FILETYPE_REDUCEDIMAGE) != 0 \u0026\u0026\n                 (nSubType \u0026 FILETYPE_MASK) != 0 \u0026\u0026\n                 iDirIndex != 1 )\n        {\n            GTiffDataset* poDS = new GTiffDataset();\n            poDS-\u003eosFilename = osFilename;\n            if( poDS-\u003eOpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE,\n                                  eAccess ) != CE_None\n                || poDS-\u003eGetRasterCount() == 0\n                || poDS-\u003eGetRasterBand(1)-\u003eGetRasterDataType() != GDT_Byte)\n            {\n                delete poDS;\n            }\n            else\n            {\n                int i = 0;  // Used after for.\n                for( ; i \u003c nOverviewCount; ++i )\n                {\n                    if( cpl::down_cast\u003cGTiffDataset *\u003e(GDALDataset::FromHandle(\n                           papoOverviewDS[i]))-\u003epoMaskDS == nullptr \u0026\u0026\n                        poDS-\u003eGetRasterXSize() ==\n                        papoOverviewDS[i]-\u003eGetRasterXSize() \u0026\u0026\n                        poDS-\u003eGetRasterYSize() ==\n                        papoOverviewDS[i]-\u003eGetRasterYSize() \u0026\u0026\n                        (poDS-\u003eGetRasterCount() == 1 ||\n                         poDS-\u003eGetRasterCount() == GetRasterCount()))\n                    {\n                        CPLDebug(\n                            \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                            poDS-\u003eGetRasterXSize(), poDS-\u003eGetRasterYSize());\n                        cpl::down_cast\u003cGTiffDataset*\u003e(GDALDataset::FromHandle(\n                            papoOverviewDS[i]))-\u003e\n                            poMaskDS = poDS;\n                        poDS-\u003ebPromoteTo8Bits =\n                            CPLTestBool(\n                                CPLGetConfigOption(\n                                    \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                    \"YES\" ) );\n                        poDS-\u003epoBaseDS = this;\n                        break;\n                    }\n                }\n                if( i == nOverviewCount )\n                {\n                    delete poDS;\n                }\n            }\n        }\n        else if( nSubType == 0 || nSubType == FILETYPE_PAGE )\n        {\n            uint32 nXSize = 0;\n            uint32 nYSize = 0;\n\n            TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, \u0026nXSize );\n            TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, \u0026nYSize );\n\n            if( nXSize \u003e INT_MAX || nYSize \u003e INT_MAX )\n            {\n                CPLDebug(\"GTiff\",\n                         \"Skipping directory with too large image: %u x %u\",\n                         nXSize, nYSize);\n            }\n            else\n            {\n                uint16 nSPP = 0;\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, \u0026nSPP ) )\n                    nSPP = 1;\n\n                CPLString osName, osDesc;\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                            iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                            iDirIndex, iDirIndex,\n                            static_cast\u003cint\u003e(nXSize),\n                            static_cast\u003cint\u003e(nYSize),\n                            nSPP );\n\n                aosSubdatasets.AddString(osName);\n                aosSubdatasets.AddString(osDesc);\n            }\n        }\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n            TIFFSetSubDirectory( hTIFF, nThisDir );\n        *ppoActiveDSRef = nullptr;\n    }\n\n    // Nasty hack. Probably something that should be fixed in libtiff\n    // In case the last directory cycles to the first directory, we have\n    // TIFFCurrentDirOffset(hTIFF) == nDirOffset, but the TIFFReadDirectory()\n    // hasn't done its job, so SetDirectory() would be confused and think it\n    // has nothing to do. To avoid that reset to a fake offset before calling\n    // SetDirectory()\n    // This can also occur if the last directory cycles to the IFD of the\n    // mask dataset and we activate this mask dataset.\n    // So always completely reset\n    TIFFSetSubDirectory( hTIFF, 0 );\n    *ppoActiveDSRef = nullptr;\n    CPL_IGNORE_RET_VAL( SetDirectory() );\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( poMaskDS != nullptr )\n    {\n        for( int i = 0; i \u003c nOverviewCount; ++i )\n        {\n            if( cpl::down_cast\u003cGTiffDataset *\u003e(GDALDataset::FromHandle(\n                   papoOverviewDS[i]))-\u003epoMaskDS != nullptr)\n            {\n                ++poMaskDS-\u003enOverviewCount;\n                poMaskDS-\u003epapoOverviewDS = static_cast\u003cGTiffDataset **\u003e(\n                    CPLRealloc(poMaskDS-\u003epapoOverviewDS,\n                               poMaskDS-\u003enOverviewCount * (sizeof(void*))) );\n                poMaskDS-\u003epapoOverviewDS[poMaskDS-\u003enOverviewCount-1] =\n                    cpl::down_cast\u003cGTiffDataset*\u003e(GDALDataset::FromHandle(\n                        papoOverviewDS[i]))-\u003epoMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() \u003e 2 )\n    {\n        oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}\n\nstatic int GTiffGetLZMAPreset(char** papszOptions)\n{\n    int nLZMAPreset = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"LZMA_PRESET\" );\n    if( pszValue != nullptr )\n    {\n        nLZMAPreset = atoi( pszValue );\n        if( !(nLZMAPreset \u003e= 0 \u0026\u0026 nLZMAPreset \u003c= 9) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"LZMA_PRESET=%s value not recognised, ignoring.\",\n                      pszValue );\n            nLZMAPreset = -1;\n        }\n    }\n    return nLZMAPreset;\n}\n\nstatic int GTiffGetZSTDPreset(char** papszOptions)\n{\n    int nZSTDLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZSTD_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZSTDLevel = atoi( pszValue );\n        if( !(nZSTDLevel \u003e= 1 \u0026\u0026 nZSTDLevel \u003c= 22) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZSTD_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZSTDLevel = -1;\n        }\n    }\n    return nZSTDLevel;\n}\n\n#if HAVE_LERC\nstatic double GTiffGetLERCMaxZError(char** papszOptions)\n{\n    return CPLAtof(CSLFetchNameValueDef( papszOptions, \"MAX_Z_ERROR\", \"0.0\") );\n}\n#endif\n\nstatic int GTiffGetWebPLevel(char** papszOptions)\n{\n    int nWebPLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"WEBP_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nWebPLevel = atoi( pszValue );\n        if( !(nWebPLevel \u003e= 1 \u0026\u0026 nWebPLevel \u003c= 100) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"WEBP_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nWebPLevel = -1;\n        }\n    }\n    return nWebPLevel;\n}\n\nstatic bool GTiffGetWebPLossless(char** papszOptions)\n{\n    return CPLFetchBool( papszOptions, \"WEBP_LOSSLESS\", false);\n}\n\nstatic int GTiffGetZLevel(char** papszOptions)\n{\n    int nZLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZLEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZLevel = atoi( pszValue );\n        if( nZLevel \u003c 1 || nZLevel \u003e 9 )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZLEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZLevel = -1;\n        }\n    }\n    return nZLevel;\n}\n\nstatic int GTiffGetJpegQuality(char** papszOptions)\n{\n    int nJpegQuality = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"JPEG_QUALITY\" );\n    if( pszValue != nullptr )\n    {\n        nJpegQuality = atoi( pszValue );\n        if( nJpegQuality \u003c 1 || nJpegQuality \u003e 100 )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"JPEG_QUALITY=%s value not recognised, ignoring.\",\n                      pszValue );\n            nJpegQuality = -1;\n        }\n    }\n    return nJpegQuality;\n}\n\nstatic int GTiffGetJpegTablesMode(char** papszOptions)\n{\n    return atoi(CSLFetchNameValueDef( papszOptions, \"JPEGTABLESMODE\",\n                                      CPLSPrintf(\"%d\",\n                                                knGTIFFJpegTablesModeDefault)));\n}\n\n/************************************************************************/\n/*                        GetDiscardLsbOption()                         */\n/************************************************************************/\n\nvoid GTiffDataset::GetDiscardLsbOption(char** papszOptions)\n{\n    const char* pszBits = CSLFetchNameValue( papszOptions, \"DISCARD_LSB\" );\n    if( pszBits == nullptr)\n        return;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on a paletted image\");\n        return;\n    }\n    if( !(nBitsPerSample == 8 || nBitsPerSample == 16 || nBitsPerSample == 32) )\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on non 8, 16 or 32 bits integer images\");\n        return;\n    }\n\n    char** papszTokens = CSLTokenizeString2( pszBits, \",\", 0 );\n    if( CSLCount(papszTokens) == 1 )\n    {\n        bHasDiscardedLsb = true;\n        for( int i = 0; i \u003c nBands; ++i )\n        {\n            int nBits = atoi(papszTokens[0]);\n            anMaskLsb.push_back(~((1 \u003c\u003c nBits)-1));\n            if( nBits \u003e 1 )\n                anOffsetLsb.push_back(1 \u003c\u003c (nBits - 1));\n            else\n                anOffsetLsb.push_back(0);\n        }\n    }\n    else if( CSLCount(papszTokens) == nBands )\n    {\n        bHasDiscardedLsb = true;\n        for( int i = 0; i \u003c nBands; ++i )\n        {\n            int nBits = atoi(papszTokens[i]);\n            anMaskLsb.push_back(~((1 \u003c\u003c nBits)-1));\n            if( nBits \u003e 1 )\n                anOffsetLsb.push_back(1 \u003c\u003c (nBits - 1));\n            else\n                anOffsetLsb.push_back(0);\n        }\n    }\n    else\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored: wrong number of components\");\n    }\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                            GTiffCreate()                             */\n/*                                                                      */\n/*      Shared functionality between GTiffDataset::Create() and         */\n/*      GTiffCreateCopy() for creating TIFF file based on a set of      */\n/*      options and a configuration.                                    */\n/************************************************************************/\n\nTIFF *GTiffDataset::CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int l_nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString\u0026 l_osTmpFilename )\n\n{\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Blow on a few errors.                                           */\n/* -------------------------------------------------------------------- */\n    if( nXSize \u003c 1 || nYSize \u003c 1 || l_nBands \u003c 1 )\n    {\n        CPLError(\n            CE_Failure, CPLE_AppDefined,\n            \"Attempt to create %dx%dx%d TIFF file, but width, height and bands\"\n            \"must be positive.\",\n            nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n    if( l_nBands \u003e 65535 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Attempt to create %dx%dx%d TIFF file, but bands \"\n                  \"must be lesser or equal to 65535.\",\n                  nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Setup values based on options.                                  */\n/* -------------------------------------------------------------------- */\n    const char *pszProfile = CSLFetchNameValue(papszParmList, \"PROFILE\");\n    if( pszProfile == nullptr )\n        pszProfile = szPROFILE_GDALGeoTIFF;\n\n    const bool bTiled = CPLFetchBool( papszParmList, \"TILED\", false );\n\n    int l_nBlockXSize = 0;\n    const char *pszValue = CSLFetchNameValue(papszParmList, \"BLOCKXSIZE\");\n    if( pszValue != nullptr )\n        l_nBlockXSize = atoi( pszValue );\n\n    int l_nBlockYSize = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"BLOCKYSIZE\");\n    if( pszValue != nullptr )\n        l_nBlockYSize = atoi( pszValue );\n\n    int nPlanar = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"INTERLEAVE\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"PIXEL\" ) )\n            nPlanar = PLANARCONFIG_CONTIG;\n        else if( EQUAL( pszValue, \"BAND\" ) )\n        {\n            nPlanar = PLANARCONFIG_SEPARATE;\n        }\n        else\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"INTERLEAVE=%s unsupported, value must be PIXEL or BAND.\",\n                      pszValue );\n            return nullptr;\n        }\n    }\n    else\n    {\n        nPlanar = PLANARCONFIG_CONTIG;\n    }\n\n    int l_nCompression = COMPRESSION_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"COMPRESS\" );\n    if( pszValue != nullptr )\n    {\n        l_nCompression = GTIFFGetCompressionMethod(pszValue, \"COMPRESS\");\n        if( l_nCompression \u003c 0 )\n            return nullptr;\n    }\n\n    int nPredictor = PREDICTOR_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"PREDICTOR\" );\n    if( pszValue != nullptr )\n        nPredictor = atoi( pszValue );\n\n    const int l_nZLevel = GTiffGetZLevel(papszParmList);\n    const int l_nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    const int l_nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    const int l_nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    const bool l_bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    const int l_nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    const int l_nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    const double l_dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Streaming related code                                          */\n/* -------------------------------------------------------------------- */\n    const CPLString osOriFilename(pszFilename);\n    bool bStreaming =\n        strcmp(pszFilename, \"/vsistdout/\") == 0 ||\n        CPLFetchBool(papszParmList, \"STREAMABLE_OUTPUT\", false);\n#ifdef S_ISFIFO\n    if( !bStreaming )\n    {\n        VSIStatBufL sStat;\n        if( VSIStatExL( pszFilename, \u0026sStat,\n                        VSI_STAT_EXISTS_FLAG | VSI_STAT_NATURE_FLAG) == 0 \u0026\u0026\n             S_ISFIFO(sStat.st_mode) )\n        {\n            bStreaming = true;\n        }\n    }\n#endif\n    if( bStreaming \u0026\u0026\n        !EQUAL( \"NONE\",\n                CSLFetchNameValueDef(papszParmList, \"COMPRESS\", \"NONE\")) )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Streaming only supported to uncompressed TIFF\" );\n        return nullptr;\n    }\n    if( bStreaming \u0026\u0026 CPLFetchBool(papszParmList, \"SPARSE_OK\", false) )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with SPARSE_OK\" );\n        return nullptr;\n    }\n    if( bStreaming \u0026\u0026 CPLFetchBool(papszParmList, \"COPY_SRC_OVERVIEWS\", false) )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with COPY_SRC_OVERVIEWS\" );\n        return nullptr;\n    }\n    if( bStreaming )\n    {\n        static int nCounter = 0;\n        l_osTmpFilename = CPLSPrintf(\"/vsimem/vsistdout_%d.tif\", ++nCounter);\n        pszFilename = l_osTmpFilename.c_str();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Compute the uncompressed size.                                  */\n/* -------------------------------------------------------------------- */\n    const double dfUncompressedImageSize =\n        nXSize * static_cast\u003cdouble\u003e(nYSize) * l_nBands *\n        GDALGetDataTypeSizeBytes(eType)\n        + dfExtraSpaceForOverviews;\n\n    if( l_nCompression == COMPRESSION_NONE\n        \u0026\u0026 dfUncompressedImageSize \u003e 4200000000.0 )\n    {\n#ifndef BIGTIFF_SUPPORT\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"A %d pixels x %d lines x %d bands %s image would be larger than \"\n            \"4GB but this is the largest size a TIFF can be, and BigTIFF \"\n            \"is unavailable.  Creation failed.\",\n            nXSize, nYSize, l_nBands, GDALGetDataTypeName(eType) );\n        return nullptr;\n#endif\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check free space (only for big, non sparse, uncompressed)       */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_NONE \u0026\u0026\n        dfUncompressedImageSize \u003e= 1e9 \u0026\u0026\n        !CPLFetchBool(papszParmList, \"SPARSE_OK\", false) \u0026\u0026\n        osOriFilename != \"/vsistdout/\" \u0026\u0026\n        osOriFilename != \"/vsistdout_redirect/\" \u0026\u0026\n        CPLTestBool(CPLGetConfigOption(\"CHECK_DISK_FREE_SPACE\", \"TRUE\")) )\n    {\n        GIntBig nFreeDiskSpace =\n            VSIGetDiskFreeSpace(CPLGetDirname(pszFilename));\n        if( nFreeDiskSpace \u003e= 0 \u0026\u0026\n            nFreeDiskSpace \u003c dfUncompressedImageSize )\n        {\n            CPLError( CE_Failure, CPLE_FileIO,\n                      \"Free disk space available is \" CPL_FRMT_GIB \" bytes, \"\n                      \"whereas \" CPL_FRMT_GIB \" are at least necessary. \"\n                      \"You can disable this check by defining the \"\n                      \"CHECK_DISK_FREE_SPACE configuration option to FALSE.\",\n                      nFreeDiskSpace,\n                      static_cast\u003cGIntBig\u003e(dfUncompressedImageSize) );\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should the file be created as a bigtiff file?                   */\n/* -------------------------------------------------------------------- */\n    const char *pszBIGTIFF = CSLFetchNameValue(papszParmList, \"BIGTIFF\");\n\n    if( pszBIGTIFF == nullptr )\n        pszBIGTIFF = \"IF_NEEDED\";\n\n    bool bCreateBigTIFF = false;\n    if( EQUAL(pszBIGTIFF, \"IF_NEEDED\") )\n    {\n        if( l_nCompression == COMPRESSION_NONE\n            \u0026\u0026 dfUncompressedImageSize \u003e 4200000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else if( EQUAL(pszBIGTIFF, \"IF_SAFER\") )\n    {\n        if( dfUncompressedImageSize \u003e 2000000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else\n    {\n        bCreateBigTIFF = CPLTestBool( pszBIGTIFF );\n        if( !bCreateBigTIFF \u0026\u0026 l_nCompression == COMPRESSION_NONE \u0026\u0026\n             dfUncompressedImageSize \u003e 4200000000.0 )\n        {\n            CPLError(\n                CE_Failure, CPLE_NotSupported,\n                \"The TIFF file will be larger than 4GB, so BigTIFF is \"\n                \"necessary.  Creation failed.\");\n            return nullptr;\n        }\n    }\n\n#ifndef BIGTIFF_SUPPORT\n    if( bCreateBigTIFF )\n    {\n        CPLError( CE_Warning, CPLE_NotSupported,\n                  \"BigTIFF requested, but GDAL built without BigTIFF \"\n                  \"enabled libtiff, request ignored.\" );\n        bCreateBigTIFF = false;\n    }\n#endif\n\n    if( bCreateBigTIFF )\n        CPLDebug( \"GTiff\", \"File being created as a BigTIFF.\" );\n\n/* -------------------------------------------------------------------- */\n/*      Check if the user wishes a particular endianness                */\n/* -------------------------------------------------------------------- */\n\n    int eEndianness = ENDIANNESS_NATIVE;\n    pszValue = CSLFetchNameValue(papszParmList, \"ENDIANNESS\");\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption( \"GDAL_TIFF_ENDIANNESS\", nullptr );\n    if( pszValue != nullptr )\n    {\n        if( EQUAL(pszValue, \"LITTLE\") )\n        {\n            eEndianness = ENDIANNESS_LITTLE;\n        }\n        else if( EQUAL(pszValue, \"BIG\") )\n        {\n            eEndianness = ENDIANNESS_BIG;\n        }\n        else if( EQUAL(pszValue, \"INVERTED\") )\n        {\n#ifdef CPL_LSB\n            eEndianness = ENDIANNESS_BIG;\n#else\n            eEndianness = ENDIANNESS_LITTLE;\n#endif\n        }\n        else if( !EQUAL(pszValue, \"NATIVE\") )\n        {\n            CPLError(\n                CE_Warning, CPLE_NotSupported,\n                \"ENDIANNESS=%s not supported. Defaulting to NATIVE\", pszValue );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n\n    char szOpeningFlag[5] = {};\n    strcpy(szOpeningFlag, \"w+\");\n    if( bCreateBigTIFF )\n        strcat(szOpeningFlag, \"8\");\n    if( eEndianness == ENDIANNESS_BIG )\n        strcat(szOpeningFlag, \"b\");\n    else if( eEndianness == ENDIANNESS_LITTLE )\n        strcat(szOpeningFlag, \"l\");\n\n    VSILFILE* l_fpL = VSIFOpenL( pszFilename, \"w+b\" );\n    if( l_fpL == nullptr )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"Attempt to create new tiff file `%s' failed: %s\",\n                  pszFilename, VSIStrerror(errno) );\n        return nullptr;\n    }\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, szOpeningFlag, l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        if( CPLGetLastErrorNo() == 0 )\n            CPLError( CE_Failure, CPLE_OpenFailed,\n                      \"Attempt to create new tiff file `%s' \"\n                      \"failed in XTIFFOpen().\",\n                      pszFilename );\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      How many bits per sample?  We have a special case if NBITS      */\n/*      specified for GDT_Byte, GDT_UInt16, GDT_UInt32.                 */\n/* -------------------------------------------------------------------- */\n    int l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n    if( CSLFetchNameValue(papszParmList, \"NBITS\") != nullptr )\n    {\n        int nMinBits = 0;\n        int nMaxBits = 0;\n        l_nBitsPerSample = atoi(CSLFetchNameValue(papszParmList, \"NBITS\"));\n        if( eType == GDT_Byte )\n        {\n            nMinBits = 1;\n            nMaxBits = 8;\n        }\n        else if( eType == GDT_UInt16 )\n        {\n            nMinBits = 9;\n            nMaxBits = 16;\n        }\n        else if( eType == GDT_UInt32 )\n        {\n            nMinBits = 17;\n            nMaxBits = 32;\n        }\n        else if( eType == GDT_Float32 )\n        {\n            if( l_nBitsPerSample != 16 \u0026\u0026 l_nBitsPerSample != 32 )\n            {\n                CPLError(CE_Warning, CPLE_NotSupported,\n                     \"NBITS is not supported for data type %s\",\n                     GDALGetDataTypeName(eType));\n                l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n            }\n        }\n        else\n        {\n            CPLError(CE_Warning, CPLE_NotSupported,\n                     \"NBITS is not supported for data type %s\",\n                     GDALGetDataTypeName(eType));\n            l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n        }\n\n        if( nMinBits != 0 )\n        {\n            if( l_nBitsPerSample \u003c nMinBits )\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMinBits);\n                l_nBitsPerSample = nMinBits;\n            }\n            else if( l_nBitsPerSample \u003e nMaxBits )\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMaxBits);\n                l_nBitsPerSample = nMaxBits;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a custom pixel type (just used for signed byte now). */\n/* -------------------------------------------------------------------- */\n    const char *pszPixelType = CSLFetchNameValue( papszParmList, \"PIXELTYPE\" );\n    if( pszPixelType == nullptr )\n        pszPixelType = \"\";\n\n/* -------------------------------------------------------------------- */\n/*      Setup some standard flags.                                      */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, l_nBitsPerSample );\n\n    uint16 l_nSampleFormat = 0;\n    if( (eType == GDT_Byte \u0026\u0026 EQUAL(pszPixelType,\"SIGNEDBYTE\"))\n        || eType == GDT_Int16 || eType == GDT_Int32 )\n        l_nSampleFormat = SAMPLEFORMAT_INT;\n    else if( eType == GDT_CInt16 || eType == GDT_CInt32 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXINT;\n    else if( eType == GDT_Float32 || eType == GDT_Float64 )\n        l_nSampleFormat = SAMPLEFORMAT_IEEEFP;\n    else if( eType == GDT_CFloat32 || eType == GDT_CFloat64 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXIEEEFP;\n    else\n        l_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, l_nSampleFormat );\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLESPERPIXEL, l_nBands );\n    TIFFSetField( l_hTIFF, TIFFTAG_PLANARCONFIG, nPlanar );\n\n/* -------------------------------------------------------------------- */\n/*      Setup Photometric Interpretation. Take this value from the user */\n/*      passed option or guess correct value otherwise.                 */\n/* -------------------------------------------------------------------- */\n    int nSamplesAccountedFor = 1;\n    bool bForceColorTable = false;\n\n    pszValue = CSLFetchNameValue(papszParmList,\"PHOTOMETRIC\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"MINISBLACK\" ) )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISBLACK );\n        else if( EQUAL( pszValue, \"MINISWHITE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISWHITE );\n        }\n        else if( EQUAL( pszValue, \"PALETTE\" ))\n        {\n            if( eType == GDT_Byte || eType == GDT_UInt16 )\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                              PHOTOMETRIC_PALETTE );\n                nSamplesAccountedFor = 1;\n                bForceColorTable = true;\n            }\n            else\n            {\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"PHOTOMETRIC=PALETTE only compatible with Byte or UInt16\" );\n            }\n        }\n        else if( EQUAL( pszValue, \"RGB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"CMYK\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED );\n            nSamplesAccountedFor = 4;\n        }\n        else if( EQUAL( pszValue, \"YCBCR\" ))\n        {\n            // Because of subsampling, setting YCBCR without JPEG compression\n            // leads to a crash currently. Would need to make\n            // GTiffRasterBand::IWriteBlock() aware of subsampling so that it\n            // doesn't overrun buffer size returned by libtiff.\n            if( l_nCompression != COMPRESSION_JPEG )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Currently, PHOTOMETRIC=YCBCR requires COMPRESS=JPEG\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            if( nPlanar == PLANARCONFIG_SEPARATE )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"PHOTOMETRIC=YCBCR requires INTERLEAVE=PIXEL\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            // YCBCR strictly requires 3 bands. Not less, not more Issue an\n            // explicit error message as libtiff one is a bit cryptic:\n            // TIFFVStripSize64:Invalid td_samplesperpixel value.\n            if( l_nBands != 3 )\n            {\n                CPLError(\n                    CE_Failure, CPLE_NotSupported,\n                    \"PHOTOMETRIC=YCBCR not supported on a %d-band raster: \"\n                    \"only compatible of a 3-band (RGB) raster\", l_nBands );\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR );\n            nSamplesAccountedFor = 3;\n\n            // Explicitly register the subsampling so that JPEGFixupTags\n            // is a no-op (helps for cloud optimized geotiffs)\n            TIFFSetField( l_hTIFF, TIFFTAG_YCBCRSUBSAMPLING, 2, 2 );\n        }\n        else if( EQUAL( pszValue, \"CIELAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ICCLAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ITULAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ITULAB );\n            nSamplesAccountedFor = 3;\n        }\n        else\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value not recognised, ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n\n        if( l_nBands \u003c nSamplesAccountedFor )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value does not correspond to number \"\n                      \"of bands (%d), ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue, l_nBands );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n    }\n    else\n    {\n        // If image contains 3 or 4 bands and datatype is Byte then we will\n        // assume it is RGB. In all other cases assume it is MINISBLACK.\n        if( l_nBands == 3 \u0026\u0026 eType == GDT_Byte )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( l_nBands == 4 \u0026\u0026 eType == GDT_Byte )\n        {\n            uint16 v[1] = {\n                GTiffGetAlphaValue(CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   DEFAULT_ALPHA_TYPE)\n            };\n\n            TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 4;\n        }\n        else\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            nSamplesAccountedFor = 1;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there are extra samples, we need to mark them with an        */\n/*      appropriate extrasamples definition here.                       */\n/* -------------------------------------------------------------------- */\n    if( l_nBands \u003e nSamplesAccountedFor )\n    {\n        const int nExtraSamples = l_nBands - nSamplesAccountedFor;\n\n        uint16 *v = static_cast\u003cuint16 *\u003e(\n            CPLMalloc( sizeof(uint16) * nExtraSamples ) );\n\n        v[0] = GTiffGetAlphaValue( CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   EXTRASAMPLE_UNSPECIFIED );\n\n        for( int i = 1; i \u003c nExtraSamples; ++i )\n            v[i] = EXTRASAMPLE_UNSPECIFIED;\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples, v );\n\n        CPLFree(v);\n    }\n\n    // Set the ICC color profile.\n    if( !EQUAL(pszProfile,szPROFILE_BASELINE) )\n    {\n        SaveICCProfile(nullptr, l_hTIFF, papszParmList, l_nBitsPerSample);\n    }\n\n    // Set the compression method before asking the default strip size\n    // This is useful when translating to a JPEG-In-TIFF file where\n    // the default strip size is 8 or 16 depending on the photometric value.\n    TIFFSetField( l_hTIFF, TIFFTAG_COMPRESSION, l_nCompression );\n\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        const char* pszCompress =\n            CSLFetchNameValueDef( papszParmList, \"COMPRESS\", \"\" );\n        if( EQUAL(pszCompress , \"LERC_DEFLATE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                        LERC_ADD_COMPRESSION_DEFLATE );\n        }\n        else if( EQUAL(pszCompress, \"LERC_ZSTD\" ) )\n        {\n            if( TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                            LERC_ADD_COMPRESSION_ZSTD ) != 1 )\n            {\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n        }\n    }\n    // TODO later: take into account LERC version\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Setup tiling/stripping flags.                                   */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n    {\n        if( l_nBlockXSize == 0 )\n            l_nBlockXSize = 256;\n\n        if( l_nBlockYSize == 0 )\n            l_nBlockYSize = 256;\n\n        if( !TIFFSetField( l_hTIFF, TIFFTAG_TILEWIDTH, l_nBlockXSize ) ||\n            !TIFFSetField( l_hTIFF, TIFFTAG_TILELENGTH, l_nBlockYSize ) )\n        {\n            XTIFFClose(l_hTIFF);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n            return nullptr;\n        }\n    }\n    else\n    {\n        const uint32 l_nRowsPerStrip = std::min(nYSize,\n            l_nBlockYSize == 0\n            ? static_cast\u003cint\u003e(TIFFDefaultStripSize(l_hTIFF,0))\n            : l_nBlockYSize );\n\n        TIFFSetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP, l_nRowsPerStrip );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Set compression related tags.                                   */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_LZW ||\n         l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n         l_nCompression == COMPRESSION_ZSTD )\n        TIFFSetField( l_hTIFF, TIFFTAG_PREDICTOR, nPredictor );\n    if( (l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n         l_nCompression == COMPRESSION_LERC) \u0026\u0026 l_nZLevel != -1 )\n        TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, l_nZLevel );\n    if( l_nCompression == COMPRESSION_JPEG \u0026\u0026 l_nJpegQuality != -1 )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, l_nJpegQuality );\n    if( l_nCompression == COMPRESSION_LZMA \u0026\u0026 l_nLZMAPreset != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, l_nLZMAPreset );\n    if( (l_nCompression == COMPRESSION_ZSTD ||\n         l_nCompression == COMPRESSION_LERC) \u0026\u0026 l_nZSTDLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, l_nZSTDLevel);\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, l_dfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP \u0026\u0026 l_nWebPLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, l_nWebPLevel);\n    if( l_nCompression == COMPRESSION_WEBP \u0026\u0026 l_bWebPLossless)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n\n    if( l_nCompression == COMPRESSION_JPEG )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, l_nJpegTablesMode );\n\n/* -------------------------------------------------------------------- */\n/*      If we forced production of a file with photometric=palette,     */\n/*      we need to push out a default color table.                      */\n/* -------------------------------------------------------------------- */\n    if( bForceColorTable )\n    {\n        const int nColors = eType == GDT_Byte ? 256 : 65536;\n\n        unsigned short *panTRed = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTGreen = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTBlue = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n\n        for( int iColor = 0; iColor \u003c nColors; ++iColor )\n        {\n            if( eType == GDT_Byte )\n            {\n                panTRed[iColor] = static_cast\u003cunsigned short\u003e(257 * iColor);\n                panTGreen[iColor] = static_cast\u003cunsigned short\u003e(257 * iColor);\n                panTBlue[iColor] = static_cast\u003cunsigned short\u003e(257 * iColor);\n            }\n            else\n            {\n                panTRed[iColor] = static_cast\u003cunsigned short\u003e(iColor);\n                panTGreen[iColor] = static_cast\u003cunsigned short\u003e(iColor);\n                panTBlue[iColor] = static_cast\u003cunsigned short\u003e(iColor);\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP,\n                      panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n\n    // Would perhaps works with libtiff 3.X but didn't bother trying This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n#if defined(BIGTIFF_SUPPORT)\n    if( l_nCompression == COMPRESSION_JPEG \u0026\u0026\n        !STARTS_WITH(pszFilename, szJPEGGTiffDatasetTmpPrefix) \u0026\u0026\n        CPLTestBool(\n            CSLFetchNameValueDef(papszParmList, \"WRITE_JPEGTABLE_TAG\", \"YES\")) )\n    {\n        GTiffWriteJPEGTables( l_hTIFF,\n                              CSLFetchNameValue(papszParmList, \"PHOTOMETRIC\"),\n                              CSLFetchNameValue(papszParmList, \"JPEG_QUALITY\"),\n                              CSLFetchNameValue(papszParmList,\n                                                \"JPEGTABLESMODE\") );\n    }\n#endif\n\n    *pfpL = l_fpL;\n\n    return l_hTIFF;\n}\n\n/************************************************************************/\n/*                      GTiffWriteJPEGTables()                          */\n/*                                                                      */\n/*      Sets the TIFFTAG_JPEGTABLES (and TIFFTAG_REFERENCEBLACKWHITE)   */\n/*      tags immediately, instead of relying on the TIFF JPEG codec     */\n/*      to write them when it starts compressing imagery. This avoids   */\n/*      an IFD rewrite at the end of the file.                          */\n/*      Must be used after having set TIFFTAG_SAMPLESPERPIXEL,          */\n/*      TIFFTAG_BITSPERSAMPLE.                                          */\n/************************************************************************/\n\nvoid GTiffWriteJPEGTables( TIFF* hTIFF,\n                           const char* pszPhotometric,\n                           const char* pszJPEGQuality,\n                           const char* pszJPEGTablesMode )\n{\n    // Would perhaps works with libtiff 3.X but didn't bother trying This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n#if defined(BIGTIFF_SUPPORT)\n    uint16 nBands = 0;\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL,\n                        \u0026nBands ) )\n        nBands = 1;\n\n    uint16 l_nBitsPerSample = 0;\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE,\n                        \u0026(l_nBitsPerSample)) )\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE* fpTmp = nullptr;\n    CPLString osTmp;\n    char** papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\" );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEG_QUALITY\",\n                                            pszJPEGQuality );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"PHOTOMETRIC\", pszPhotometric );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"BLOCKYSIZE\",\n                                            CPLSPrintf(\"%u\", nInMemImageHeight)\n                                          );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"NBITS\",\n                                            CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEGTABLESMODE\",\n                                            pszJPEGTablesMode );\n\n    TIFF* hTIFFTmp = GTiffDataset::CreateLL(\n                    osTmpFilenameIn, nInMemImageWidth, nInMemImageHeight,\n                    (nBands \u003c= 4) ? nBands : 1,\n                    (l_nBitsPerSample \u003c= 8) ? GDT_Byte : GDT_UInt16, 0.0,\n                    papszLocalParameters, \u0026fpTmp, osTmp );\n    CSLDestroy(papszLocalParameters);\n    if( hTIFFTmp )\n    {\n        uint16 l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField( hTIFFTmp, TIFFTAG_PHOTOMETRIC, \u0026(l_nPhotometric) );\n        TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                        \u0026nJpegTablesModeIn );\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if(l_nJpegQuality \u003e 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if( l_nPhotometric == PHOTOMETRIC_YCBCR\n            \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGCOLORMODE,\n                            JPEGCOLORMODE_RGB);\n        }\n        if( nJpegTablesModeIn \u003e= 0 )\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                            nJpegTablesModeIn);\n\n        int nBlockSize = nInMemImageWidth * nInMemImageHeight *\n                                        ((nBands \u003c= 4) ? nBands : 1);\n        if( l_nBitsPerSample == 12 )\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector\u003cGByte\u003e abyZeroData( nBlockSize, 0 );\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, \u0026abyZeroData[0], nBlockSize);\n\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLES, \u0026nJPEGTableSize,\n                            \u0026pJPEGTable) )\n            TIFFSetField( hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize,\n                            pJPEGTable);\n\n        float *ref = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, \u0026ref) )\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n#endif\n}\n\n/************************************************************************/\n/*                            GuessJPEGQuality()                        */\n/*                                                                      */\n/*      Guess JPEG quality from JPEGTABLES tag.                         */\n/************************************************************************/\n\nstatic const GByte* GTIFFFindNextTable( const GByte* paby, GByte byMarker,\n                                        int nLen, int* pnLenTable )\n{\n    for( int i = 0; i + 1 \u003c nLen; )\n    {\n        if( paby[i] != 0xFF )\n            return nullptr;\n        ++i;\n        if( paby[i] == 0xD8 )\n        {\n            ++i;\n            continue;\n        }\n        if( i + 2 \u003e= nLen )\n            return nullptr;\n        int nMarkerLen = paby[i+1] * 256 + paby[i+2];\n        if( i+1+nMarkerLen \u003e= nLen )\n            return nullptr;\n        if( paby[i] == byMarker )\n        {\n            if( pnLenTable ) *pnLenTable = nMarkerLen;\n            return paby + i + 1;\n        }\n        i += 1 + nMarkerLen;\n    }\n    return nullptr;\n}\n\n// We assume that if there are several quantization tables, they are\n// in the same order. Which is a reasonable assumption for updating\n// a file generated by ourselves.\nstatic bool GTIFFQuantizationTablesEqual( const GByte* paby1, int nLen1,\n                                          const GByte* paby2, int nLen2 )\n{\n    bool bFound = false;\n    while( true )\n    {\n        int nLenTable1 = 0;\n        int nLenTable2 = 0;\n        const GByte* paby1New =\n            GTIFFFindNextTable(paby1, 0xDB, nLen1, \u0026nLenTable1);\n        const GByte* paby2New =\n            GTIFFFindNextTable(paby2, 0xDB, nLen2, \u0026nLenTable2);\n        if( paby1New == nullptr \u0026\u0026 paby2New == nullptr )\n            return bFound;\n        if( paby1New == nullptr || paby2New == nullptr )\n            return false;\n        if( nLenTable1 != nLenTable2 )\n            return false;\n        if( memcmp(paby1New, paby2New, nLenTable1) != 0 )\n            return false;\n        paby1New += nLenTable1;\n        paby2New += nLenTable2;\n        nLen1 -= static_cast\u003cint\u003e(paby1New - paby1);\n        nLen2 -= static_cast\u003cint\u003e(paby2New - paby2);\n        paby1 = paby1New;\n        paby2 = paby2New;\n        bFound = true;\n    }\n}\n\nint GTiffDataset::GuessJPEGQuality( bool\u0026 bOutHasQuantizationTable,\n                                    bool\u0026 bOutHasHuffmanTable )\n{\n    CPLAssert( nCompression == COMPRESSION_JPEG );\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    if( !TIFFGetField(hTIFF, TIFFTAG_JPEGTABLES, \u0026nJPEGTableSize, \u0026pJPEGTable) )\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable( static_cast\u003cconst GByte*\u003e(pJPEGTable), 0xDB,\n                            nJPEGTableSize, nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable( static_cast\u003cconst GByte*\u003e(pJPEGTable), 0xC4,\n                            nJPEGTableSize, nullptr) != nullptr;\n    if( !bOutHasQuantizationTable )\n        return -1;\n\n    char** papszLocalParameters = nullptr;\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\");\n    if( nPhotometric == PHOTOMETRIC_YCBCR )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"YCBCR\");\n    else if( nPhotometric == PHOTOMETRIC_SEPARATED )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"BLOCKYSIZE\", \"16\");\n    if( nBitsPerSample == 12 )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf( \"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                            this );\n\n    int nRet = -1;\n    for( int nQuality = 0; nQuality \u003c= 100 \u0026\u0026 nRet \u003c 0; ++nQuality )\n    {\n        VSILFILE* fpTmp = nullptr;\n        if( nQuality == 0 )\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                   \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                \"JPEG_QUALITY\", CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF* hTIFFTmp =\n            CreateLL( osTmpFilenameIn, 16, 16, (nBands \u003c= 4) ? nBands : 1,\n                      GetRasterBand(1)-\u003eGetRasterDataType(), 0.0,\n                      papszLocalParameters, \u0026fpTmp, osTmp );\n        CPLPopErrorHandler();\n        if( !hTIFFTmp )\n        {\n            break;\n        }\n\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now reset jpegcolormode.\n        if( nPhotometric == PHOTOMETRIC_YCBCR\n            \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16*16*4*3)/2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands \u003c= 4) ? nBands : 1) * nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32 nJPEGTableSizeTry = 0;\n        void* pJPEGTableTry = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES,\n                         \u0026nJPEGTableSizeTry, \u0026pJPEGTableTry) )\n        {\n            if( GTIFFQuantizationTablesEqual(\n                   static_cast\u003cGByte *\u003e(pJPEGTable), nJPEGTableSize,\n                   static_cast\u003cGByte *\u003e(pJPEGTableTry), nJPEGTableSizeTry) )\n            {\n                nRet = (nQuality == 0 ) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}\n\n/************************************************************************/\n/*               SetJPEGQualityAndTablesModeFromFile()                  */\n/************************************************************************/\n\nvoid GTiffDataset::SetJPEGQualityAndTablesModeFromFile()\n{\n    bool bHasQuantizationTable = false;\n    bool bHasHuffmanTable = false;\n    int nQuality = GuessJPEGQuality( bHasQuantizationTable,\n                                     bHasHuffmanTable );\n    if( nQuality \u003e 0 )\n    {\n        CPLDebug(\"GTiff\", \"Guessed JPEG quality to be %d\", nQuality);\n        nJpegQuality = nQuality;\n        TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, nQuality );\n\n        // This means we will use the quantization tables from the\n        // JpegTables tag.\n        nJpegTablesMode = JPEGTABLESMODE_QUANT;\n    }\n    else\n    {\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( !TIFFGetField( hTIFF, TIFFTAG_JPEGTABLES,\n                            \u0026nJPEGTableSize, \u0026pJPEGTable) )\n        {\n            toff_t *panByteCounts = nullptr;\n            const int nBlockCount =\n                nPlanarConfig == PLANARCONFIG_SEPARATE\n                ? nBlocksPerBand * nBands\n                : nBlocksPerBand;\n            if( TIFFIsTiled( hTIFF ) )\n                TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS,\n                                \u0026panByteCounts );\n            else\n                TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                                \u0026panByteCounts );\n\n            bool bFoundNonEmptyBlock = false;\n            if( panByteCounts != nullptr )\n            {\n                for( int iBlock = 0; iBlock \u003c nBlockCount; ++iBlock )\n                {\n                    if( panByteCounts[iBlock] != 0 )\n                    {\n                        bFoundNonEmptyBlock = true;\n                        break;\n                    }\n                }\n            }\n            if( bFoundNonEmptyBlock )\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality. \"\n                            \"JPEG tables are missing, so going in \"\n                            \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n                // Write quantization tables in each strile.\n                nJpegTablesMode = 0;\n            }\n        }\n        else\n        {\n            if( bHasQuantizationTable )\n            {\n                // FIXME in libtiff: this is likely going to cause issues\n                // since libtiff will reuse in each strile the number of\n                // the global quantization table, which is invalid.\n                CPLDebug(\n                    \"GTiff\", \"Could not guess JPEG quality although JPEG \"\n                    \"quantization tables are present, so going in \"\n                    \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality since JPEG \"\n                        \"quantization tables are not present, so going in \"\n                        \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n            }\n\n            // Write quantization tables in each strile.\n            nJpegTablesMode = 0;\n        }\n    }\n    if( bHasHuffmanTable )\n    {\n        // If there are Huffman tables in header use them, otherwise\n        // if we use optimized tables, libtiff will currently reuse\n        // the number of the Huffman tables of the header for the\n        // optimized version of each strile, which is illegal.\n        nJpegTablesMode |= JPEGTABLESMODE_HUFF;\n    }\n    if( nJpegTablesMode \u003e= 0 )\n        TIFFSetField( hTIFF, TIFFTAG_JPEGTABLESMODE,\n                        nJpegTablesMode);\n}\n\n/************************************************************************/\n/*                               Create()                               */\n/*                                                                      */\n/*      Create a new GeoTIFF or TIFF file.                              */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int l_nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    TIFF *l_hTIFF = CreateLL(\n        pszFilename,\n        nXSize, nYSize, l_nBands,\n        eType, 0, papszParmList, \u0026l_fpL, l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS-\u003ehTIFF = l_hTIFF;\n    poDS-\u003efpL = l_fpL;\n    if( bStreaming )\n    {\n        poDS-\u003ebStreamingOut = true;\n        poDS-\u003eosTmpFilename = l_osTmpFilename;\n        poDS-\u003efpToWrite = VSIFOpenL( pszFilename, \"wb\" );\n        if( poDS-\u003efpToWrite == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            delete poDS;\n            return nullptr;\n        }\n    }\n    poDS-\u003epoActiveDS = poDS;\n    poDS-\u003eppoActiveDSRef = \u0026(poDS-\u003epoActiveDS);\n\n    poDS-\u003enRasterXSize = nXSize;\n    poDS-\u003enRasterYSize = nYSize;\n    poDS-\u003eeAccess = GA_Update;\n    poDS-\u003ebCrystalized = false;\n    poDS-\u003enSamplesPerPixel = static_cast\u003cuint16\u003e(l_nBands);\n    poDS-\u003eosFilename = pszFilename;\n\n    // Don't try to load external metadata files (#6597).\n    poDS-\u003ebIMDRPCMetadataLoaded = true;\n\n    // Avoid premature crystalization that will cause directory re-writing if\n    // GetProjectionRef() or GetGeoTransform() are called on the newly created\n    // GeoTIFF.\n    poDS-\u003ebLookedForProjection = true;\n\n    TIFFGetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, \u0026(poDS-\u003enSampleFormat) );\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, \u0026(poDS-\u003enPlanarConfig) );\n    // Weird that we need this, but otherwise we get a Valgrind warning on\n    // tiff_write_124.\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, \u0026(poDS-\u003enPhotometric) ) )\n        poDS-\u003enPhotometric = PHOTOMETRIC_MINISBLACK;\n    TIFFGetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, \u0026(poDS-\u003enBitsPerSample) );\n    TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, \u0026(poDS-\u003enCompression) );\n\n    if( TIFFIsTiled(l_hTIFF) )\n    {\n        TIFFGetField( l_hTIFF, TIFFTAG_TILEWIDTH, \u0026(poDS-\u003enBlockXSize) );\n        TIFFGetField( l_hTIFF, TIFFTAG_TILELENGTH, \u0026(poDS-\u003enBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           \u0026(poDS-\u003enRowsPerStrip) ) )\n            poDS-\u003enRowsPerStrip = 1;  // Dummy value.\n\n        poDS-\u003enBlockXSize = nXSize;\n        poDS-\u003enBlockYSize =\n            std::min( static_cast\u003cint\u003e(poDS-\u003enRowsPerStrip) , nYSize );\n    }\n\n    poDS-\u003enBlocksPerBand =\n        DIV_ROUND_UP(nYSize, poDS-\u003enBlockYSize)\n        * DIV_ROUND_UP(nXSize, poDS-\u003enBlockXSize);\n\n    if( CSLFetchNameValue( papszParmList, \"PROFILE\" ) != nullptr )\n        poDS-\u003eosProfile = CSLFetchNameValue( papszParmList, \"PROFILE\" );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS-\u003enCompression == COMPRESSION_JPEG\n        \u0026\u0026 poDS-\u003enPhotometric == PHOTOMETRIC_YCBCR\n        \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        int nColorMode = 0;\n\n        poDS-\u003eSetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\");\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, \u0026nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n#ifdef HAVE_LERC\n    if( poDS-\u003enCompression == COMPRESSION_LERC )\n    {\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_LERC_PARAMETERS, \u0026nLercParamCount,\n                          \u0026panLercParms ) \u0026\u0026\n            nLercParamCount == 2 )\n        {\n            memcpy( poDS-\u003eanLercAddCompressionAndVersion, panLercParms,\n                    sizeof(poDS-\u003eanLercAddCompressionAndVersion) );\n        }\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( poDS-\u003enPhotometric == PHOTOMETRIC_PALETTE\n        \u0026\u0026 TIFFGetField( l_hTIFF, TIFFTAG_COLORMAP,\n                         \u0026panRed, \u0026panGreen, \u0026panBlue) )\n    {\n\n        poDS-\u003epoColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 \u003c\u003c poDS-\u003enBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor \u003e= 0; iColor-- )\n        {\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast\u003cshort\u003e(panRed[iColor] / divisor),\n                static_cast\u003cshort\u003e(panGreen[iColor] / divisor),\n                static_cast\u003cshort\u003e(panBlue[iColor] / divisor),\n                static_cast\u003cshort\u003e(255)\n            };\n\n            poDS-\u003epoColorTable-\u003eSetColorEntry( iColor, \u0026oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CPLFetchBool( papszParmList, \"SPARSE_OK\", false ) )\n        poDS-\u003ebFillEmptyTilesAtClosing = true;\n\n    poDS-\u003ebWriteEmptyTiles = bStreaming ||\n        (poDS-\u003enCompression != COMPRESSION_NONE \u0026\u0026\n         poDS-\u003ebFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed stripped files in the\n    // right order and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset.\n    if( CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n         CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n    {\n        poDS-\u003ebWriteEmptyTiles = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS-\u003epapszCreationOptions = CSLDuplicate( papszParmList );\n\n    poDS-\u003enZLevel = GTiffGetZLevel(papszParmList);\n    poDS-\u003enLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    poDS-\u003enZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    poDS-\u003enWebPLevel = GTiffGetWebPLevel(papszParmList);\n    poDS-\u003ebWebPLossless = GTiffGetWebPLossless(papszParmList);\n    poDS-\u003enJpegQuality = GTiffGetJpegQuality(papszParmList);\n    poDS-\u003enJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    poDS-\u003edfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n    poDS-\u003eInitCreationOrOpenOptions(papszParmList);\n\n#if !defined(BIGTIFF_SUPPORT)\n/* -------------------------------------------------------------------- */\n/*      If we are writing jpeg compression we need to write some        */\n/*      imagery to force the jpegtables to get created.  This is,       */\n/*      likely only needed with libtiff \u003e= 3.9.3 (#3633)                */\n/* -------------------------------------------------------------------- */\n    if( poDS-\u003enCompression == COMPRESSION_JPEG\n        \u0026\u0026 strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != nullptr )\n    {\n        CPLDebug( \"GDAL\",\n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( l_hTIFF ) )\n        {\n            const int cc = TIFFTileSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast\u003cunsigned char *\u003e(CPLCalloc(cc, 1));\n            TIFFWriteEncodedTile(l_hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            const int cc = TIFFStripSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast\u003cunsigned char *\u003e(CPLCalloc(cc, 1));\n            TIFFWriteEncodedStrip(l_hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        poDS-\u003ebDontReloadFirstBlock = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand \u003c l_nBands; ++iBand )\n    {\n        if( poDS-\u003enBitsPerSample == 8 ||\n            (poDS-\u003enBitsPerSample == 16 \u0026\u0026 eType != GDT_Float32) ||\n            poDS-\u003enBitsPerSample == 32 ||\n            poDS-\u003enBitsPerSample == 64 ||\n            poDS-\u003enBitsPerSample == 128)\n        {\n            poDS-\u003eSetBand( iBand + 1, new GTiffRasterBand( poDS, iBand + 1 ) );\n        }\n        else\n        {\n            poDS-\u003eSetBand( iBand + 1, new GTiffOddBitsBand( poDS, iBand + 1 ) );\n            poDS-\u003eGetRasterBand( iBand + 1 )-\u003e\n                SetMetadataItem( \"NBITS\",\n                                 CPLString().Printf(\"%d\",poDS-\u003enBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    poDS-\u003eGetDiscardLsbOption(papszParmList);\n\n    if( poDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 l_nBands != 1 )\n        poDS-\u003eSetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        poDS-\u003eSetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    poDS-\u003eoOvManager.Initialize( poDS, pszFilename );\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                             CreateCopy()                             */\n/************************************************************************/\n\nGDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS,\n                          int bStrict, char ** papszOptions,\n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    if( poSrcDS-\u003eGetRasterCount() == 0 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return nullptr;\n    }\n\n    GDALRasterBand * const poPBand = poSrcDS-\u003eGetRasterBand(1);\n    const GDALDataType eType = poPBand-\u003eGetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    const int l_nBands = poSrcDS-\u003eGetRasterCount();\n    for( int iBand = 2; iBand \u003c= l_nBands; ++iBand )\n    {\n        if( eType != poSrcDS-\u003eGetRasterBand(iBand)-\u003eGetRasterDataType() )\n        {\n            if( bStrict )\n            {\n                CPLError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n                return nullptr;\n            }\n            else\n            {\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const char *pszProfile = CSLFetchNameValue(papszOptions, \"PROFILE\");\n    if( pszProfile == nullptr )\n        pszProfile = szPROFILE_GDALGeoTIFF;\n\n    if( !EQUAL(pszProfile, szPROFILE_BASELINE)\n        \u0026\u0026 !EQUAL(pszProfile, szPROFILE_GeoTIFF)\n        \u0026\u0026 !EQUAL(pszProfile, szPROFILE_GDALGeoTIFF) )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"PROFILE=%s not supported in GTIFF driver.\",\n                  pszProfile );\n        return nullptr;\n    }\n\n    const bool bGeoTIFF = !EQUAL(pszProfile, szPROFILE_BASELINE);\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand-\u003eGetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != nullptr\n        \u0026\u0026 atoi(poPBand-\u003eGetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) \u003e 0\n        \u0026\u0026 CSLFetchNameValue( papszCreateOptions, \"NBITS\") == nullptr )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand-\u003eGetMetadataItem( \"NBITS\",\n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == nullptr\n        \u0026\u0026 eType == GDT_Byte\n        \u0026\u0026 poPBand-\u003eGetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\",\n                             poPBand-\u003eGetMetadataItem(\n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Color profile.  Copy from band metadata if found.              */\n/* -------------------------------------------------------------------- */\n    if( bGeoTIFF )\n    {\n        const char* pszOptionsMD[] = {\n            \"SOURCE_ICC_PROFILE\",\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\",\n            \"SOURCE_WHITEPOINT\",\n            \"TIFFTAG_TRANSFERFUNCTION_RED\",\n            \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n            \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\",\n            nullptr\n        };\n\n        // Copy all the tags.  Options will override tags in the source.\n        int i = 0;\n        while(pszOptionsMD[i] != nullptr)\n        {\n            char const *pszMD =\n                CSLFetchNameValue(papszOptions, pszOptionsMD[i]);\n            if( pszMD == nullptr )\n                pszMD = poSrcDS-\u003eGetMetadataItem( pszOptionsMD[i],\n                                                  \"COLOR_PROFILE\" );\n\n            if( (pszMD != nullptr) \u0026\u0026 !EQUAL(pszMD, \"\") )\n            {\n                papszCreateOptions =\n                    CSLSetNameValue( papszCreateOptions, pszOptionsMD[i],\n                                     pszMD );\n\n                // If an ICC profile exists, other tags are not needed.\n                if( EQUAL(pszOptionsMD[i], \"SOURCE_ICC_PROFILE\") )\n                    break;\n            }\n\n            ++i;\n        }\n    }\n\n    double dfExtraSpaceForOverviews = 0;\n    if( CPLFetchBool(papszOptions, \"COPY_SRC_OVERVIEWS\", false) )\n    {\n        const int nSrcOverviews = poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverviewCount();\n        if( nSrcOverviews )\n        {\n            for( int j = 1; j \u003c= l_nBands; ++j )\n            {\n                if( poSrcDS-\u003eGetRasterBand(j)-\u003eGetOverviewCount() !=\n                                                        nSrcOverviews )\n                {\n                    CPLError(\n                        CE_Failure, CPLE_NotSupported,\n                        \"COPY_SRC_OVERVIEWS cannot be used when the bands have \"\n                        \"not the same number of overview levels.\" );\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                for( int i = 0; i \u003c nSrcOverviews; ++i )\n                {\n                    GDALRasterBand* poOvrBand =\n                        poSrcDS-\u003eGetRasterBand(j)-\u003eGetOverview(i);\n                    if( poOvrBand == nullptr )\n                    {\n                        CPLError(\n                            CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when one \"\n                            \"overview band is NULL.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                    GDALRasterBand* poOvrFirstBand =\n                        poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(i);\n                    if( poOvrBand-\u003eGetXSize() != poOvrFirstBand-\u003eGetXSize() ||\n                        poOvrBand-\u003eGetYSize() != poOvrFirstBand-\u003eGetYSize() )\n                    {\n                        CPLError(\n                            CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when the \"\n                            \"overview bands have not the same dimensions \"\n                            \"among bands.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                }\n            }\n\n            for( int i = 0; i \u003c nSrcOverviews; ++i )\n            {\n                dfExtraSpaceForOverviews +=\n                    static_cast\u003cdouble\u003e(\n                      poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(i)-\u003eGetXSize() ) *\n                      poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(i)-\u003eGetYSize();\n            }\n            dfExtraSpaceForOverviews *=\n                                l_nBands * GDALGetDataTypeSizeBytes(eType);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we use optimized way of copying from an input JPEG       */\n/*      dataset?                                                        */\n/* -------------------------------------------------------------------- */\n\n// TODO(schwehr): Refactor bDirectCopyFromJPEG to be a const.\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bDirectCopyFromJPEG = false;\n#endif\n\n    // Note: JPEG_DIRECT_COPY is not defined by default, because it is mainly\n    // useful for debugging purposes.\n#ifdef JPEG_DIRECT_COPY\n    if( CPLFetchBool(papszCreateOptions, \"JPEG_DIRECT_COPY\", false) \u0026\u0026\n        GTIFF_CanDirectCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug(\"GTiff\", \"Using special direct copy mode from a JPEG dataset\");\n\n        bDirectCopyFromJPEG = true;\n    }\n#endif\n\n#ifdef HAVE_LIBJPEG\n    bool bCopyFromJPEG = false;\n\n    // When CreateCopy'ing() from a JPEG dataset, and asking for COMPRESS=JPEG,\n    // use DCT coefficients (unless other options are incompatible, like\n    // strip/tile dimensions, specifying JPEG_QUALITY option, incompatible\n    // PHOTOMETRIC with the source colorspace, etc.) to avoid the lossy steps\n    // involved by decompression/recompression.\n    if( !bDirectCopyFromJPEG \u0026\u0026\n        GTIFF_CanCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug( \"GTiff\", \"Using special copy mode from a JPEG dataset\" );\n\n        bCopyFromJPEG = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      If the source is RGB, then set the PHOTOMETRIC=RGB value        */\n/* -------------------------------------------------------------------- */\n\n    const bool bForcePhotometric =\n        CSLFetchNameValue(papszOptions, \"PHOTOMETRIC\") != nullptr;\n\n    if( l_nBands \u003e= 3 \u0026\u0026 !bForcePhotometric \u0026\u0026\n#ifdef HAVE_LIBJPEG\n        !bCopyFromJPEG \u0026\u0026\n#endif\n        poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorInterpretation() == GCI_RedBand \u0026\u0026\n        poSrcDS-\u003eGetRasterBand(2)-\u003eGetColorInterpretation() == GCI_GreenBand \u0026\u0026\n        poSrcDS-\u003eGetRasterBand(3)-\u003eGetColorInterpretation() == GCI_BlueBand )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PHOTOMETRIC\", \"RGB\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n    const int nXSize = poSrcDS-\u003eGetRasterXSize();\n    const int nYSize = poSrcDS-\u003eGetRasterYSize();\n    TIFF *l_hTIFF =\n        CreateLL( pszFilename, nXSize, nYSize, l_nBands,\n                  eType, dfExtraSpaceForOverviews, papszCreateOptions, \u0026l_fpL,\n                  l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    CSLDestroy( papszCreateOptions );\n    papszCreateOptions = nullptr;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        return nullptr;\n    }\n\n    uint16 l_nPlanarConfig = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, \u0026l_nPlanarConfig );\n\n    uint16 l_nBitsPerSample = 0;\n    TIFFGetField(l_hTIFF, TIFFTAG_BITSPERSAMPLE, \u0026l_nBitsPerSample );\n\n    uint16 l_nCompression = 0;\n\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, \u0026(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Set the alpha channel if it is the last one.                    */\n/* -------------------------------------------------------------------- */\n    if( poSrcDS-\u003eGetRasterBand(l_nBands)-\u003eGetColorInterpretation() ==\n        GCI_AlphaBand )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, \u0026count, \u0026v ) )\n        {\n            const int nBaseSamples = l_nBands - count;\n            if( l_nBands \u003e nBaseSamples \u0026\u0026 l_nBands - nBaseSamples - 1 \u003c count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast\u003cuint16 *\u003e(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                pasNewExtraSamples[l_nBands - nBaseSamples - 1] =\n                    GTiffGetAlphaValue(\n                        CPLGetConfigOption(\n                            \"GTIFF_ALPHA\",\n                            CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n                        DEFAULT_ALPHA_TYPE);\n\n                TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, count,\n                              pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( l_nBands \u003e= 3\n            \u0026\u0026 (poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorInterpretation()\n                == GCI_YCbCr_YBand)\n            \u0026\u0026 (poSrcDS-\u003eGetRasterBand(2)-\u003eGetColorInterpretation()\n                == GCI_YCbCr_CbBand)\n            \u0026\u0026 (poSrcDS-\u003eGetRasterBand(3)-\u003eGetColorInterpretation()\n                == GCI_YCbCr_CrBand) )\n        {\n            // Do nothing.\n        }\n        else\n        {\n            // Assume RGB if it is not explicitly YCbCr.\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( (l_nBands == 1 || l_nBands == 2) \u0026\u0026\n        poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable() != nullptr\n        \u0026\u0026 eType == GDT_Byte )\n    {\n        unsigned short anTRed[256] = { 0 };\n        unsigned short anTGreen[256] = { 0 };\n        unsigned short anTBlue[256] = { 0 };\n        GDALColorTable *poCT = poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable();\n\n        for( int iColor = 0; iColor \u003c 256; ++iColor )\n        {\n            if( iColor \u003c poCT-\u003eGetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT-\u003eGetColorEntryAsRGB( iColor, \u0026sRGB );\n\n                anTRed[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c1);\n                anTGreen[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c2);\n                anTBlue[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = 0;\n                anTGreen[iColor] = 0;\n                anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( (l_nBands == 1 || l_nBands == 2)\n             \u0026\u0026 poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable() != nullptr\n             \u0026\u0026 eType == GDT_UInt16 )\n    {\n        unsigned short *panTRed = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTGreen = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTBlue = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n\n        GDALColorTable *poCT = poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable();\n\n        for( int iColor = 0; iColor \u003c 65536; ++iColor )\n        {\n            if( iColor \u003c poCT-\u003eGetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT-\u003eGetColorEntryAsRGB( iColor, \u0026sRGB );\n\n                panTRed[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c1);\n                panTGreen[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c2);\n                panTBlue[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = 0;\n                panTGreen[iColor] = 0;\n                panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable() != nullptr )\n        CPLError(\n            CE_Warning, CPLE_AppDefined,\n            \"Unable to export color table to GeoTIFF file.  Color tables \"\n            \"can only be written to 1 band or 2 bands Byte or \"\n            \"UInt16 GeoTIFF files.\" );\n\n    if( l_nBands == 2\n        \u0026\u0026 poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable() != nullptr\n        \u0026\u0026 (eType == GDT_Byte || eType == GDT_UInt16) )\n    {\n        uint16 v[1] = { EXTRASAMPLE_UNASSALPHA };\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v );\n    }\n\n    // FIXME? libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    const bool bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, l_hTIFF, false, pszProfile,\n                                         pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/*      Write NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n    {\n        int bSuccess = FALSE;\n        const double dfNoData =\n            poSrcDS-\u003eGetRasterBand(1)-\u003eGetNoDataValue( \u0026bSuccess );\n        if( bSuccess )\n            GTiffDataset::WriteNoDataValue( l_hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Are we addressing PixelIsPoint mode?                            */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    if( poSrcDS-\u003eGetMetadataItem( GDALMD_AREA_OR_POINT )\n        \u0026\u0026 EQUAL(poSrcDS-\u003eGetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const char *l_pszProjection = nullptr;\n    double l_adfGeoTransform[6] = { 0.0 };\n\n    if( poSrcDS-\u003eGetGeoTransform( l_adfGeoTransform ) == CE_None )\n    {\n        if( bGeoTIFF )\n        {\n            l_pszProjection = poSrcDS-\u003eGetProjectionRef();\n\n            if( l_adfGeoTransform[2] == 0.0 \u0026\u0026 l_adfGeoTransform[4] == 0.0\n                \u0026\u0026 l_adfGeoTransform[5] \u003c 0.0 )\n            {\n                double dfOffset = 0.0;\n                {\n                    // In the case the SRS has a vertical component and we have\n                    // a single band, encode its scale/offset in the GeoTIFF tags\n                    int bHasScale = FALSE;\n                    double dfScale =\n                        poSrcDS-\u003eGetRasterBand(1)-\u003eGetScale(\u0026bHasScale);\n                    int bHasOffset = FALSE;\n                    dfOffset =\n                        poSrcDS-\u003eGetRasterBand(1)-\u003eGetOffset(\u0026bHasOffset);\n                    const bool bApplyScaleOffset =\n                        HasVerticalCS(l_pszProjection) \u0026\u0026\n                        poSrcDS-\u003eGetRasterCount() == 1;\n                    if( bApplyScaleOffset \u0026\u0026 !bHasScale )\n                        dfScale = 1.0;\n                    if( !bApplyScaleOffset || !bHasOffset )\n                        dfOffset = 0.0;\n                    const double adfPixelScale[3] = {\n                        l_adfGeoTransform[1], fabs(l_adfGeoTransform[5]),\n                        bApplyScaleOffset ? dfScale : 0.0 };\n\n                    TIFFSetField( l_hTIFF, TIFFTAG_GEOPIXELSCALE, 3,\n                                  adfPixelScale );\n                }\n\n                double adfTiePoints[6] = {\n                    0.0,\n                    0.0,\n                    0.0,\n                    l_adfGeoTransform[0],\n                    l_adfGeoTransform[3],\n                    dfOffset\n                };\n\n                if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n                {\n                    adfTiePoints[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfTiePoints[4] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double adfMatrix[16] = { 0.0 };\n\n                adfMatrix[0] = l_adfGeoTransform[1];\n                adfMatrix[1] = l_adfGeoTransform[2];\n                adfMatrix[3] = l_adfGeoTransform[0];\n                adfMatrix[4] = l_adfGeoTransform[4];\n                adfMatrix[5] = l_adfGeoTransform[5];\n                adfMatrix[7] = l_adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n\n                if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n                {\n                    adfMatrix[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfMatrix[7] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CPLFetchBool( papszOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", l_adfGeoTransform );\n        else if( CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", l_adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS-\u003eGetGCPCount() \u003e 0 \u0026\u0026 bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS-\u003eGetGCPs();\n        double *padfTiePoints = static_cast\u003cdouble *\u003e(\n            CPLMalloc(6 * sizeof(double) * poSrcDS-\u003eGetGCPCount()) );\n\n        for( int iGCP = 0; iGCP \u003c poSrcDS-\u003eGetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                      6*poSrcDS-\u003eGetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n\n        l_pszProjection = poSrcDS-\u003eGetGCPProjection();\n\n        if( CPLFetchBool( papszOptions, \"TFW\", false )\n            || CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n        {\n            CPLError(\n                CE_Warning, CPLE_AppDefined,\n                \"TFW=ON or WORLDFILE=ON creation options are ignored when \"\n                \"GCPs are available\" );\n        }\n    }\n    else\n    {\n        l_pszProjection = poSrcDS-\u003eGetProjectionRef();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection =\n        l_pszProjection != nullptr \u0026\u0026 strlen(l_pszProjection) \u003e 0;\n    if( (bHasProjection || bPixelIsPoint) \u0026\u0026 bGeoTIFF )\n    {\n        GTIF *psGTIF = GTiffDatasetGTIFNew( l_hTIFF );\n\n        if( bHasProjection )\n        {\n            GTIFSetFromOGISDefnEx( psGTIF, l_pszProjection,\n                                   GetGTIFFKeysFlavor(papszOptions) );\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet( psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                        RasterPixelIsPoint );\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n    bool l_bDontReloadFirstBlock = false;\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        GTIFF_CopyFromJPEG_WriteAdditionalTags(l_hTIFF,\n                                               poSrcDS);\n    }\n#endif\n\n#if defined(HAVE_LIBJPEG) \u0026\u0026 !defined(BIGTIFF_SUPPORT)\n    else\n#endif\n\n#if !defined(BIGTIFF_SUPPORT)\n    /* -------------------------------------------------------------------- */\n    /*      If we are writing jpeg compression we need to write some        */\n    /*      imagery to force the jpegtables to get created.  This is,       */\n    /*      likely only needed with libtiff \u003e= 3.9.3 (#3633)                */\n    /* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_JPEG\n            \u0026\u0026 strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != nullptr )\n    {\n        CPLDebug( \"GDAL\",\n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( l_hTIFF ) )\n        {\n            const int cc = TIFFTileSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast\u003cunsigned char *\u003e( CPLCalloc(cc, 1) );\n            TIFFWriteEncodedTile( l_hTIFF, 0, pabyZeros, cc );\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            int cc = TIFFStripSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast\u003cunsigned char *\u003e( CPLCalloc(cc,1) );\n            TIFFWriteEncodedStrip( l_hTIFF, 0, pabyZeros, cc );\n            CPLFree( pabyZeros );\n        }\n        l_bDontReloadFirstBlock = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n\n    TIFFWriteCheck( l_hTIFF, TIFFIsTiled(l_hTIFF), \"GTiffCreateCopy()\" );\n    TIFFWriteDirectory( l_hTIFF );\n    if( bStreaming )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( l_hTIFF, 0 );\n        TIFFWriteDirectory( l_hTIFF );\n\n        if( VSIFSeekL( l_fpL, 0, SEEK_END ) != 0 )\n            CPLError(CE_Failure, CPLE_FileIO, \"Cannot seek\");\n        const int nSize = static_cast\u003cint\u003e( VSIFTellL(l_fpL) );\n\n        vsi_l_offset nDataLength = 0;\n        VSIGetMemFileBuffer( l_osTmpFilename, \u0026nDataLength, FALSE);\n        TIFFSetDirectory( l_hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( l_hTIFF, nSize );\n        TIFFWriteDirectory( l_hTIFF );\n    }\n    TIFFFlush( l_hTIFF );\n    XTIFFClose( l_hTIFF );\n    l_hTIFF = nullptr;\n\n    {\n        const CPLErr eErr = VSIFCloseL(l_fpL) == 0 ? CE_None : CE_Failure;\n        l_fpL = nullptr;\n\n        if( eErr != CE_None )\n        {\n            VSIUnlink( bStreaming ? l_osTmpFilename.c_str() : pszFilename );\n            return nullptr;\n        }\n    }\n\n    // fpStreaming will assigned to the instance and not closed here.\n    VSILFILE *fpStreaming = nullptr;\n    if( bStreaming )\n    {\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( l_osTmpFilename, \u0026nDataLength, FALSE);\n        fpStreaming = VSIFOpenL( pszFilename, \"wb\" );\n        if( fpStreaming == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            return nullptr;\n        }\n        if( static_cast\u003cvsi_l_offset\u003e(\n                VSIFWriteL( pabyBuffer, 1, static_cast\u003cint\u003e(nDataLength),\n                            fpStreaming ) ) != nDataLength )\n        {\n            CPLError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      static_cast\u003cint\u003e(nDataLength) );\n            CPL_IGNORE_RET_VAL(VSIFCloseL( fpStreaming ));\n            VSIUnlink(l_osTmpFilename);\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    CPLString osFileName(\"GTIFF_RAW:\");\n\n    osFileName += bStreaming ? l_osTmpFilename.c_str() : pszFilename;\n\n    GDALOpenInfo oOpenInfo( osFileName, GA_Update );\n    if( bStreaming )\n    {\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n    }\n    GTiffDataset *poDS = cpl::down_cast\u003cGTiffDataset *\u003e( Open(\u0026oOpenInfo) );\n    if( bStreaming )\n        CPLPopErrorHandler();\n    if( poDS == nullptr )\n    {\n        oOpenInfo.eAccess = GA_ReadOnly;\n        poDS = cpl::down_cast\u003cGTiffDataset *\u003e( Open(\u0026oOpenInfo) );\n    }\n\n    if( poDS == nullptr )\n    {\n        VSIUnlink( bStreaming ? l_osTmpFilename.c_str() : pszFilename );\n        return nullptr;\n    }\n    poDS-\u003eosFilename = pszFilename;\n\n    if( bStreaming )\n    {\n        VSIUnlink(l_osTmpFilename);\n        poDS-\u003efpToWrite = fpStreaming;\n    }\n    poDS-\u003eosProfile = pszProfile;\n\n    int nCloneInfoFlags = GCIF_PAM_DEFAULT \u0026 ~GCIF_MASK;\n\n    // If we explicitly asked not to tag the alpha band as such, do not\n    // reintroduce this alpha color interpretation in PAM.\n    if( poSrcDS-\u003eGetRasterBand(l_nBands)-\u003eGetColorInterpretation() ==\n        GCI_AlphaBand \u0026\u0026\n        GTiffGetAlphaValue(\n            CPLGetConfigOption(\n                \"GTIFF_ALPHA\",\n                CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n            DEFAULT_ALPHA_TYPE) == EXTRASAMPLE_UNSPECIFIED )\n    {\n        nCloneInfoFlags \u0026= ~GCIF_COLORINTERP;\n    }\n    // Ignore source band color interpretation if requesting PHOTOMETRIC=RGB\n    else if( l_nBands \u003e= 3 \u0026\u0026\n        EQUAL(CSLFetchNameValueDef(papszOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") )\n    {\n        for( int i = 1; i \u003c= 3; i++)\n        {\n            poDS-\u003eGetRasterBand(i)-\u003eSetColorInterpretation(\n                static_cast\u003cGDALColorInterp\u003e(GCI_RedBand + (i-1)));\n        }\n        nCloneInfoFlags \u0026= ~GCIF_COLORINTERP;\n        if( !(l_nBands == 4 \u0026\u0026 CSLFetchNameValue(papszOptions, \"ALPHA\") != nullptr) )\n        {\n            for( int i = 4; i \u003c= l_nBands; i++)\n            {\n                poDS-\u003eGetRasterBand(i)-\u003eSetColorInterpretation(\n                    poSrcDS-\u003eGetRasterBand(i)-\u003eGetColorInterpretation());\n            }\n        }\n    }\n\n    CPLString osOldGTIFF_REPORT_COMPD_CSVal(\n        CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"\"));\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"YES\");\n    poDS-\u003eCloneInfo( poSrcDS, nCloneInfoFlags );\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\",\n        osOldGTIFF_REPORT_COMPD_CSVal.empty() ? nullptr :\n        osOldGTIFF_REPORT_COMPD_CSVal.c_str());\n\n    if( !bGeoTIFF \u0026\u0026 (poDS-\u003eGetPamFlags() \u0026 GPF_DISABLED) == 0 )\n    {\n        // Copy georeferencing info to PAM if the profile is not GeoTIFF\n        poDS-\u003eGDALPamDataset::SetProjection(poDS-\u003eGetProjectionRef());\n        double adfGeoTransform[6];\n        if( poDS-\u003eGetGeoTransform(adfGeoTransform) == CE_None )\n        {\n            poDS-\u003eGDALPamDataset::SetGeoTransform(adfGeoTransform);\n        }\n        poDS-\u003eGDALPamDataset::SetGCPs(poDS-\u003eGetGCPCount(),\n                                      poDS-\u003eGetGCPs(),\n                                      poDS-\u003eGetGCPProjection());\n    }\n\n    poDS-\u003epapszCreationOptions = CSLDuplicate( papszOptions );\n    poDS-\u003ebDontReloadFirstBlock = l_bDontReloadFirstBlock;\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() does not merge metadata, it just replaces it        */\n/*      totally.  So we have to merge it.                               */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS-\u003eGetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS-\u003eGetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS-\u003eSetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    // Depending on the PHOTOMETRIC tag, the TIFF file may not have the same\n    // band count as the source. Will fail later in GDALDatasetCopyWholeRaster\n    // anyway.\n    for( int nBand = 1;\n         nBand \u003c= std::min(poDS-\u003eGetRasterCount(), poSrcDS-\u003eGetRasterCount()) ;\n         ++nBand )\n    {\n        GDALRasterBand* poSrcBand = poSrcDS-\u003eGetRasterBand(nBand);\n        GDALRasterBand* poDstBand = poDS-\u003eGetRasterBand(nBand);\n        papszSRC_MD = poSrcBand-\u003eGetMetadata();\n        papszDST_MD = CSLDuplicate(poDstBand-\u003eGetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDstBand-\u003eSetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n\n        char** papszCatNames = poSrcBand-\u003eGetCategoryNames();\n        if( nullptr != papszCatNames )\n            poDstBand-\u003eSetCategoryNames( papszCatNames );\n    }\n\n    l_hTIFF = static_cast\u003cTIFF *\u003e( poDS-\u003eGetInternalHandle(nullptr) );\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = poSrcDS-\u003eGetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            poDS-\u003eSetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Second chance: now that we have a PAM dataset, it is possible   */\n/*      to write metadata that we could not write as a TIFF tag.        */\n/* -------------------------------------------------------------------- */\n    if( !bHasWrittenMDInGeotiffTAG \u0026\u0026 !bStreaming )\n        GTiffDataset::WriteMetadata(\n            poDS, l_hTIFF, true, pszProfile,\n            pszFilename, papszOptions,\n            true /* don't write RPC and IMD file again */ );\n\n    if( !bStreaming )\n        GTiffDataset::WriteRPC(\n            poDS, l_hTIFF, true, pszProfile,\n            pszFilename, papszOptions,\n            true /* write only in PAM AND if needed */ );\n\n    // To avoid unnecessary directory rewriting.\n    poDS-\u003ebMetadataChanged = false;\n    poDS-\u003ebGeoTIFFInfoChanged = false;\n    poDS-\u003ebNoDataChanged = false;\n    poDS-\u003ebForceUnsetGTOrGCPs = false;\n    poDS-\u003ebForceUnsetProjection = false;\n    poDS-\u003ebStreamingOut = bStreaming;\n\n    // Don't try to load external metadata files (#6597).\n    poDS-\u003ebIMDRPCMetadataLoaded = true;\n\n    // We must re-set the compression level at this point, since it has been\n    // lost a few lines above when closing the newly create TIFF file The\n    // TIFFTAG_ZIPQUALITY \u0026 TIFFTAG_JPEGQUALITY are not store in the TIFF file.\n    // They are just TIFF session parameters.\n\n    poDS-\u003enZLevel = GTiffGetZLevel(papszOptions);\n    poDS-\u003enLZMAPreset = GTiffGetLZMAPreset(papszOptions);\n    poDS-\u003enZSTDLevel = GTiffGetZSTDPreset(papszOptions);\n    poDS-\u003enWebPLevel = GTiffGetWebPLevel(papszOptions);\n    poDS-\u003ebWebPLossless = GTiffGetWebPLossless(papszOptions);\n    poDS-\u003enJpegQuality = GTiffGetJpegQuality(papszOptions);\n    poDS-\u003enJpegTablesMode = GTiffGetJpegTablesMode(papszOptions);\n    poDS-\u003eGetDiscardLsbOption(papszOptions);\n#if HAVE_LERC\n    poDS-\u003edfMaxZError = GTiffGetLERCMaxZError(papszOptions);\n#endif\n    poDS-\u003eInitCreationOrOpenOptions(papszOptions);\n\n    if( l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        if( poDS-\u003enZLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, poDS-\u003enZLevel );\n        }\n    }\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( poDS-\u003enJpegQuality != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, poDS-\u003enJpegQuality );\n        }\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, poDS-\u003enJpegTablesMode );\n    }\n    if( l_nCompression == COMPRESSION_LZMA )\n    {\n        if( poDS-\u003enLZMAPreset != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, poDS-\u003enLZMAPreset );\n        }\n    }\n    if( l_nCompression == COMPRESSION_ZSTD ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        if( poDS-\u003enZSTDLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, poDS-\u003enZSTDLevel );\n        }\n    }\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, poDS-\u003edfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP )\n    {\n        if( poDS-\u003enWebPLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, poDS-\u003enWebPLevel );\n        }\n\n        if( poDS-\u003ebWebPLossless)\n        {\n          TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, poDS-\u003ebWebPLossless );\n        }\n    }\n\n    // Precreate (internal) mask, so that the IBuildOverviews() below\n    // has a chance to create also the overviews of the mask.\n    CPLErr eErr = CE_None;\n\n    const int nMaskFlags = poSrcDS-\u003eGetRasterBand(1)-\u003eGetMaskFlags();\n    bool bMask = false;\n    if( !(nMaskFlags \u0026 (GMF_ALL_VALID|GMF_ALPHA|GMF_NODATA) )\n        \u0026\u0026 (nMaskFlags \u0026 GMF_PER_DATASET) \u0026\u0026 !bStreaming )\n    {\n        bMask = true;\n        eErr = poDS-\u003eCreateMaskBand( nMaskFlags );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create and then copy existing overviews if requested            */\n/*  We do it such that all the IFDs are at the beginning of the file,   */\n/*  and that the imagery data for the smallest overview is written      */\n/*  first, that way the file is more usable when embedded in a          */\n/*  compressed stream.                                                  */\n/* -------------------------------------------------------------------- */\n\n    // For scaled progress due to overview copying.\n    const int nBandsWidthMask = l_nBands +  (bMask ? 1 : 0);\n    double dfTotalPixels =\n        static_cast\u003cdouble\u003e(nXSize) * nYSize * nBandsWidthMask;\n    double dfCurPixels = 0;\n\n    if( eErr == CE_None \u0026\u0026\n        CPLFetchBool(papszOptions, \"COPY_SRC_OVERVIEWS\", false) )\n    {\n        const int nSrcOverviews = poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverviewCount();\n        if( nSrcOverviews )\n        {\n            eErr = poDS-\u003eCreateOverviewsFromSrcOverviews(poSrcDS);\n\n            if( poDS-\u003enOverviewCount != nSrcOverviews )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                        \"Did only manage to instantiate %d overview levels, \"\n                        \"whereas source contains %d\",\n                        poDS-\u003enOverviewCount, nSrcOverviews);\n                eErr = CE_Failure;\n            }\n\n            for( int i = 0; i \u003c nSrcOverviews; ++i )\n            {\n                GDALRasterBand* poOvrBand =\n                    poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(i);\n                dfTotalPixels += static_cast\u003cdouble\u003e(poOvrBand-\u003eGetXSize()) *\n                                poOvrBand-\u003eGetYSize() * nBandsWidthMask;\n            }\n\n            char* papszCopyWholeRasterOptions[2] = { nullptr, nullptr };\n            if( l_nCompression != COMPRESSION_NONE )\n                papszCopyWholeRasterOptions[0] =\n                    const_cast\u003cchar*\u003e( \"COMPRESSED=YES\" );\n            // Now copy the imagery.\n            for( int i = 0; eErr == CE_None \u0026\u0026 i \u003c nSrcOverviews; ++i )\n            {\n                // Begin with the smallest overview.\n                const int iOvrLevel = nSrcOverviews - 1 - i;\n\n                // Create a fake dataset with the source overview level so that\n                // GDALDatasetCopyWholeRaster can cope with it.\n                GDALDataset* poSrcOvrDS =\n                    GDALCreateOverviewDataset(poSrcDS, iOvrLevel, TRUE);\n\n                GDALRasterBand* poOvrBand =\n                        poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(iOvrLevel);\n                double dfNextCurPixels =\n                    dfCurPixels +\n                    static_cast\u003cdouble\u003e(poOvrBand-\u003eGetXSize()) *\n                    poOvrBand-\u003eGetYSize() * l_nBands;\n\n                void* pScaledData =\n                    GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                            dfNextCurPixels / dfTotalPixels,\n                                            pfnProgress, pProgressData );\n\n                eErr =\n                    GDALDatasetCopyWholeRaster(\n                        GDALDataset::ToHandle(poSrcOvrDS),\n                        GDALDataset::ToHandle(poDS-\u003epapoOverviewDS[iOvrLevel]),\n                        papszCopyWholeRasterOptions,\n                        GDALScaledProgress, pScaledData );\n\n                dfCurPixels = dfNextCurPixels;\n                GDALDestroyScaledProgress(pScaledData);\n\n                delete poSrcOvrDS;\n                poSrcOvrDS = nullptr;\n                poDS-\u003epapoOverviewDS[iOvrLevel]-\u003eFlushCache();\n\n                // Copy mask of the overview.\n                if( eErr == CE_None \u0026\u0026 poDS-\u003epoMaskDS != nullptr )\n                {\n                    dfNextCurPixels +=\n                        static_cast\u003cdouble\u003e(poOvrBand-\u003eGetXSize()) *\n                                            poOvrBand-\u003eGetYSize();\n                    pScaledData =\n                        GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                            dfNextCurPixels / dfTotalPixels,\n                                            pfnProgress, pProgressData );\n                    eErr =\n                        GDALRasterBandCopyWholeRaster(\n                            poOvrBand-\u003eGetMaskBand(),\n                            poDS-\u003epapoOverviewDS[iOvrLevel]-\u003e\n                            poMaskDS-\u003eGetRasterBand(1),\n                            papszCopyWholeRasterOptions,\n                            GDALScaledProgress, pScaledData );\n                    dfCurPixels = dfNextCurPixels;\n                    GDALDestroyScaledProgress(pScaledData);\n                    poDS-\u003epapoOverviewDS[iOvrLevel]-\u003epoMaskDS-\u003eFlushCache();\n                }\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n    double dfNextCurPixels =\n        dfCurPixels + static_cast\u003cdouble\u003e(nXSize) * nYSize * l_nBands;\n    void* pScaledData = GDALCreateScaledProgress(\n        dfCurPixels / dfTotalPixels,\n        dfNextCurPixels / dfTotalPixels,\n        pfnProgress, pProgressData);\n\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bTryCopy = true;\n#endif\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        eErr = GTIFF_CopyFromJPEG( poDS, poSrcDS,\n                                   pfnProgress, pProgressData,\n                                   bTryCopy );\n\n        // In case of failure in the decompression step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n#ifdef JPEG_DIRECT_COPY\n    if( bDirectCopyFromJPEG )\n    {\n        eErr = GTIFF_DirectCopyFromJPEG(poDS, poSrcDS,\n                                        pfnProgress, pProgressData,\n                                        bTryCopy);\n\n        // In case of failure in the reading step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n    if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy \u0026\u0026\n#endif\n        (poDS-\u003ebTreatAsSplit || poDS-\u003ebTreatAsSplitBitmap) )\n    {\n        // For split bands, we use TIFFWriteScanline() interface.\n        CPLAssert(poDS-\u003enBitsPerSample == 8 || poDS-\u003enBitsPerSample == 1);\n\n        if( poDS-\u003enPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 poDS-\u003enBands \u003e 1 )\n        {\n            GByte* pabyScanline =\n                static_cast\u003cGByte *\u003e(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(l_hTIFF)) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            for( int j = 0; j \u003c nYSize \u0026\u0026 eErr == CE_None; ++j )\n            {\n                eErr =\n                    poSrcDS-\u003eRasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, l_nBands, nullptr, poDS-\u003enBands, 0, 1,\n                        nullptr );\n                if( eErr == CE_None \u0026\u0026\n                    TIFFWriteScanline( l_hTIFF, pabyScanline, j, 0) == -1 )\n                {\n                    CPLError( CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !GDALScaledProgress( (j + 1) * 1.0 / nYSize,\n                                         nullptr, pScaledData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree( pabyScanline );\n        }\n        else\n        {\n            GByte* pabyScanline = static_cast\u003cGByte *\u003e(\n                VSI_MALLOC_VERBOSE(nXSize) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            else\n                eErr = CE_None;\n            for( int iBand = 1; iBand \u003c= l_nBands \u0026\u0026 eErr == CE_None; ++iBand )\n            {\n                for( int j = 0; j \u003c nYSize \u0026\u0026 eErr == CE_None; ++j )\n                {\n                    eErr = poSrcDS-\u003eGetRasterBand(iBand)-\u003eRasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, 0, 0, nullptr );\n                    if( poDS-\u003ebTreatAsSplitBitmap )\n                    {\n                        for( int i = 0; i \u003c nXSize; ++i )\n                        {\n                            const GByte byVal = pabyScanline[i];\n                            if( (i \u0026 0x7) == 0 )\n                                pabyScanline[i \u003e\u003e 3] = 0;\n                            if( byVal )\n                                pabyScanline[i \u003e\u003e 3] |= 0x80 \u003e\u003e (i \u0026 0x7);\n                        }\n                    }\n                    if( eErr == CE_None \u0026\u0026\n                        TIFFWriteScanline(\n                            l_hTIFF, pabyScanline, j,\n                            static_cast\u003cuint16\u003e(iBand - 1)) == -1 )\n                    {\n                        CPLError( CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !GDALScaledProgress(\n                           (j + 1 + (iBand - 1) * nYSize) * 1.0 /\n                           (l_nBands * nYSize),\n                           nullptr, pScaledData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n\n        // Necessary to be able to read the file without re-opening.\n#if defined(HAVE_TIFFGETSIZEPROC)\n        TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( l_hTIFF );\n\n        TIFFFlushData( l_hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( l_hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n#endif\n\n        TIFFFlush( l_hTIFF );\n\n#if defined(HAVE_TIFFGETSIZEPROC)\n        if( poDS-\u003enDirOffset != TIFFCurrentDirOffset( l_hTIFF ) )\n        {\n            poDS-\u003enDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\", \"directory moved during flush.\" );\n        }\n#endif\n    }\n    else if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy \u0026\u0026\n#endif\n        eErr == CE_None )\n    {\n        char* papszCopyWholeRasterOptions[3] = { nullptr, nullptr, nullptr };\n        int iNextOption = 0;\n        papszCopyWholeRasterOptions[iNextOption++] =\n                const_cast\u003cchar *\u003e( \"SKIP_HOLES=YES\" );\n        if( l_nCompression != COMPRESSION_NONE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                const_cast\u003cchar *\u003e( \"COMPRESSED=YES\" );\n        }\n        // For streaming with separate, we really want that bands are written\n        // after each other, even if the source is pixel interleaved.\n        else if( bStreaming \u0026\u0026 poDS-\u003enPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                const_cast\u003cchar *\u003e(\"INTERLEAVE=BAND\");\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Do we want to ensure all blocks get written out on close to     */\n    /*      avoid sparse files?                                             */\n    /* -------------------------------------------------------------------- */\n        if( !CPLFetchBool( papszOptions, \"SPARSE_OK\", false ) )\n            poDS-\u003ebFillEmptyTilesAtClosing = true;\n\n        poDS-\u003ebWriteEmptyTiles =\n            bStreaming ||\n            (poDS-\u003enCompression != COMPRESSION_NONE \u0026\u0026\n             poDS-\u003ebFillEmptyTilesAtClosing);\n        // Only required for people writing non-compressed stripped files in the\n        // rightorder and wanting all tstrips to be written in the same order\n        // so that the end result can be memory mapped without knowledge of each\n        // strip offset\n        if( CPLTestBool( CSLFetchNameValueDef(\n                             papszOptions,\n                             \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n           CPLTestBool( CSLFetchNameValueDef(\n                             papszOptions,\n                             \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n        {\n            poDS-\u003ebWriteEmptyTiles = true;\n        }\n\n        eErr = GDALDatasetCopyWholeRaster(\n            /* (GDALDatasetH) */ poSrcDS,\n            /* (GDALDatasetH) */ poDS,\n            papszCopyWholeRasterOptions,\n            GDALScaledProgress, pScaledData );\n    }\n\n    GDALDestroyScaledProgress(pScaledData);\n\n    if( eErr == CE_None \u0026\u0026 !bStreaming )\n    {\n        pScaledData = GDALCreateScaledProgress(\n            dfNextCurPixels / dfTotalPixels,\n            1.0,\n            pfnProgress, pProgressData);\n        if( poDS-\u003epoMaskDS )\n        {\n            const char* l_papszOptions[2] = { \"COMPRESSED=YES\", nullptr };\n            eErr = GDALRasterBandCopyWholeRaster(\n                                    poSrcDS-\u003eGetRasterBand(1)-\u003eGetMaskBand(),\n                                    poDS-\u003eGetRasterBand(1)-\u003eGetMaskBand(),\n                                    const_cast\u003cchar **\u003e(l_papszOptions),\n                                    GDALScaledProgress, pScaledData );\n        }\n        else\n        {\n            eErr = GDALDriver::DefaultCopyMasks( poSrcDS, poDS, bStrict,\n                                                 nullptr,\n                                                 GDALScaledProgress, pScaledData );\n        }\n        GDALDestroyScaledProgress(pScaledData);\n    }\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = nullptr;\n\n        if( CPLTestBool(CPLGetConfigOption(\"GTIFF_DELETE_ON_ERROR\", \"YES\")) )\n        {\n            if( !bStreaming )\n            {\n                // Should really delete more carefully.\n                VSIUnlink( pszFilename );\n            }\n        }\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                          GetProjectionRef()                          */\n/************************************************************************/\n\nconst char *GTiffDataset::GetProjectionRef()\n\n{\n    if( nGCPCount == 0 )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n        LookForProjection();\n\n        return pszProjection;\n    }\n\n    return \"\";\n}\n\n\n/************************************************************************/\n/*                           HasVerticalCS()                            */\n/************************************************************************/\n\nbool GTiffDataset::HasVerticalCS(const char *pszProjectionIn)\n{\n    if( pszProjectionIn != nullptr \u0026\u0026 pszProjectionIn[0] != '\\0' )\n    {\n        OGRSpatialReference oSRS;\n        oSRS.SetFromUserInput(pszProjectionIn);\n        return CPL_TO_BOOL(oSRS.IsVertical());\n    }\n    else\n    {\n        return false;\n    }\n}\n\n/************************************************************************/\n/*                           SetProjection()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetProjection( const char * pszNewProjection )\n\n{\n    if( bStreamingOut \u0026\u0026 bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify projection at that point in \"\n            \"a streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n    LookForProjection();\n\n    if( !STARTS_WITH_CI(pszNewProjection, \"GEOGCS\")\n        \u0026\u0026 !STARTS_WITH_CI(pszNewProjection, \"PROJCS\")\n        \u0026\u0026 !STARTS_WITH_CI(pszNewProjection, \"LOCAL_CS\")\n        \u0026\u0026 !STARTS_WITH_CI(pszNewProjection, \"COMPD_CS\")\n        \u0026\u0026 !STARTS_WITH_CI(pszNewProjection, \"GEOCCS\")\n        \u0026\u0026 !EQUAL(pszNewProjection,\"\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                \"Only OGC WKT Projections supported for writing to GeoTIFF.  \"\n                \"%s not supported.\",\n                  pszNewProjection );\n\n        return CE_Failure;\n    }\n\n    if( EQUAL(pszNewProjection, \"\") \u0026\u0026\n        pszProjection != nullptr \u0026\u0026\n        !EQUAL(pszProjection, \"\") )\n    {\n        bForceUnsetProjection = true;\n    }\n\n    CPLFree( pszProjection );\n    pszProjection = CPLStrdup( pszNewProjection );\n\n    bGeoTIFFInfoChanged = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          GetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::GetGeoTransform( double * padfTransform )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    memcpy( padfTransform, adfGeoTransform, sizeof(double) * 6 );\n\n    if( !bGeoTransformValid )\n        return CE_Failure;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          SetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGeoTransform( double * padfTransform )\n\n{\n    if( bStreamingOut \u0026\u0026 bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify geotransform at that point in a \"\n            \"streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        if( nGCPCount \u003e 0 )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"GCPs previously set are going to be cleared \"\n                     \"due to the setting of a geotransform.\");\n            bForceUnsetGTOrGCPs = true;\n            GDALDeinitGCPs( nGCPCount, pasGCPList );\n            CPLFree( pasGCPList );\n            nGCPCount = 0;\n            pasGCPList = nullptr;\n        }\n        else if( padfTransform[0] == 0.0 \u0026\u0026\n                 padfTransform[1] == 0.0 \u0026\u0026\n                 padfTransform[2] == 0.0 \u0026\u0026\n                 padfTransform[3] == 0.0 \u0026\u0026\n                 padfTransform[4] == 0.0 \u0026\u0026\n                 padfTransform[5] == 0.0 )\n        {\n            if( bGeoTransformValid )\n            {\n                bForceUnsetGTOrGCPs = true;\n                bGeoTIFFInfoChanged = true;\n            }\n            bGeoTransformValid = false;\n            memcpy( adfGeoTransform, padfTransform, sizeof(double)*6 );\n            return CE_None;\n        }\n\n        memcpy( adfGeoTransform, padfTransform, sizeof(double)*6 );\n        bGeoTransformValid = true;\n        bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Attempt to call SetGeoTransform() on a read-only GeoTIFF file.\" );\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                            GetGCPCount()                             */\n/************************************************************************/\n\nint GTiffDataset::GetGCPCount()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return nGCPCount;\n}\n\n/************************************************************************/\n/*                          GetGCPProjection()                          */\n/************************************************************************/\n\nconst char *GTiffDataset::GetGCPProjection()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( nGCPCount \u003e 0 )\n    {\n        LookForProjection();\n    }\n    if( pszProjection != nullptr )\n        return pszProjection;\n\n    return \"\";\n}\n\n/************************************************************************/\n/*                               GetGCPs()                              */\n/************************************************************************/\n\nconst GDAL_GCP *GTiffDataset::GetGCPs()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return pasGCPList;\n}\n\n/************************************************************************/\n/*                               SetGCPs()                              */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGCPs( int nGCPCountIn, const GDAL_GCP *pasGCPListIn,\n                              const char *pszGCPProjection )\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        LookForProjection();\n\n        if( nGCPCount \u003e 0 \u0026\u0026 nGCPCountIn == 0 )\n        {\n            bForceUnsetGTOrGCPs = true;\n        }\n        else if( nGCPCountIn \u003e 0 \u0026\u0026\n                 bGeoTransformValid )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"A geotransform previously set is going to be cleared \"\n                     \"due to the setting of GCPs.\");\n            adfGeoTransform[0] = 0.0;\n            adfGeoTransform[1] = 1.0;\n            adfGeoTransform[2] = 0.0;\n            adfGeoTransform[3] = 0.0;\n            adfGeoTransform[4] = 0.0;\n            adfGeoTransform[5] = 1.0;\n            bGeoTransformValid = false;\n            bForceUnsetGTOrGCPs = true;\n        }\n\n        if( pszProjection != nullptr \u0026\u0026\n            !EQUAL(pszProjection, \"\") \u0026\u0026\n                   (pszGCPProjection == nullptr ||\n                   pszGCPProjection[0] == '\\0') )\n            bForceUnsetProjection = true;\n\n        if( nGCPCount \u003e 0 )\n        {\n            GDALDeinitGCPs( nGCPCount, pasGCPList );\n            CPLFree( pasGCPList );\n        }\n\n        nGCPCount = nGCPCountIn;\n        pasGCPList = GDALDuplicateGCPs(nGCPCount, pasGCPListIn);\n\n        CPLFree( pszProjection );\n        pszProjection = CPLStrdup( pszGCPProjection );\n        bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"SetGCPs() is only supported on newly created GeoTIFF files.\");\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadataDomainList()\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszDomainList = CSLDuplicate(oGTiffMDMD.GetDomainList());\n    char **papszBaseList = GDALDataset::GetMetadataDomainList();\n\n    const int nbBaseDomains = CSLCount(papszBaseList);\n\n    for( int domainId = 0; domainId \u003c nbBaseDomains; ++domainId )\n        papszDomainList = CSLAddString(papszDomainList,papszBaseList[domainId]);\n\n    CSLDestroy(papszBaseList);\n\n    return BuildMetadataDomainList(\n        papszDomainList,\n        TRUE,\n        \"\", \"ProxyOverviewRequest\", MD_DOMAIN_RPC, MD_DOMAIN_IMD,\n        \"SUBDATASETS\", \"EXIF\",\n        \"xml:XMP\", \"COLOR_PROFILE\", nullptr);\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"ProxyOverviewRequest\") )\n        return GDALPamDataset::GetMetadata( pszDomain );\n\n    if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"DERIVED_SUBDATASETS\"))\n    {\n        return GDALDataset::GetMetadata(pszDomain);\n    }\n\n    else if( pszDomain != nullptr \u0026\u0026 (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n        LoadMetadata();\n\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"SUBDATASETS\") )\n        ScanDirectories();\n\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"EXIF\") )\n        LoadEXIFMetadata();\n\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"COLOR_PROFILE\") )\n        LoadICCProfile();\n\n    else if( pszDomain == nullptr || EQUAL(pszDomain, \"\") )\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n\n    return oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\nCPLErr GTiffDataset::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( bStreamingOut \u0026\u0026 bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, MD_DOMAIN_RPC) )\n    {\n        // So that a subsequent GetMetadata() wouldn't override our new values\n        LoadMetadata();\n        m_bForceUnsetRPC = (CSLCount(papszMD) == 0);\n    }\n\n    if( (papszMD != nullptr) \u0026\u0026\n        (pszDomain != nullptr) \u0026\u0026\n        EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update \u0026\u0026\n            GDALPamDataset::GetMetadata(pszDomain) != nullptr )\n            GDALPamDataset::SetMetadata(nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) \u0026\u0026\n        CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT) != nullptr )\n    {\n        const char* pszPrevValue =\n                GetMetadataItem(GDALMD_AREA_OR_POINT);\n        const char* pszNewValue =\n                CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT);\n        if( pszPrevValue == nullptr || pszNewValue == nullptr ||\n            !EQUAL(pszPrevValue, pszNewValue) )\n        {\n            LookForProjection();\n            bGeoTIFFInfoChanged = true;\n        }\n    }\n\n    if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"xml:XMP\") )\n    {\n        if( papszMD != nullptr \u0026\u0026 *papszMD != nullptr )\n        {\n            int nTagSize = static_cast\u003cint\u003e(strlen(*papszMD));\n            TIFFSetField( hTIFF, TIFFTAG_XMLPACKET, nTagSize, *papszMD );\n        }\n        else\n        {\n#ifdef HAVE_UNSETFIELD\n            TIFFUnsetField( hTIFF, TIFFTAG_XMLPACKET );\n#else\n            CPLDebug(\n                \"GTiff\",\n                \"TIFFUnsetField() not supported, xml:XMP may not be cleared.\" );\n#endif\n        }\n    }\n\n    return oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffDataset::GetMetadataItem( const char *pszName,\n                                           const char *pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n    {\n        return GDALPamDataset::GetMetadataItem( pszName, pszDomain );\n    }\n    else if( pszDomain != nullptr \u0026\u0026 (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n    {\n        LoadMetadata();\n    }\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"SUBDATASETS\") )\n    {\n        ScanDirectories();\n    }\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"EXIF\") )\n    {\n        LoadEXIFMetadata();\n    }\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        LoadICCProfile();\n    }\n    else if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) \u0026\u0026\n        pszName != nullptr \u0026\u0026 EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n    }\n\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"_DEBUG_\") \u0026\u0026\n             pszName != nullptr \u0026\u0026\n             EQUAL(pszName, \"UNREACHED_VIRTUALMEMIO_CODE_PATH\") )\n    {\n        CPLString osMissing;\n        for( int i = 0; i \u003c static_cast\u003cint\u003e(\n                                CPL_ARRAYSIZE(anReachedVirtualMemIO)); ++i )\n        {\n            if( !anReachedVirtualMemIO[i] )\n            {\n                if( !osMissing.empty() ) osMissing += \",\";\n                osMissing += CPLSPrintf(\"%d\", i);\n            }\n        }\n        return (osMissing.size()) ? CPLSPrintf(\"%s\", osMissing.c_str()) : nullptr;\n    }\n#endif\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"_DEBUG_\") \u0026\u0026\n             pszName != nullptr \u0026\u0026 EQUAL(pszName, \"TIFFTAG_EXTRASAMPLES\") )\n    {\n        CPLString osRet;\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, \u0026count, \u0026v ) )\n        {\n            for( int i = 0; i \u003c static_cast\u003cint\u003e(count); ++i )\n            {\n                if( i \u003e 0 ) osRet += \",\";\n                osRet += CPLSPrintf(\"%d\", v[i]);\n            }\n        }\n        return (osRet.size()) ? CPLSPrintf(\"%s\", osRet.c_str()) : nullptr;\n    }\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"_DEBUG_\") \u0026\u0026\n             pszName != nullptr \u0026\u0026 EQUAL(pszName, \"TIFFTAG_PHOTOMETRIC\") )\n    {\n        return CPLSPrintf(\"%d\", nPhotometric);\n    }\n\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"_DEBUG_\") \u0026\u0026\n             pszName != nullptr \u0026\u0026 EQUAL( pszName, \"TIFFTAG_GDAL_METADATA\") )\n    {\n        char* pszText = nullptr;\n        if( !TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, \u0026pszText ) )\n            return nullptr;\n\n        return CPLSPrintf(\"%s\", pszText);\n    }\n\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetMetadataItem( const char *pszName,\n                                      const char *pszValue,\n                                      const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( bStreamingOut \u0026\u0026 bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( (pszDomain != nullptr) \u0026\u0026 EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update \u0026\u0026\n            GDALPamDataset::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamDataset::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) \u0026\u0026\n        pszName != nullptr \u0026\u0026 EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LookForProjection();\n        bGeoTIFFInfoChanged = true;\n    }\n\n    return oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                         GetInternalHandle()                          */\n/************************************************************************/\n\nvoid *GTiffDataset::GetInternalHandle( const char * /* pszHandleName */ )\n\n{\n    return hTIFF;\n}\n\n/************************************************************************/\n/*                         LoadEXIFMetadata()                           */\n/************************************************************************/\n\nvoid GTiffDataset::LoadEXIFMetadata()\n{\n    if( bEXIFMetadataLoaded )\n        return;\n    bEXIFMetadataLoaded = true;\n\n    if( !SetDirectory() )\n        return;\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n\n    GByte abyHeader[2] = { 0 };\n    if( VSIFSeekL(fp, 0, SEEK_SET) != 0 ||\n        VSIFReadL(abyHeader, 1, 2, fp) != 2 )\n        return;\n\n    const bool bLittleEndian = abyHeader[0] == 'I' \u0026\u0026 abyHeader[1] == 'I';\n    const bool bLeastSignificantBit = CPL_IS_LSB != 0;\n    const bool bSwabflag = bLittleEndian != bLeastSignificantBit;  // != is XOR.\n\n    char** papszMetadata = nullptr;\n    toff_t nOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n\n    if( TIFFGetField(hTIFF, TIFFTAG_EXIFIFD, \u0026nOffset) )\n    {\n        int nExifOffset = static_cast\u003cint\u003e(nOffset);\n        int nInterOffset = 0;\n        int nGPSOffset = 0;\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast\u003cint\u003e(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset);\n    }\n\n    if( TIFFGetField(hTIFF, TIFFTAG_GPSIFD, \u0026nOffset) )\n    {\n        int nExifOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n        int nInterOffset = 0;\n        int nGPSOffset = static_cast\u003cint\u003e(nOffset);\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast\u003cint\u003e(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset );\n    }\n\n    if( papszMetadata )\n    {\n        oGTiffMDMD.SetMetadata( papszMetadata, \"EXIF\" );\n        CSLDestroy( papszMetadata );\n    }\n}\n\n/************************************************************************/\n/*                           LoadMetadata()                             */\n/************************************************************************/\nvoid GTiffDataset::LoadMetadata()\n{\n    if( bIMDRPCMetadataLoaded )\n        return;\n    bIMDRPCMetadataLoaded = true;\n\n    GDALMDReaderManager mdreadermanager;\n    GDALMDReaderBase* mdreader =\n        mdreadermanager.GetReader(osFilename,\n                                  oOvManager.GetSiblingFiles(), MDR_ANY);\n\n    if( nullptr != mdreader )\n    {\n        mdreader-\u003eFillMetadata(\u0026oGTiffMDMD);\n\n        if(mdreader-\u003eGetMetadataDomain(MD_DOMAIN_RPC) == nullptr)\n        {\n            char** papszRPCMD = GTiffDatasetReadRPCTag(hTIFF);\n            if( papszRPCMD )\n            {\n                oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n                CSLDestroy( papszRPCMD );\n            }\n        }\n\n        papszMetadataFiles = mdreader-\u003eGetMetadataFiles();\n    }\n    else\n    {\n        char** papszRPCMD = GTiffDatasetReadRPCTag(hTIFF);\n        if( papszRPCMD )\n        {\n            oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n            CSLDestroy( papszRPCMD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                            GetFileList()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetFileList()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszFileList = GDALPamDataset::GetFileList();\n\n    LoadMetadata();\n    if(nullptr != papszMetadataFiles)\n    {\n        for( int i = 0; papszMetadataFiles[i] != nullptr; ++i )\n        {\n            if( CSLFindString( papszFileList, papszMetadataFiles[i] ) \u003c 0 )\n            {\n                papszFileList =\n                    CSLAddString( papszFileList, papszMetadataFiles[i] );\n            }\n        }\n    }\n\n    if( !osGeorefFilename.empty() \u0026\u0026\n        CSLFindString(papszFileList, osGeorefFilename) == -1 )\n    {\n        papszFileList = CSLAddString( papszFileList, osGeorefFilename );\n    }\n\n    return papszFileList;\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateMaskBand(int nFlagsIn)\n{\n    ScanDirectories();\n\n    if( poMaskDS != nullptr )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n    else if( CPLTestBool(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")) )\n    {\n        if( nFlagsIn != GMF_PER_DATASET )\n        {\n            CPLError(\n                CE_Failure, CPLE_AppDefined,\n                \"The only flag value supported for internal mask is \"\n                \"GMF_PER_DATASET\" );\n            return CE_Failure;\n        }\n\n        int l_nCompression = COMPRESSION_PACKBITS;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"\u003cValue\u003eDEFLATE\u003c/Value\u003e\") != nullptr )\n            l_nCompression = COMPRESSION_ADOBE_DEFLATE;\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                      \"File open for read-only accessing, \"\n                      \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlagsIn);\n        }\n\n        if( poBaseDS \u0026\u0026 !poBaseDS-\u003eSetDirectory() )\n            return CE_Failure;\n\n        if( !SetDirectory() )\n            return CE_Failure;\n\n        bool bIsOverview = false;\n        uint32 nSubType = 0;\n        if( TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, \u0026nSubType) )\n        {\n            bIsOverview = (nSubType \u0026 FILETYPE_REDUCEDIMAGE) != 0;\n\n            if( (nSubType \u0026 FILETYPE_MASK) != 0 )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        const int bIsTiled = TIFFIsTiled(hTIFF);\n\n        FlushDirectory();\n\n        const toff_t nOffset =\n            GTIFFWriteDirectory(\n                hTIFF,\n                bIsOverview ?\n                FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                nRasterXSize, nRasterYSize,\n                1, PLANARCONFIG_CONTIG, 1,\n                nBlockXSize, nBlockYSize,\n                bIsTiled, l_nCompression,\n                PHOTOMETRIC_MASK, PREDICTOR_NONE,\n                SAMPLEFORMAT_UINT, nullptr, nullptr, nullptr, 0, nullptr, \"\", nullptr, nullptr,\n                nullptr, nullptr );\n        if( nOffset == 0 )\n            return CE_Failure;\n\n        poMaskDS = new GTiffDataset();\n        poMaskDS-\u003ebPromoteTo8Bits =\n            CPLTestBool(\n                CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n        if( poMaskDS-\u003eOpenOffset( hTIFF, ppoActiveDSRef, nOffset,\n                                  false, GA_Update ) != CE_None)\n        {\n            delete poMaskDS;\n            poMaskDS = nullptr;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n\n    return GDALPamDataset::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::CreateMaskBand( int nFlagsIn )\n{\n    poGDS-\u003eScanDirectories();\n\n    if( poGDS-\u003epoMaskDS != nullptr )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n\n    if( CPLTestBool( CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\") ) )\n    {\n        return poGDS-\u003eCreateMaskBand(nFlagsIn);\n    }\n\n    return GDALPamRasterBand::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                       PrepareTIFFErrorFormat()                       */\n/*                                                                      */\n/*      sometimes the \"module\" has stuff in it that has special         */\n/*      meaning in a printf() style format, so we try to escape it.     */\n/*      For now we hope the only thing we have to escape is %'s.        */\n/************************************************************************/\n\nstatic char *PrepareTIFFErrorFormat( const char *module, const char *fmt )\n\n{\n    const size_t nModuleSize = strlen(module);\n    const size_t nModFmtSize = nModuleSize * 2 + strlen(fmt) + 2;\n    char *pszModFmt = static_cast\u003cchar *\u003e( CPLMalloc( nModFmtSize ) );\n\n    size_t iOut = 0;  // Used after for.\n\n    for( size_t iIn = 0; iIn \u003c nModuleSize; ++iIn )\n    {\n        if( module[iIn] == '%' )\n        {\n            CPLAssert(iOut \u003c nModFmtSize - 2);\n            pszModFmt[iOut++] = '%';\n            pszModFmt[iOut++] = '%';\n        }\n        else\n        {\n            CPLAssert(iOut \u003c nModFmtSize - 1);\n            pszModFmt[iOut++] = module[iIn];\n        }\n    }\n    CPLAssert(iOut \u003c nModFmtSize);\n    pszModFmt[iOut] = '\\0';\n    strcat( pszModFmt, \":\" );\n    strcat( pszModFmt, fmt );\n\n    return pszModFmt;\n}\n\n/************************************************************************/\n/*                        GTiffWarningHandler()                         */\n/************************************************************************/\nstatic void\nGTiffWarningHandler(const char* module, const char* fmt, va_list ap )\n{\n    if( strstr(fmt,\"nknown field\") != nullptr )\n        return;\n\n    char *pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    if( strstr(fmt, \"does not end in null byte\") != nullptr )\n    {\n        CPLString osMsg;\n        osMsg.vPrintf(pszModFmt, ap);\n        CPLDebug( \"GTiff\", \"%s\", osMsg.c_str() );\n    }\n    else\n    {\n        CPLErrorV( CE_Warning, CPLE_AppDefined, pszModFmt, ap );\n    }\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                         GTiffErrorHandler()                          */\n/************************************************************************/\nstatic void\nGTiffErrorHandler( const char* module, const char* fmt, va_list ap )\n{\n#ifdef BIGTIFF_SUPPORT\n    if( strcmp(fmt, \"Maximum TIFF file size exceeded\") == 0 )\n    {\n        // Ideally there would be a thread-safe way of setting this flag,\n        // but we cannot really use the extended error handler, since the\n        // handler is for all TIFF handles, and not necessarily the ones of\n        // this driver.\n        if( bGlobalInExternalOvr )\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use --config BIGTIFF_OVERVIEW YES configuration option.\";\n        else\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use BIGTIFF=YES creation option.\";\n    }\n#endif\n\n    char* pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    CPLErrorV( CE_Failure, CPLE_AppDefined, pszModFmt, ap );\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                          GTiffTagExtender()                          */\n/*                                                                      */\n/*      Install tags specially known to GDAL.                           */\n/************************************************************************/\n\nstatic TIFFExtendProc _ParentExtender = nullptr;\n\nstatic void GTiffTagExtender(TIFF *tif)\n\n{\n    const TIFFFieldInfo xtiffFieldInfo[] = {\n        { TIFFTAG_GDAL_METADATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast\u003cchar *\u003e( \"GDALMetadata\" ) },\n        { TIFFTAG_GDAL_NODATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast\u003cchar*\u003e( \"GDALNoDataValue\" ) },\n        { TIFFTAG_RPCCOEFFICIENT, -1, -1, TIFF_DOUBLE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast\u003cchar *\u003e( \"RPCCoefficient\" ) },\n        { TIFFTAG_TIFF_RSID, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast\u003cchar *\u003e( \"TIFF_RSID\" ) },\n        { TIFFTAG_GEO_METADATA, -1, -1, TIFF_BYTE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast\u003cchar *\u003e( \"GEO_METADATA\" ) }\n    };\n\n    if( _ParentExtender )\n        (*_ParentExtender)(tif);\n\n    TIFFMergeFieldInfo( tif, xtiffFieldInfo,\n                        sizeof(xtiffFieldInfo) / sizeof(xtiffFieldInfo[0]) );\n}\n\n/************************************************************************/\n/*                          GTiffOneTimeInit()                          */\n/*                                                                      */\n/*      This is stuff that is initialized for the TIFF library just     */\n/*      once.  We deliberately defer the initialization till the        */\n/*      first time we are likely to call into libtiff to avoid          */\n/*      unnecessary paging in of the library for GDAL apps that         */\n/*      don't use it.                                                   */\n/************************************************************************/\n#if defined(HAVE_DLFCN_H) \u0026\u0026 !defined(WIN32)\n#include \u003cdlfcn.h\u003e\n#endif\n\nstatic std::mutex oDeleteMutex;\n#ifdef HAVE_LERC\nstatic TIFFCodec* pLercCodec = nullptr;\n#endif\n\nint GTiffOneTimeInit()\n\n{\n    std::lock_guard\u003cstd::mutex\u003e oLock(oDeleteMutex);\n \n#ifdef HAVE_LERC\n    if( pLercCodec == nullptr )\n    {\n        pLercCodec = TIFFRegisterCODEC(COMPRESSION_LERC, \"LERC\", TIFFInitLERC);\n    }\n#endif\n\n    static bool bOneTimeInitDone = false;\n    if( bOneTimeInitDone )\n        return TRUE;\n\n    bOneTimeInitDone = true;\n\n    // This is a frequent configuration error that is difficult to track down\n    // for people unaware of the issue : GDAL built against internal libtiff\n    // (4.X), but used by an application that links with external libtiff (3.X)\n    // Note: on my conf, the order that cause GDAL to crash - and that is\n    // detected by the following code - is \"-ltiff -lgdal\". \"-lgdal -ltiff\"\n    // works for the GTiff driver but probably breaks the application that\n    // believes it uses libtiff 3.X but we cannot detect that.\n#if defined(BIGTIFF_SUPPORT) \u0026\u0026 !defined(RENAME_INTERNAL_LIBTIFF_SYMBOLS)\n#if defined(HAVE_DLFCN_H) \u0026\u0026 !defined(WIN32)\n    const char* (*pfnVersion)(void);\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n    pfnVersion = reinterpret_cast\u003cconst char* (*)(void)\u003e(dlsym(RTLD_DEFAULT, \"TIFFGetVersion\"));\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic pop\n#endif\n    if( pfnVersion )\n    {\n        const char* pszVersion = pfnVersion();\n        if( pszVersion \u0026\u0026 strstr(pszVersion, \"Version 3.\") != nullptr )\n        {\n            CPLError(\n                CE_Warning, CPLE_AppDefined,\n                \"libtiff version mismatch: You're linking against libtiff 3.X, \"\n                \"but GDAL has been compiled against libtiff \u003e= 4.0.0\" );\n        }\n    }\n#endif  // HAVE_DLFCN_H\n#endif  // BIGTIFF_SUPPORT\n\n    _ParentExtender = TIFFSetTagExtender(GTiffTagExtender);\n\n    TIFFSetWarningHandler( GTiffWarningHandler );\n    TIFFSetErrorHandler( GTiffErrorHandler );\n\n    LibgeotiffOneTimeInit();\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                        GDALDeregister_GTiff()                        */\n/************************************************************************/\n\nstatic\nvoid GDALDeregister_GTiff( GDALDriver * )\n\n{\n    CSVDeaccess( nullptr );\n\n#if defined(LIBGEOTIFF_VERSION) \u0026\u0026 LIBGEOTIFF_VERSION \u003e 1150\n    GTIFDeaccessCSV();\n#endif\n \n#ifdef HAVE_LERC\n    if( pLercCodec )\n        TIFFUnRegisterCODEC(pLercCodec);\n    pLercCodec = nullptr;\n#endif\n\n    delete gpoCompressThreadPool;\n    gpoCompressThreadPool = nullptr;\n}\n\n/************************************************************************/\n/*                   GTIFFGetCompressionMethod()                        */\n/************************************************************************/\n\nint GTIFFGetCompressionMethod(const char* pszValue, const char* pszVariableName)\n{\n    int nCompression = COMPRESSION_NONE;\n    if( EQUAL( pszValue, \"NONE\" ) )\n        nCompression = COMPRESSION_NONE;\n    else if( EQUAL( pszValue, \"JPEG\" ) )\n        nCompression = COMPRESSION_JPEG;\n    else if( EQUAL( pszValue, \"LZW\" ) )\n        nCompression = COMPRESSION_LZW;\n    else if( EQUAL( pszValue, \"PACKBITS\" ))\n        nCompression = COMPRESSION_PACKBITS;\n    else if( EQUAL( pszValue, \"DEFLATE\" ) || EQUAL( pszValue, \"ZIP\" ))\n        nCompression = COMPRESSION_ADOBE_DEFLATE;\n    else if( EQUAL( pszValue, \"FAX3\" )\n             || EQUAL( pszValue, \"CCITTFAX3\" ))\n        nCompression = COMPRESSION_CCITTFAX3;\n    else if( EQUAL( pszValue, \"FAX4\" )\n             || EQUAL( pszValue, \"CCITTFAX4\" ))\n        nCompression = COMPRESSION_CCITTFAX4;\n    else if( EQUAL( pszValue, \"CCITTRLE\" ) )\n        nCompression = COMPRESSION_CCITTRLE;\n    else if( EQUAL( pszValue, \"LZMA\" ) )\n        nCompression = COMPRESSION_LZMA;\n    else if( EQUAL( pszValue, \"ZSTD\" ) )\n        nCompression = COMPRESSION_ZSTD;\n#ifdef HAVE_LERC\n    else if( EQUAL( pszValue, \"LERC\" ) ||\n             EQUAL( pszValue, \"LERC_DEFLATE\" ) ||\n             EQUAL( pszValue, \"LERC_ZSTD\" ) )\n    {\n        nCompression = COMPRESSION_LERC;\n    }\n#endif\n    else if( EQUAL( pszValue, \"WEBP\" ) )\n        nCompression = COMPRESSION_WEBP;\n    else\n        CPLError( CE_Warning, CPLE_IllegalArg,\n                  \"%s=%s value not recognised, ignoring.\",\n                  pszVariableName,pszValue );\n\n#if defined(TIFFLIB_VERSION) \u0026\u0026 TIFFLIB_VERSION \u003e 20031007  // 3.6.0\n    if( nCompression != COMPRESSION_NONE \u0026\u0026\n        !TIFFIsCODECConfigured(static_cast\u003cuint16\u003e(nCompression)) )\n    {\n        CPLError(\n            CE_Failure, CPLE_AppDefined,\n            \"Cannot create TIFF file due to missing codec for %s.\", pszValue );\n        return -1;\n    }\n#endif\n\n    return nCompression;\n}\n\n/************************************************************************/\n/*                          GDALRegister_GTiff()                        */\n/************************************************************************/\n\nvoid GDALRegister_GTiff()\n\n{\n    if( GDALGetDriverByName( \"GTiff\" ) != nullptr )\n        return;\n\n    CPLString osOptions;\n    CPLString osCompressValues;\n    bool bHasJPEG = false;\n    bool bHasLZMA = false;\n    bool bHasZSTD = false;\n    bool bHasWebP = false;\n\n    GDALDriver *poDriver = new GDALDriver();\n\n/* -------------------------------------------------------------------- */\n/*      Determine which compression codecs are available that we        */\n/*      want to advertise.  If we are using an old libtiff we won't     */\n/*      be able to find out so we just assume all are available.        */\n/* -------------------------------------------------------------------- */\n    osCompressValues = \"       \u003cValue\u003eNONE\u003c/Value\u003e\";\n\n#if TIFFLIB_VERSION \u003c= 20040919\n    osCompressValues +=\n            \"       \u003cValue\u003ePACKBITS\u003c/Value\u003e\"\n            \"       \u003cValue\u003eJPEG\u003c/Value\u003e\"\n            \"       \u003cValue\u003eLZW\u003c/Value\u003e\"\n            \"       \u003cValue\u003eDEFLATE\u003c/Value\u003e\";\n    bool bHasLZW = true;\n    bool bHasDEFLATE = true;\n#else\n    bool bHasLZW = false;\n    bool bHasDEFLATE = false;\n    TIFFCodec *codecs = TIFFGetConfiguredCODECs();\n\n    for( TIFFCodec *c = codecs; c-\u003ename; ++c )\n    {\n        if( c-\u003escheme == COMPRESSION_PACKBITS )\n        {\n            osCompressValues +=\n                    \"       \u003cValue\u003ePACKBITS\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_JPEG )\n        {\n            bHasJPEG = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eJPEG\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_LZW )\n        {\n            bHasLZW = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eLZW\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_ADOBE_DEFLATE )\n        {\n            bHasDEFLATE = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eDEFLATE\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_CCITTRLE )\n        {\n            osCompressValues +=\n                    \"       \u003cValue\u003eCCITTRLE\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_CCITTFAX3 )\n        {\n            osCompressValues +=\n                    \"       \u003cValue\u003eCCITTFAX3\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_CCITTFAX4 )\n        {\n            osCompressValues +=\n                    \"       \u003cValue\u003eCCITTFAX4\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_LZMA )\n        {\n            bHasLZMA = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eLZMA\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_ZSTD )\n        {\n            bHasZSTD = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eZSTD\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_WEBP )\n        {\n            bHasWebP = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eWEBP\u003c/Value\u003e\";\n        }\n    }\n#ifdef HAVE_LERC\n    osCompressValues +=\n                    \"       \u003cValue\u003eLERC\u003c/Value\u003e\";\n    osCompressValues +=\n                    \"       \u003cValue\u003eLERC_DEFLATE\u003c/Value\u003e\";\n    if( bHasZSTD )\n    {\n        osCompressValues +=\n                    \"       \u003cValue\u003eLERC_ZSTD\u003c/Value\u003e\";\n    }\n#endif\n    _TIFFfree( codecs );\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Build full creation option list.                                */\n/* -------------------------------------------------------------------- */\n    osOptions = \"\u003cCreationOptionList\u003e\"\n              \"   \u003cOption name='COMPRESS' type='string-select'\u003e\";\n    osOptions += osCompressValues;\n    osOptions += \"   \u003c/Option\u003e\";\n    if( bHasLZW || bHasDEFLATE || bHasZSTD )\n        osOptions += \"\"\n\"   \u003cOption name='PREDICTOR' type='int' description='Predictor Type (1=default, 2=horizontal differencing, 3=floating point prediction)'/\u003e\";\n    osOptions += \"\"\n\"   \u003cOption name='DISCARD_LSB' type='string' description='Number of least-significant bits to set to clear as a single value or comma-separated list of values for per-band values'/\u003e\";\n    if( bHasJPEG )\n    {\n        osOptions += \"\"\n\"   \u003cOption name='JPEG_QUALITY' type='int' description='JPEG quality 1-100' default='75'/\u003e\"\n\"   \u003cOption name='JPEGTABLESMODE' type='int' description='Content of JPEGTABLES tag. 0=no JPEGTABLES tag, 1=Quantization tables only, 2=Huffman tables only, 3=Both' default='1'/\u003e\";\n#ifdef JPEG_DIRECT_COPY\n        osOptions += \"\"\n\"   \u003cOption name='JPEG_DIRECT_COPY' type='boolean' description='To copy without any decompression/recompression a JPEG source file' default='NO'/\u003e\";\n#endif\n    }\n    if( bHasDEFLATE )\n        osOptions += \"\"\n\"   \u003cOption name='ZLEVEL' type='int' description='DEFLATE compression level 1-9' default='6'/\u003e\";\n    if( bHasLZMA )\n        osOptions += \"\"\n\"   \u003cOption name='LZMA_PRESET' type='int' description='LZMA compression level 0(fast)-9(slow)' default='6'/\u003e\";\n    if( bHasZSTD )\n        osOptions += \"\"\n\"   \u003cOption name='ZSTD_LEVEL' type='int' description='ZSTD compression level 1(fast)-22(slow)' default='9'/\u003e\";\n#ifdef HAVE_LERC\n    osOptions += \"\"\n\"   \u003cOption name='MAX_Z_ERROR' type='float' description='Maximum error for LERC compression' default='0'/\u003e\";\n#endif\n    if ( bHasWebP )\n    {\n      osOptions += \"\"\n#if WEBP_ENCODER_ABI_VERSION \u003e= 0x0100\n\"   \u003cOption name='WEBP_LOSSLESS' type='boolean' description='Whether lossless compression should be used' default='FALSE'/\u003e\"\n#endif\n\"   \u003cOption name='WEBP_LEVEL' type='int' description='WEBP quality level. Low values result in higher compression ratios' default='75'/\u003e\";\n    }\n    osOptions += \"\"\n\"   \u003cOption name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/\u003e\"\n\"   \u003cOption name='NBITS' type='int' description='BITS for sub-byte files (1-7), sub-uint16 (9-15), sub-uint32 (17-31), or float32 (16)'/\u003e\"\n\"   \u003cOption name='INTERLEAVE' type='string-select' default='PIXEL'\u003e\"\n\"       \u003cValue\u003eBAND\u003c/Value\u003e\"\n\"       \u003cValue\u003ePIXEL\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='TILED' type='boolean' description='Switch to tiled format'/\u003e\"\n\"   \u003cOption name='TFW' type='boolean' description='Write out world file'/\u003e\"\n\"   \u003cOption name='RPB' type='boolean' description='Write out .RPB (RPC) file'/\u003e\"\n\"   \u003cOption name='RPCTXT' type='boolean' description='Write out _RPC.TXT file'/\u003e\"\n\"   \u003cOption name='BLOCKXSIZE' type='int' description='Tile Width'/\u003e\"\n\"   \u003cOption name='BLOCKYSIZE' type='int' description='Tile/Strip Height'/\u003e\"\n\"   \u003cOption name='PHOTOMETRIC' type='string-select'\u003e\"\n\"       \u003cValue\u003eMINISBLACK\u003c/Value\u003e\"\n\"       \u003cValue\u003eMINISWHITE\u003c/Value\u003e\"\n\"       \u003cValue\u003ePALETTE\u003c/Value\u003e\"\n\"       \u003cValue\u003eRGB\u003c/Value\u003e\"\n\"       \u003cValue\u003eCMYK\u003c/Value\u003e\"\n\"       \u003cValue\u003eYCBCR\u003c/Value\u003e\"\n\"       \u003cValue\u003eCIELAB\u003c/Value\u003e\"\n\"       \u003cValue\u003eICCLAB\u003c/Value\u003e\"\n\"       \u003cValue\u003eITULAB\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/\u003e\"\n\"   \u003cOption name='ALPHA' type='string-select' description='Mark first extrasample as being alpha'\u003e\"\n\"       \u003cValue\u003eNON-PREMULTIPLIED\u003c/Value\u003e\"\n\"       \u003cValue\u003ePREMULTIPLIED\u003c/Value\u003e\"\n\"       \u003cValue\u003eUNSPECIFIED\u003c/Value\u003e\"\n\"       \u003cValue aliasOf='NON-PREMULTIPLIED'\u003eYES\u003c/Value\u003e\"\n\"       \u003cValue aliasOf='UNSPECIFIED'\u003eNO\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='PROFILE' type='string-select' default='GDALGeoTIFF'\u003e\"\n\"       \u003cValue\u003eGDALGeoTIFF\u003c/Value\u003e\"\n\"       \u003cValue\u003eGeoTIFF\u003c/Value\u003e\"\n\"       \u003cValue\u003eBASELINE\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='PIXELTYPE' type='string-select'\u003e\"\n\"       \u003cValue\u003eDEFAULT\u003c/Value\u003e\"\n\"       \u003cValue\u003eSIGNEDBYTE\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n#ifdef BIGTIFF_SUPPORT\n\"   \u003cOption name='BIGTIFF' type='string-select' description='Force creation of BigTIFF file'\u003e\"\n\"     \u003cValue\u003eYES\u003c/Value\u003e\"\n\"     \u003cValue\u003eNO\u003c/Value\u003e\"\n\"     \u003cValue\u003eIF_NEEDED\u003c/Value\u003e\"\n\"     \u003cValue\u003eIF_SAFER\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n#endif\n\"   \u003cOption name='ENDIANNESS' type='string-select' default='NATIVE' description='Force endianness of created file. For DEBUG purpose mostly'\u003e\"\n\"       \u003cValue\u003eNATIVE\u003c/Value\u003e\"\n\"       \u003cValue\u003eINVERTED\u003c/Value\u003e\"\n\"       \u003cValue\u003eLITTLE\u003c/Value\u003e\"\n\"       \u003cValue\u003eBIG\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='COPY_SRC_OVERVIEWS' type='boolean' default='NO' description='Force copy of overviews of source dataset (CreateCopy())'/\u003e\"\n\"   \u003cOption name='SOURCE_ICC_PROFILE' type='string' description='ICC profile'/\u003e\"\n\"   \u003cOption name='SOURCE_PRIMARIES_RED' type='string' description='x,y,1.0 (xyY) red chromaticity'/\u003e\"\n\"   \u003cOption name='SOURCE_PRIMARIES_GREEN' type='string' description='x,y,1.0 (xyY) green chromaticity'/\u003e\"\n\"   \u003cOption name='SOURCE_PRIMARIES_BLUE' type='string' description='x,y,1.0 (xyY) blue chromaticity'/\u003e\"\n\"   \u003cOption name='SOURCE_WHITEPOINT' type='string' description='x,y,1.0 (xyY) whitepoint'/\u003e\"\n\"   \u003cOption name='TIFFTAG_TRANSFERFUNCTION_RED' type='string' description='Transfer function for red'/\u003e\"\n\"   \u003cOption name='TIFFTAG_TRANSFERFUNCTION_GREEN' type='string' description='Transfer function for green'/\u003e\"\n\"   \u003cOption name='TIFFTAG_TRANSFERFUNCTION_BLUE' type='string' description='Transfer function for blue'/\u003e\"\n\"   \u003cOption name='TIFFTAG_TRANSFERRANGE_BLACK' type='string' description='Transfer range for black'/\u003e\"\n\"   \u003cOption name='TIFFTAG_TRANSFERRANGE_WHITE' type='string' description='Transfer range for white'/\u003e\"\n\"   \u003cOption name='STREAMABLE_OUTPUT' type='boolean' default='NO' description='Enforce a mode compatible with a streamable file'/\u003e\"\n\"   \u003cOption name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used'\u003e\"\n\"       \u003cValue\u003eSTANDARD\u003c/Value\u003e\"\n\"       \u003cValue\u003eESRI_PE\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"\u003c/CreationOptionList\u003e\";\n\n/* -------------------------------------------------------------------- */\n/*      Set the driver details.                                         */\n/* -------------------------------------------------------------------- */\n    poDriver-\u003eSetDescription( \"GTiff\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DCAP_RASTER, \"YES\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_LONGNAME, \"GeoTIFF\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_HELPTOPIC, \"frmt_gtiff.html\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_MIMETYPE, \"image/tiff\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_EXTENSION, \"tif\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_EXTENSIONS, \"tif tiff\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_CREATIONDATATYPES,\n                               \"Byte UInt16 Int16 UInt32 Int32 Float32 \"\n                               \"Float64 CInt16 CInt32 CFloat32 CFloat64\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_CREATIONOPTIONLIST, osOptions );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_OPENOPTIONLIST,\n\"\u003cOpenOptionList\u003e\"\n\"   \u003cOption name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/\u003e\"\n\"   \u003cOption name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used (for writing)'\u003e\"\n\"       \u003cValue\u003eSTANDARD\u003c/Value\u003e\"\n\"       \u003cValue\u003eESRI_PE\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='GEOREF_SOURCES' type='string' description='Comma separated list made with values INTERNAL/TABFILE/WORLDFILE/PAM/NONE that describe the priority order for georeferencing' default='PAM,INTERNAL,TABFILE,WORLDFILE'/\u003e\"\n\"   \u003cOption name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/\u003e\"\n\"\u003c/OpenOptionList\u003e\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_SUBDATASETS, \"YES\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DCAP_VIRTUALIO, \"YES\" );\n\n#ifdef INTERNAL_LIBTIFF\n    poDriver-\u003eSetMetadataItem( \"LIBTIFF\", \"INTERNAL\" );\n#else\n    poDriver-\u003eSetMetadataItem( \"LIBTIFF\", TIFFLIB_VERSION_STR );\n#endif\n\n    poDriver-\u003epfnOpen = GTiffDataset::Open;\n    poDriver-\u003epfnCreate = GTiffDataset::Create;\n    poDriver-\u003epfnCreateCopy = GTiffDataset::CreateCopy;\n    poDriver-\u003epfnUnloadDriver = GDALDeregister_GTiff;\n    poDriver-\u003epfnIdentify = GTiffDataset::Identify;\n\n    GetGDALDriverManager()-\u003eRegisterDriver( poDriver );\n}\n",
        "name": "geotiff.cpp",
        "path": "deps/libgdal/gdal/frmts/gtiff/geotiff.cpp",
        "url": "/github.com/naturalatlas/node-gdal/-/blob/deps/libgdal/gdal/frmts/gtiff/geotiff.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5960,
          "offsetAndLengths": [
            [
              16,
              19
            ]
          ],
          "preview": "            if( TIFFReadRGBATileExt("
        }
      ],
      "repository": {
        "name": "github.com/naturalatlas/node-gdal",
        "url": "/github.com/naturalatlas/node-gdal"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "c15ace4a9bb90693e1e9aaa55969b51859ec2633"
        },
        "content": "#include \"FDSan.h\"\n#include \u003ctiffio.hxx\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdint.h\u003e\n#include \u003cvector\u003e\n#include \u003cfstream\u003e\n#include \u003ciostream\u003e\n#include \u003csstream\u003e\n//\u003cID\u003e 1498\n//\u003cPrompt\u003e [\"TIFFStreamOpen\",\"TIFFReadBufferSetup\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFGetStrileByteCountWithErr\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"TIFFReadRGBATileExt\",\"_TIFFfree\",\"TIFFClose\"]\n/*\u003cCombination\u003e: [TIFF *TIFFStreamOpen(const char * , std::ostream * ),\n    int TIFFReadBufferSetup(TIFF * tif, void * bp, tmsize_t size),\n    int TIFFGetField(TIFF * tif, uint32_t tag),\n    void *_TIFFmalloc(tmsize_t s),\n    int TIFFReadRGBAImageOriented(TIFF * , uint32_t , uint32_t , uint32_t * , int , int ),\n    uint64_t TIFFStripSize64(TIFF * tif),\n    int TIFFIsByteSwapped(TIFF * ),\n    uint64_t TIFFGetStrileByteCountWithErr(TIFF * tif, uint32_t strile, int * pbErr),\n    TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc ),\n    int TIFFFlushData(TIFF * tif),\n    double LogL16toY(int ),\n    int TIFFReadRGBAStripExt(TIFF * , uint32_t , uint32_t * , int stop_on_error),\n    uint32_t LogLuv24fromXYZ(float * , int ),\n    int TIFFReadRGBATileExt(TIFF * , uint32_t , uint32_t , uint32_t * , int stop_on_error),\n    void _TIFFfree(void * p),\n    void TIFFClose(TIFF * tif)\n*/\n//\u003cscore\u003e 117.8, nr_unique_branch: 78\n//\u003cQuality\u003e {\"density\":31,\"unique_branches\":{\"ZIPCleanup\":[[538,9,538,39,0,0,4,0]],\"ZIPPostEncode\":[[504,13,504,30,0,0,4,0],[505,13,505,22,0,0,4,1],[506,21,506,75,0,0,4,0],[510,25,510,45,0,0,4,1],[514,25,514,70,0,0,4,0],[519,13,519,20,0,0,4,1],[523,14,523,35,0,0,4,1]],\"TIFFSetupStrips\":[[551,30,551,64,3,0,4,1],[209,34,209,71,10,0,4,0]],\"TIFFWriteDirectorySec\":[[534,9,534,61,0,0,4,0],[572,21,574,80,0,0,4,1],[576,21,578,80,0,0,4,1],[636,21,638,77,0,0,4,1],[650,21,652,54,0,0,4,1],[678,21,680,80,0,0,4,1],[852,25,852,54,0,0,4,0],[853,25,853,58,0,0,4,1],[209,34,209,71,15,0,4,0],[209,34,209,71,33,0,4,0],[209,34,209,71,37,0,4,0],[209,34,209,71,45,0,4,0]],\"TIFFWriteDirectoryTagCheckedRational\":[[2363,9,2363,18,0,0,4,1],[2368,14,2368,28,0,0,4,1],[2383,9,2383,35,0,0,4,0]],\"TIFFFlushData\":[[150,9,150,41,0,0,4,0],[153,13,153,41,0,0,4,1]],\"ZIPSetupEncode\":[[297,9,297,39,0,0,4,1],[304,9,304,43,0,0,4,1],[307,9,307,56,0,0,4,1]],\"TIFFWriteDirectoryTagRational\":[[1689,9,1689,20,0,0,4,0],[1689,9,1689,20,0,0,4,1]],\"TIFFWriteScanline\":[[70,9,70,34,0,0,4,1],[85,9,85,53,0,0,4,1],[105,9,105,32,0,0,4,1],[107,9,107,35,0,0,4,0],[107,9,107,35,0,0,4,1],[112,13,112,32,0,0,4,1],[120,13,120,43,0,0,4,1],[123,13,123,39,0,0,4,1],[129,13,129,52,0,0,4,0],[129,13,129,52,0,0,4,1],[131,17,131,46,0,0,4,1],[142,13,142,48,0,0,4,1],[151,9,151,28,0,0,4,1],[36,6,36,43,1,0,4,0],[36,47,36,79,1,0,4,0],[40,7,40,44,2,0,4,0],[40,7,40,44,2,0,4,1],[40,48,40,64,2,0,4,0],[41,6,41,53,2,0,4,0]],\"ZIPPreEncode\":[[328,9,328,40,0,0,4,1],[339,28,339,73,0,0,4,0]],\"putRGBAAseparate8bittile\":[[1356,9,1356,15,4,0,4,0]],\"_WriteAsType\":[[1813,9,1813,40,0,0,4,1],[1817,14,1817,45,0,0,4,1],[1818,14,1818,44,0,0,4,1],[1819,14,1819,54,0,0,4,1],[1820,14,1820,48,0,0,4,0]],\"PredictorSetupEncode\":[[231,9,231,33,0,0,4,1],[231,37,231,57,0,0,4,1],[234,9,234,27,0,0,4,1],[292,14,292,32,0,0,4,1]],\"_TIFFReadEncodedTileAndAllocBuffer\":[[1053,19,1053,57,0,0,4,0]],\"TIFFWriteBufferSetup\":[[695,13,695,28,0,0,4,0],[250,22,250,62,3,0,4,1]],\"TIFFFlushData1\":[[928,9,928,27,0,0,4,0],[928,31,928,62,0,0,4,0],[930,13,930,25,0,0,4,1],[933,13,935,50,0,0,4,1],[250,22,250,62,4,0,4,1]],\"ZIPEncode\":[[460,13,460,40,0,0,4,0],[463,13,463,53,0,0,4,1],[468,13,468,38,0,0,4,1],[479,14,479,20,0,0,4,1]],\"DoubleToRational\":[[2673,9,2673,22,0,0,4,1],[2682,9,2682,29,0,0,4,1],[2689,9,2689,35,0,0,4,0]]},\"library_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFClose\",\"TIFFReadRGBAImageOriented\",\"_TIFFfree\",\"TIFFClose\",\"TIFFOpen\",\"_TIFFfree\",\"TIFFClose\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFDefaultStripSize\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFWriteScanline\",\"_TIFFfree\",\"TIFFClose\",\"TIFFClose\",\"_TIFFfree\",\"TIFFClose\",\"TIFFClose\"],\"critical_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"TIFFOpen\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFDefaultStripSize\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFWriteScanline\",\"_TIFFfree\",\"TIFFClose\",\"TIFFClose\"],\"visited\":4}\n/*Here is the complete implementation of the LLVMFuzzerTestOneInput_62 function:\n\n*/\n\nextern \"C\" int LLVMFuzzerTestOneInput_62(const uint8_t* data, size_t size) {\n\tif(size\u003c0) return 0;\n\n\tFILE *input_file_ptr = fopen(\"input_file\", \"wb\");\n\tif (input_file_ptr == NULL) {return 0;}\n\tfwrite(data, sizeof(uint8_t), size, input_file_ptr);\n\tfclose(input_file_ptr);\n\n  // write data into input_file\n  FILE *in_file = fopen(\"input_file\", \"wb\");\n  if (in_file == NULL) {\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n  }\n  fwrite(data, sizeof(uint8_t), size, in_file);\n  assert_file_closed(\u0026in_file);;\n\n  // open input tiff in memory\n  std::istringstream s(std::string(data, data + size));\n  TIFF *in_tif = TIFFStreamOpen(\"MemTIFF\", \u0026s);\n  if (!in_tif) {\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n  }\n\n  // initialize variables\n  uint32_t width;\n  uint32_t height;\n  uint32_t* raster;\n  int stop_on_error = 0;\n  int error = 0;\n\n  // get width and height from TIFF\n  TIFFGetField(in_tif, TIFFTAG_IMAGEWIDTH, \u0026width);\n  TIFFGetField(in_tif, TIFFTAG_IMAGELENGTH, \u0026height);\n\n  // allocate memory for raster\n  tmsize_t raster_size = width * height * sizeof(uint32_t);\n  raster = (uint32_t*)_TIFFmalloc(raster_size);\n  if (!raster) {\n    TIFFClose(in_tif);\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n  }\n\n  // read RGBA image from TIFF\n  int result = TIFFReadRGBAImageOriented(in_tif, width, height, raster, 0, 1);\n  if (!result) {\n    _TIFFfree(raster);\n    TIFFClose(in_tif);\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n  }\n\n  // perform operations on raster data\n  // ...\n\n  // write raster data to output TIFF\n  TIFF* out_tif = TIFFOpen(\"output_file\", \"wb\");\n  if (!out_tif) {\n    _TIFFfree(raster);\n    TIFFClose(in_tif);\n    assert_file_name_closed(\"output_file\");\n\tassert_file_closed(\u0026in_file);\n\treturn 0;\n  }\n\n  TIFFSetField(out_tif, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(out_tif, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(out_tif, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(out_tif, TIFFTAG_SAMPLESPERPIXEL, 4);\n  TIFFSetField(out_tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(out_tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(out_tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out_tif, 0));\n  TIFFSetField(out_tif, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n  TIFFSetField(out_tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(out_tif, TIFFTAG_XRESOLUTION, 72.0);\n  TIFFSetField(out_tif, TIFFTAG_YRESOLUTION, 72.0);\n  TIFFSetField(out_tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\n  tmsize_t raster_size_bytes = width * height * sizeof(uint32_t);\n  for (uint32_t row = 0; row \u003c height; row++) {\n    if (TIFFWriteScanline(out_tif, \u0026raster[row * width], row, 0) \u003c 0) {\n      error = 1;\n      break;\n    }\n  }\n\n  if (error) {\n    _TIFFfree(raster);\n    TIFFClose(in_tif);\n    TIFFClose(out_tif);\n    assert_file_name_closed(\"output_file\");\n\tassert_file_closed(\u0026in_file);\n\treturn 0;\n  }\n\n  _TIFFfree(raster);\n  TIFFClose(in_tif);\n  TIFFClose(out_tif);\n\n  assert_file_name_closed(\"output_file\");\n\tassert_file_closed(\u0026in_file);\n\treturn 0;\n}",
        "name": "id_000062.cc",
        "path": "examples/libtiff/fuzzer_0/fuzzers/id_000062.cc",
        "url": "/github.com/PromptFuzz/PromptFuzz/-/blob/examples/libtiff/fuzzer_0/fuzzers/id_000062.cc"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              269,
              19
            ]
          ],
          "preview": "//\u003cPrompt\u003e [\"TIFFStreamOpen\",\"TIFFReadBufferSetup\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFGetStrileByteCountWithErr\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"TIFFReadRGBATileExt\",\"_TIFFfree\",\"TIFFClose\"]"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              8,
              19
            ]
          ],
          "preview": "    int TIFFReadRGBATileExt(TIFF * , uint32_t , uint32_t , uint32_t * , int stop_on_error),"
        }
      ],
      "repository": {
        "name": "github.com/PromptFuzz/PromptFuzz",
        "url": "/github.com/PromptFuzz/PromptFuzz"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "c15ace4a9bb90693e1e9aaa55969b51859ec2633"
        },
        "content": "#include \"FDSan.h\"\n#include \"FuzzedDataProvider.h\"\n#include \u003ctiffio.hxx\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdint.h\u003e\n#include \u003cvector\u003e\n#include \u003cfstream\u003e\n#include \u003ciostream\u003e\n#include \u003csstream\u003e\n//\u003cID\u003e 1498\n//\u003cPrompt\u003e [\"TIFFStreamOpen\",\"TIFFReadBufferSetup\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFGetStrileByteCountWithErr\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"TIFFReadRGBATileExt\",\"_TIFFfree\",\"TIFFClose\"]\n/*\u003cCombination\u003e: [TIFF *TIFFStreamOpen(const char * , std::ostream * ),\n    int TIFFReadBufferSetup(TIFF * tif, void * bp, tmsize_t size),\n    int TIFFGetField(TIFF * tif, uint32_t tag),\n    void *_TIFFmalloc(tmsize_t s),\n    int TIFFReadRGBAImageOriented(TIFF * , uint32_t , uint32_t , uint32_t * , int , int ),\n    uint64_t TIFFStripSize64(TIFF * tif),\n    int TIFFIsByteSwapped(TIFF * ),\n    uint64_t TIFFGetStrileByteCountWithErr(TIFF * tif, uint32_t strile, int * pbErr),\n    TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc ),\n    int TIFFFlushData(TIFF * tif),\n    double LogL16toY(int ),\n    int TIFFReadRGBAStripExt(TIFF * , uint32_t , uint32_t * , int stop_on_error),\n    uint32_t LogLuv24fromXYZ(float * , int ),\n    int TIFFReadRGBATileExt(TIFF * , uint32_t , uint32_t , uint32_t * , int stop_on_error),\n    void _TIFFfree(void * p),\n    void TIFFClose(TIFF * tif)\n*/\n//\u003cscore\u003e 117.8, nr_unique_branch: 78\n//\u003cQuality\u003e {\"density\":31,\"unique_branches\":{\"ZIPCleanup\":[[538,9,538,39,0,0,4,0]],\"ZIPPostEncode\":[[504,13,504,30,0,0,4,0],[505,13,505,22,0,0,4,1],[506,21,506,75,0,0,4,0],[510,25,510,45,0,0,4,1],[514,25,514,70,0,0,4,0],[519,13,519,20,0,0,4,1],[523,14,523,35,0,0,4,1]],\"TIFFSetupStrips\":[[551,30,551,64,3,0,4,1],[209,34,209,71,10,0,4,0]],\"TIFFWriteDirectorySec\":[[534,9,534,61,0,0,4,0],[572,21,574,80,0,0,4,1],[576,21,578,80,0,0,4,1],[636,21,638,77,0,0,4,1],[650,21,652,54,0,0,4,1],[678,21,680,80,0,0,4,1],[852,25,852,54,0,0,4,0],[853,25,853,58,0,0,4,1],[209,34,209,71,15,0,4,0],[209,34,209,71,33,0,4,0],[209,34,209,71,37,0,4,0],[209,34,209,71,45,0,4,0]],\"TIFFWriteDirectoryTagCheckedRational\":[[2363,9,2363,18,0,0,4,1],[2368,14,2368,28,0,0,4,1],[2383,9,2383,35,0,0,4,0]],\"TIFFFlushData\":[[150,9,150,41,0,0,4,0],[153,13,153,41,0,0,4,1]],\"ZIPSetupEncode\":[[297,9,297,39,0,0,4,1],[304,9,304,43,0,0,4,1],[307,9,307,56,0,0,4,1]],\"TIFFWriteDirectoryTagRational\":[[1689,9,1689,20,0,0,4,0],[1689,9,1689,20,0,0,4,1]],\"TIFFWriteScanline\":[[70,9,70,34,0,0,4,1],[85,9,85,53,0,0,4,1],[105,9,105,32,0,0,4,1],[107,9,107,35,0,0,4,0],[107,9,107,35,0,0,4,1],[112,13,112,32,0,0,4,1],[120,13,120,43,0,0,4,1],[123,13,123,39,0,0,4,1],[129,13,129,52,0,0,4,0],[129,13,129,52,0,0,4,1],[131,17,131,46,0,0,4,1],[142,13,142,48,0,0,4,1],[151,9,151,28,0,0,4,1],[36,6,36,43,1,0,4,0],[36,47,36,79,1,0,4,0],[40,7,40,44,2,0,4,0],[40,7,40,44,2,0,4,1],[40,48,40,64,2,0,4,0],[41,6,41,53,2,0,4,0]],\"ZIPPreEncode\":[[328,9,328,40,0,0,4,1],[339,28,339,73,0,0,4,0]],\"putRGBAAseparate8bittile\":[[1356,9,1356,15,4,0,4,0]],\"_WriteAsType\":[[1813,9,1813,40,0,0,4,1],[1817,14,1817,45,0,0,4,1],[1818,14,1818,44,0,0,4,1],[1819,14,1819,54,0,0,4,1],[1820,14,1820,48,0,0,4,0]],\"PredictorSetupEncode\":[[231,9,231,33,0,0,4,1],[231,37,231,57,0,0,4,1],[234,9,234,27,0,0,4,1],[292,14,292,32,0,0,4,1]],\"_TIFFReadEncodedTileAndAllocBuffer\":[[1053,19,1053,57,0,0,4,0]],\"TIFFWriteBufferSetup\":[[695,13,695,28,0,0,4,0],[250,22,250,62,3,0,4,1]],\"TIFFFlushData1\":[[928,9,928,27,0,0,4,0],[928,31,928,62,0,0,4,0],[930,13,930,25,0,0,4,1],[933,13,935,50,0,0,4,1],[250,22,250,62,4,0,4,1]],\"ZIPEncode\":[[460,13,460,40,0,0,4,0],[463,13,463,53,0,0,4,1],[468,13,468,38,0,0,4,1],[479,14,479,20,0,0,4,1]],\"DoubleToRational\":[[2673,9,2673,22,0,0,4,1],[2682,9,2682,29,0,0,4,1],[2689,9,2689,35,0,0,4,0]]},\"library_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFClose\",\"TIFFReadRGBAImageOriented\",\"_TIFFfree\",\"TIFFClose\",\"TIFFOpen\",\"_TIFFfree\",\"TIFFClose\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFDefaultStripSize\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFWriteScanline\",\"_TIFFfree\",\"TIFFClose\",\"TIFFClose\",\"_TIFFfree\",\"TIFFClose\",\"TIFFClose\"],\"critical_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"TIFFOpen\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFDefaultStripSize\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFSetField\",\"TIFFWriteScanline\",\"_TIFFfree\",\"TIFFClose\",\"TIFFClose\"],\"visited\":4}\n/*Here is the complete implementation of the LLVMFuzzerTestOneInput_62 function:\n\n*/\n\nextern \"C\" int LLVMFuzzerTestOneInput_62(const uint8_t* f_data, size_t f_size) {\n\tif(f_size\u003c81) return 0;\n\n\t\n\t//fuzzer vars shim {\n\t\tFuzzedDataProvider fdp(f_data, f_size);\n\t\tFDPConsumeRawBytes(const uint8_t *, data, size, fdp)\n\t\tFDPConsumeRandomLengthString(char, fuzz_str_1, fuzz_str_sz_1, fdp);\n\t\tFDPConsumeIntegral(int32_t, fuzz_int32_t_2, fdp);\n\t\tFDPConsumeIntegral(int32_t, fuzz_int32_t_3, fdp);\n\t\tFDPConsumeRandomLengthString(char, fuzz_str_4, fuzz_str_sz_4, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_5, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_6, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_7, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_8, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_9, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_10, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_11, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_12, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_13, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_14, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_15, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_16, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_17, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_18, fdp);\n\t\tFDPConsumeIntegral(uint16_t, fuzz_uint16_t_19, fdp);\n\t//fuzzer shim end}\n\n\n\n\n  // write data into input_file\n  FILE *in_file = fopen(\"input_file\", \"wb\");\n  if (in_file == NULL) {\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n  }\n  fwrite(data, sizeof(uint8_t), size, in_file);\n  assert_file_closed(\u0026in_file);;\n\n  // open input tiff in memory\n  std::istringstream s(std::string(data, data + size));\n  TIFF *in_tif = TIFFStreamOpen(fuzz_str_1, \u0026s);\n  if (!in_tif) {\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n  }\n\n  // initialize variables\n  uint32_t width;\n  uint32_t height;\n  uint32_t* raster;\n  int stop_on_error = 0;\n  int error = 0;\n\n  // get width and height from TIFF\n  TIFFGetField(in_tif, TIFFTAG_IMAGEWIDTH, \u0026width);\n  TIFFGetField(in_tif, TIFFTAG_IMAGELENGTH, \u0026height);\n\n  // allocate memory for raster\n  tmsize_t raster_size = width * height * sizeof(uint32_t);\n  raster = (uint32_t*)_TIFFmalloc(raster_size);\n  if (!raster) {\n    TIFFClose(in_tif);\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n  }\n\n  // read RGBA image from TIFF\n  int result = TIFFReadRGBAImageOriented(in_tif, width, height, raster, fuzz_int32_t_2, fuzz_int32_t_3);\n  if (!result) {\n    _TIFFfree(raster);\n    TIFFClose(in_tif);\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n  }\n\n  // perform operations on raster data\n  // ...\n\n  // write raster data to output TIFF\n  TIFF* out_tif = TIFFOpen(\"output_file\", fuzz_str_4);\n  if (!out_tif) {\n    _TIFFfree(raster);\n    TIFFClose(in_tif);\n    assert_file_closed(\u0026in_file);\n\tassert_file_name_closed(\"output_file\");\n\treturn 0;\n  }\n\n  TIFFSetField(out_tif, fuzz_uint32_t_5, width);\n  TIFFSetField(out_tif, fuzz_uint32_t_6, height);\n  TIFFSetField(out_tif, fuzz_uint32_t_7, 8);\n  TIFFSetField(out_tif, fuzz_uint32_t_8, 4);\n  TIFFSetField(out_tif, fuzz_uint32_t_9, PHOTOMETRIC_RGB);\n  TIFFSetField(out_tif, fuzz_uint32_t_10, PLANARCONFIG_CONTIG);\n  TIFFSetField(out_tif, fuzz_uint32_t_11, TIFFDefaultStripSize(out_tif, fuzz_uint32_t_12));\n  TIFFSetField(out_tif, fuzz_uint32_t_13, COMPRESSION_DEFLATE);\n  TIFFSetField(out_tif, fuzz_uint32_t_14, ORIENTATION_TOPLEFT);\n  TIFFSetField(out_tif, fuzz_uint32_t_15, 72.0);\n  TIFFSetField(out_tif, fuzz_uint32_t_16, 72.0);\n  TIFFSetField(out_tif, fuzz_uint32_t_17, RESUNIT_INCH);\n\n  tmsize_t raster_size_bytes = width * height * sizeof(uint32_t);\n  for (uint32_t row = 0; row \u003c height; row++) {\n    if (TIFFWriteScanline(out_tif, \u0026raster[row * width], fuzz_uint32_t_18, fuzz_uint16_t_19) \u003c 0) {\n      error = 1;\n      break;\n    }\n  }\n\n  if (error) {\n    _TIFFfree(raster);\n    TIFFClose(in_tif);\n    TIFFClose(out_tif);\n    assert_file_closed(\u0026in_file);\n\tassert_file_name_closed(\"output_file\");\n\treturn 0;\n  }\n\n  _TIFFfree(raster);\n  TIFFClose(in_tif);\n  TIFFClose(out_tif);\n\n  assert_file_closed(\u0026in_file);\n\tassert_file_name_closed(\"output_file\");\n\treturn 0;\n}",
        "name": "id_000062.cc",
        "path": "examples/libtiff/fuzzer_1/fuzzers/id_000062.cc",
        "url": "/github.com/PromptFuzz/PromptFuzz/-/blob/examples/libtiff/fuzzer_1/fuzzers/id_000062.cc"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              269,
              19
            ]
          ],
          "preview": "//\u003cPrompt\u003e [\"TIFFStreamOpen\",\"TIFFReadBufferSetup\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFGetStrileByteCountWithErr\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"TIFFReadRGBATileExt\",\"_TIFFfree\",\"TIFFClose\"]"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              8,
              19
            ]
          ],
          "preview": "    int TIFFReadRGBATileExt(TIFF * , uint32_t , uint32_t , uint32_t * , int stop_on_error),"
        }
      ],
      "repository": {
        "name": "github.com/PromptFuzz/PromptFuzz",
        "url": "/github.com/PromptFuzz/PromptFuzz"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "123c2fbef73b431e42d3d0294f94ed862bbc83d9"
        },
        "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam \u003cwarmerdam@pobox.com\u003e\n * Copyright (c) 2007-2015, Even Rouault \u003ceven dot rouault at spatialys dot com\u003e\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n// If we use sunpro compiler on linux. Weird idea indeed!\n#if defined(__SUNPRO_CC) \u0026\u0026 defined(__linux__)\n#define _GNU_SOURCE\n#elif defined(__GNUC__) \u0026\u0026 !defined(_GNU_SOURCE)\n// Required to use RTLD_DEFAULT of dlfcn.h.\n#define _GNU_SOURCE\n#endif\n\n#include \"cpl_port.h\"  // Must be first.\n#include \"gtiff.h\"\n\n#include \u003ccassert\u003e\n#include \u003ccerrno\u003e\n#include \u003cclimits\u003e\n#include \u003ccmath\u003e\n#include \u003ccstdarg\u003e\n#include \u003ccstddef\u003e\n#include \u003ccstdio\u003e\n#include \u003ccstdlib\u003e\n#include \u003ccstring\u003e\n#if HAVE_FCNTL_H\n#include \u003cfcntl.h\u003e\n#endif\n#if HAVE_SYS_STAT_H\n#  include \u003csys/stat.h\u003e\n#endif\n\n#include \u003calgorithm\u003e\n#include \u003cmap\u003e\n#include \u003cmemory\u003e\n#include \u003cmutex\u003e\n#include \u003cset\u003e\n#include \u003cstring\u003e\n#include \u003cqueue\u003e\n#include \u003cutility\u003e\n#include \u003cvector\u003e\n\n#include \"cpl_config.h\"\n#include \"cpl_conv.h\"\n#include \"cpl_error.h\"\n#include \"cpl_error_internal.h\"\n#include \"cpl_mem_cache.h\"\n#include \"cpl_minixml.h\"\n#include \"cpl_multiproc.h\"\n#include \"cpl_port.h\"\n#include \"cpl_progress.h\"\n#include \"cpl_string.h\"\n#include \"cpl_virtualmem.h\"\n#include \"cpl_vsi.h\"\n#include \"cpl_vsi_virtual.h\"\n#include \"cpl_worker_thread_pool.h\"\n#include \"cplkeywordparser.h\"\n#include \"gdal.h\"\n#include \"gdal_frmts.h\"\n#include \"gdal_mdreader.h\"\n#include \"gdal_pam.h\"\n#include \"gdal_priv.h\"\n#include \"gdal_priv_templates.hpp\"\n#include \"gdal_thread_pool.h\"\n#include \"geo_normalize.h\"\n#include \"geotiff.h\"\n#include \"geovalues.h\"\n#include \"gt_jpeg_copy.h\"\n#include \"gt_overview.h\"\n#include \"gt_wkt_srs.h\"\n#include \"gt_wkt_srs_priv.h\"\n#include \"ogr_spatialref.h\"\n#include \"ogr_proj_p.h\"\n#include \"tiff.h\"\n#include \"tif_float.h\"\n#include \"tiffio.h\"\n#ifdef INTERNAL_LIBTIFF\n#  include \"tif_lerc.h\"\n#endif\n#include \"tiffvers.h\"\n#include \"tifvsi.h\"\n#include \"xtiffio.h\"\n\nCPL_CVSID(\"$Id: geotiff.cpp 9e52ad241bade9e0b989281f186f01e8a17106de 2020-10-19 14:27:54 +0200 Even Rouault $\")\n\nstatic bool bGlobalInExternalOvr = false;\n\n// Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if TIFFLIB_VERSION \u003e= 20120922\n#define SUPPORTS_MORE_THAN_32768_DIRECTORIES\n#endif\n\n#if TIFFLIB_VERSION \u003e 20181110 // \u003e 4.0.10\n#define SUPPORTS_GET_OFFSET_BYTECOUNT\n#endif\n\nconst char* const szJPEGGTiffDatasetTmpPrefix = \"/vsimem/gtiffdataset_jpg_tmp_\";\n\ntypedef enum\n{\n    GTIFFTAGTYPE_STRING,\n    GTIFFTAGTYPE_SHORT,\n    GTIFFTAGTYPE_FLOAT,\n    GTIFFTAGTYPE_BYTE_STRING\n} GTIFFTagTypes;\n\ntypedef struct\n{\n    const char    *pszTagName;\n    int            nTagVal;\n    GTIFFTagTypes  eType;\n} GTIFFTags;\n\nstatic const GTIFFTags asTIFFTags[] =\n{\n    { \"TIFFTAG_DOCUMENTNAME\", TIFFTAG_DOCUMENTNAME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_IMAGEDESCRIPTION\", TIFFTAG_IMAGEDESCRIPTION,\n        GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_SOFTWARE\", TIFFTAG_SOFTWARE, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_DATETIME\", TIFFTAG_DATETIME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_ARTIST\", TIFFTAG_ARTIST, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_HOSTCOMPUTER\", TIFFTAG_HOSTCOMPUTER, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_COPYRIGHT\", TIFFTAG_COPYRIGHT, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_XRESOLUTION\", TIFFTAG_XRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    { \"TIFFTAG_YRESOLUTION\", TIFFTAG_YRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    // Dealt as special case.\n    { \"TIFFTAG_RESOLUTIONUNIT\", TIFFTAG_RESOLUTIONUNIT, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MINSAMPLEVALUE\", TIFFTAG_MINSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MAXSAMPLEVALUE\", TIFFTAG_MAXSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n\n    // GeoTIFF DGIWG tags\n    { \"GEO_METADATA\", TIFFTAG_GEO_METADATA, GTIFFTAGTYPE_BYTE_STRING },\n    { \"TIFF_RSID\", TIFFTAG_TIFF_RSID, GTIFFTAGTYPE_STRING },\n};\n\nconst char szPROFILE_BASELINE[] = \"BASELINE\";\nconst char szPROFILE_GeoTIFF[] = \"GeoTIFF\";\nconst char szPROFILE_GDALGeoTIFF[] = \"GDALGeoTIFF\";\n\n/************************************************************************/\n/*                          GTIFFSetInExternalOvr()                     */\n/************************************************************************/\n\nvoid GTIFFSetInExternalOvr( bool b )\n{\n    bGlobalInExternalOvr = b;\n}\n\n/************************************************************************/\n/*                     GTIFFGetOverviewBlockSize()                      */\n/************************************************************************/\n\nvoid GTIFFGetOverviewBlockSize( GDALRasterBandH hBand, int* pnBlockXSize, int* pnBlockYSize )\n{\n    const char* pszVal = CPLGetConfigOption(\"GDAL_TIFF_OVR_BLOCKSIZE\", nullptr);\n    if( ! pszVal )\n    {\n        GDALRasterBand* const poBand = GDALRasterBand::FromHandle(hBand);\n        poBand-\u003eGetBlockSize(pnBlockXSize,pnBlockYSize);\n        if ( *pnBlockXSize != *pnBlockYSize ||\n             *pnBlockXSize \u003c 64 || *pnBlockXSize \u003e 4096 ||\n             !CPLIsPowerOfTwo(*pnBlockXSize) )\n        {\n            *pnBlockXSize=*pnBlockYSize=128;\n        }\n    }\n    else\n    {\n        int nOvrBlockSize = atoi(pszVal);\n        if( nOvrBlockSize \u003c 64 || nOvrBlockSize \u003e 4096 ||\n            !CPLIsPowerOfTwo(nOvrBlockSize) )\n        {\n            static bool bHasWarned = false;\n            if( !bHasWarned )\n            {\n                CPLError( CE_Warning, CPLE_NotSupported,\n                          \"Wrong value for GDAL_TIFF_OVR_BLOCKSIZE : %s. \"\n                          \"Should be a power of 2 between 64 and 4096. \"\n                          \"Defaulting to 128\",\n                          pszVal );\n                bHasWarned = true;\n            }\n            nOvrBlockSize = 128;\n        }\n\n        *pnBlockXSize = nOvrBlockSize;\n        *pnBlockYSize = nOvrBlockSize;\n    }\n}\n\nenum\n{\n    ENDIANNESS_NATIVE,\n    ENDIANNESS_LITTLE,\n    ENDIANNESS_BIG\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffDataset                                */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand;\nclass GTiffDataset;\nclass GTiffJPEGOverviewBand;\nclass GTiffJPEGOverviewDS;\nclass GTiffRasterBand;\nclass GTiffRGBABand;\n\n#if !defined(__MINGW32__)\nnamespace {\n#endif\ntypedef struct\n{\n    GTiffDataset *poDS;\n    char         *pszTmpFilename;\n    GByte        *pabyBuffer;\n    GByte        *pabyCompressedBuffer;  // Owned by pszTmpFilename.\n    GPtrDiff_t    nBufferSize;\n    GPtrDiff_t    nCompressedBufferSize;\n    int           nHeight;\n    int           nStripOrTile;\n    uint16        nPredictor;\n    bool          bTIFFIsBigEndian;\n    bool          bReady;\n} GTiffCompressionJob;\n#if !defined(__MINGW32__)\n}\n#endif\n\nenum class GTiffProfile: GByte\n{\n    BASELINE,\n    GEOTIFF,\n    GDALGEOTIFF\n};\n\nclass GTiffDataset final : public GDALPamDataset\n{\npublic:\n    struct MaskOffset\n    {\n        int nMask;\n        int nOffset;\n    };\n\nprivate:\n    CPL_DISALLOW_COPY_ASSIGN(GTiffDataset)\n\n    friend class GTiffBitmapBand;\n    friend class GTiffJPEGOverviewDS;\n    friend class GTiffJPEGOverviewBand;\n    friend class GTiffOddBitsBand;\n    friend class GTiffRasterBand;\n    friend class GTiffRGBABand;\n    friend class GTiffSplitBand;\n    friend class GTiffSplitBitmapBand;\n\n    friend void  GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality );\n    friend void  GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode );\n    friend void  GTIFFSetWebPLevel( GDALDatasetH hGTIFFDS, int nWebPLevel );\n\n    TIFF                 *m_hTIFF = nullptr;\n    VSILFILE             *m_fpL = nullptr;\n    VSILFILE             *m_fpToWrite = nullptr;\n    GTiffDataset        **m_papoOverviewDS = nullptr;\n    GTiffDataset         *m_poMaskDS = nullptr; // For a non-mask dataset, points to the corresponding (internal) mask\n    GDALDataset          *m_poExternalMaskDS = nullptr; // Points to a dataset within m_poMaskExtOvrDS\n    GTiffDataset         *m_poImageryDS = nullptr; // For a mask dataset, points to the corresponding imagery dataset\n    GTiffDataset         *m_poBaseDS = nullptr; // For an overview or mask dataset, points to the root dataset\n    std::unique_ptr\u003cGDALDataset\u003e m_poMaskExtOvrDS{}; // Used with MASK_OVERVIEW_DATASET open option\n    GTiffJPEGOverviewDS **m_papoJPEGOverviewDS = nullptr;\n    GDAL_GCP             *m_pasGCPList = nullptr;\n    GDALColorTable       *m_poColorTable = nullptr;\n    char                **m_papszMetadataFiles = nullptr;\n    GByte                *m_pabyBlockBuf = nullptr;\n    char                **m_papszCreationOptions = nullptr;\n    void                 *m_pabyTempWriteBuffer = nullptr;\n    CPLVirtualMem        *m_pBaseMapping = nullptr;\n    GByte                *m_pTempBufferForCommonDirectIO = nullptr;\n    CPLVirtualMem        *m_psVirtualMemIOMapping = nullptr;\n    std::unique_ptr\u003cCPLJobQueue\u003e m_poCompressQueue{};\n    CPLMutex             *m_hCompressThreadPoolMutex = nullptr;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    lru11::Cache\u003cint, std::pair\u003cvsi_l_offset, vsi_l_offset\u003e\u003e m_oCacheStrileToOffsetByteCount{1024};\n#endif\n\n    MaskOffset* m_panMaskOffsetLsb = nullptr;\n    char       *m_pszVertUnit = nullptr;\n    char       *m_pszFilename = nullptr;\n    char       *m_pszTmpFilename = nullptr;\n    char       *m_pszGeorefFilename = nullptr;\n\n    double      m_adfGeoTransform[6]{0,1,0,0,0,1};\n#if HAVE_LERC\n    double      m_dfMaxZError = 0.0;\n    uint32      m_anLercAddCompressionAndVersion[2]{0,0};\n#endif\n    double      m_dfNoDataValue = -9999.0;\n\n    toff_t      m_nDirOffset = 0;\n\n    int         m_nBlocksPerBand = 0;\n    int         m_nBlockXSize = 0;\n    int         m_nBlockYSize = 0;\n    int         m_nLoadedBlock = -1;  // Or tile, or scanline\n    uint32      m_nRowsPerStrip = 0;\n    int         m_nLastBandRead = -1; // Used for the all-in-on-strip case.\n    int         m_nLastWrittenBlockId = -1; // used for m_bStreamingOut\n    int         m_nRefBaseMapping = 0;\n    int         m_nGCPCount = 0;\n\n    GTIFFKeysFlavorEnum m_eGeoTIFFKeysFlavor = GEOTIFF_KEYS_STANDARD;\n    GeoTIFFVersionEnum m_eGeoTIFFVersion = GEOTIFF_VERSION_AUTO;\n\n    uint16      m_nPlanarConfig = 0;\n    uint16      m_nSamplesPerPixel = 0;\n    uint16      m_nBitsPerSample = 0;\n    uint16      m_nPhotometric = 0;\n    uint16      m_nSampleFormat = 0;\n    uint16      m_nCompression = 0;\n\n    signed char m_nOverviewCount = 0;\n\n    // If \u003e 0, the implicit JPEG overviews are visible through\n    // GetOverviewCount().\n    signed char m_nJPEGOverviewVisibilityCounter = 0;\n    // Currently visible overviews. Generally == nJPEGOverviewCountOri.\n    signed char m_nJPEGOverviewCount = -1;\n    signed char m_nJPEGOverviewCountOri = 0;  // Size of papoJPEGOverviewDS.\n    signed char m_nPAMGeorefSrcIndex = -1;\n    signed char m_nINTERNALGeorefSrcIndex = -1;\n    signed char m_nTABFILEGeorefSrcIndex = -1;\n    signed char m_nWORLDFILEGeorefSrcIndex = -1;\n    signed char m_nGeoTransformGeorefSrcIndex = -1;\n\n    signed char m_nHasOptimizedReadMultiRange = -1;\n\n    signed char m_nZLevel = -1;\n    signed char m_nLZMAPreset = -1;\n    signed char m_nZSTDLevel = -1;\n    signed char m_nWebPLevel = -1;\n    signed char m_nJpegQuality = -1;\n    signed char m_nJpegTablesMode = -1;\n\n    enum class VirtualMemIOEnum: GByte\n    {\n        NO,\n        YES,\n        IF_ENOUGH_RAM\n    };\n\n    VirtualMemIOEnum m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n\n    GTiffProfile m_eProfile = GTiffProfile::GDALGEOTIFF;\n\n    OGRSpatialReference m_oSRS{};\n\n    GDALMultiDomainMetadata m_oGTiffMDMD{};\n\n    std::vector\u003cGTiffCompressionJob\u003e m_asCompressionJobs{};\n    std::queue\u003cint\u003e m_asQueueJobIdx{}; // queue of index of m_asCompressionJobs being compressed in worker threads\n\n    bool        m_bStreamingIn:1;\n    bool        m_bStreamingOut:1;\n    bool        m_bScanDeferred:1;\n    bool        m_bSingleIFDOpened = false;\n    bool        m_bLoadedBlockDirty:1;\n    bool        m_bWriteError:1;\n    bool        m_bLookedForProjection:1;\n    bool        m_bLookedForMDAreaOrPoint:1;\n    bool        m_bGeoTransformValid:1;\n    bool        m_bCrystalized:1;\n    bool        m_bGeoTIFFInfoChanged:1;\n    bool        m_bForceUnsetGTOrGCPs:1;\n    bool        m_bForceUnsetProjection:1;\n    bool        m_bNoDataChanged:1;\n    bool        m_bNoDataSet:1;\n    bool        m_bMetadataChanged:1;\n    bool        m_bColorProfileMetadataChanged:1;\n    bool        m_bForceUnsetRPC:1;\n    bool        m_bNeedsRewrite:1;\n    bool        m_bLoadingOtherBands:1;\n    bool        m_bIsOverview:1;\n    bool        m_bWriteEmptyTiles:1;\n    bool        m_bFillEmptyTilesAtClosing:1;\n    bool        m_bTreatAsSplit:1;\n    bool        m_bTreatAsSplitBitmap:1;\n    bool        m_bClipWarn:1;\n    bool        m_bIMDRPCMetadataLoaded:1;\n    bool        m_bEXIFMetadataLoaded:1;\n    bool        m_bICCMetadataLoaded:1;\n    bool        m_bHasWarnedDisableAggressiveBandCaching:1;\n    bool        m_bDontReloadFirstBlock:1;  // Hack for libtiff 3.X and #3633.\n    bool        m_bWebPLossless:1;\n    bool        m_bPromoteTo8Bits:1;\n    bool        m_bDebugDontWriteBlocks:1;\n    bool        m_bIsFinalized:1;\n    bool        m_bIgnoreReadErrors:1;\n    bool        m_bDirectIO:1;\n    bool        m_bReadGeoTransform:1;\n    bool        m_bLoadPam:1;\n    bool        m_bHasGotSiblingFiles:1;\n    bool        m_bHasIdentifiedAuthorizedGeoreferencingSources:1;\n    bool        m_bLayoutIFDSBeforeData:1;\n    bool        m_bBlockOrderRowMajor:1;\n    bool        m_bLeaderSizeAsUInt4:1;\n    bool        m_bTrailerRepeatedLast4BytesRepeated:1;\n    bool        m_bMaskInterleavedWithImagery:1;\n    bool        m_bKnownIncompatibleEdition:1;\n    bool        m_bWriteKnownIncompatibleEdition:1;\n    bool        m_bHasUsedReadEncodedAPI:1; // for debugging\n    bool        m_bWriteCOGLayout:1;\n\n    void        ScanDirectories();\n    bool        ReadStrile(int nBlockId,\n                           void* pOutputBuffer, GPtrDiff_t nBlockReqSize);\n    CPLErr      LoadBlockBuf( int nBlockId, bool bReadFromDisk = true );\n    CPLErr      FlushBlockBuf();\n\n    void        LoadMDAreaOrPoint();\n    void        LookForProjection();\n#ifdef ESRI_BUILD\n    void        AdjustLinearUnit( short UOMLength );\n#endif\n\n    void        Crystalize();  // TODO: Spelling.\n    void        RestoreVolatileParameters(TIFF* hTIFF);\n\n    void        WriteGeoTIFFInfo();\n    bool        SetDirectory();\n    void        ReloadDirectory();\n\n    int         GetJPEGOverviewCount();\n\n    bool        IsBlockAvailable( int nBlockId,\n                                  vsi_l_offset* pnOffset = nullptr,\n                                  vsi_l_offset* pnSize = nullptr,\n                                  bool *pbErrOccurred = nullptr );\n\n    void        ApplyPamInfo();\n    void        PushMetadataToPam();\n\n    bool         WriteEncodedTile( uint32 tile, GByte* pabyData,\n                                   int bPreserveDataBuffer );\n    bool         WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                    int bPreserveDataBuffer );\n    template\u003cclass T\u003e\n    bool         HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents ) const;\n    bool         HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents );\n    inline bool  IsFirstPixelEqualToNoData( const void* pBuffer );\n\n    void         FillEmptyTiles();\n\n    void         FlushDirectory();\n    CPLErr       CleanOverviews();\n\n    void          LoadMetadata();\n    void          LoadEXIFMetadata();\n    void          LoadICCProfile();\n\n    CPLErr        RegisterNewOverviewDataset( toff_t nOverviewOffset, int l_nJpegQuality,\n                                              int l_nWebPLevel );\n    CPLErr        CreateOverviewsFromSrcOverviews( GDALDataset* poSrcDS,\n                                                   GDALDataset* poOvrDS );\n    CPLErr        CreateInternalMaskOverviews( int nOvrBlockXSize,\n                                               int nOvrBlockYSize );\n    int           Finalize();\n\n    void           DiscardLsb(GByte* pabyBuffer, GPtrDiff_t nBytes, int iBand) const;\n    void           GetDiscardLsbOption( char** papszOptions );\n    void           InitCompressionThreads( char** papszOptions );\n    void           InitCreationOrOpenOptions( char** papszOptions );\n    static void    ThreadCompressionFunc( void* pData );\n    void           WaitCompletionForJobIdx( int i );\n    void           WaitCompletionForBlock( int nBlockId );\n    void           WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        GPtrDiff_t nCompressedBufferSize );\n    bool           SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         GPtrDiff_t cc, int nHeight) ;\n\n    int            GuessJPEGQuality( bool\u0026 bOutHasQuantizationTable,\n                                     bool\u0026 bOutHasHuffmanTable );\n\n    void           SetJPEGQualityAndTablesModeFromFile();\n\n    int            DirectIO( GDALRWFlag eRWFlag,\n                             int nXOff, int nYOff, int nXSize, int nYSize,\n                             void * pData, int nBufXSize, int nBufYSize,\n                             GDALDataType eBufType,\n                             int nBandCount, int *panBandMap,\n                             GSpacing nPixelSpace, GSpacing nLineSpace,\n                             GSpacing nBandSpace,\n                             GDALRasterIOExtraArg* psExtraArg );\n\n    int            VirtualMemIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 int nBandCount, int *panBandMap,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GSpacing nBandSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    void            SetStructuralMDFromParent(GTiffDataset* poParentDS);\n\n    template\u003cclass FetchBuffer\u003e CPLErr CommonDirectIO(\n        FetchBuffer\u0026 oFetcher,\n        int nXOff, int nYOff, int nXSize, int nYSize,\n        void * pData, int nBufXSize, int nBufYSize,\n        GDALDataType eBufType,\n        int nBandCount, int *panBandMap,\n        GSpacing nPixelSpace, GSpacing nLineSpace,\n        GSpacing nBandSpace );\n\n    void        LoadGeoreferencingAndPamIfNeeded();\n\n    char      **GetSiblingFiles();\n\n    void        IdentifyAuthorizedGeoreferencingSources();\n\n    void        FlushCacheInternal( bool bFlushDirectory );\n    bool        HasOptimizedReadMultiRange();\n\n    bool        AssociateExternalMask();\n\n    static bool MustCreateInternalMask();\n\n    static CPLErr CopyImageryAndMask(GTiffDataset* poDstDS,\n                                     GDALDataset* poSrcDS,\n                                     GDALRasterBand* poSrcMaskBand,\n                                     GDALProgressFunc pfnProgress,\n                                     void * pProgressData);\n\n  protected:\n    virtual int         CloseDependentDatasets() override;\n\n  public:\n             GTiffDataset();\n    virtual ~GTiffDataset();\n\n    const OGRSpatialReference* GetSpatialRef() const override;\n    CPLErr SetSpatialRef(const OGRSpatialReference* poSRS) override;\n\n    virtual CPLErr GetGeoTransform( double * ) override;\n    virtual CPLErr SetGeoTransform( double * ) override;\n\n    virtual int    GetGCPCount() override;\n    const OGRSpatialReference* GetGCPSpatialRef() const override;\n    virtual const GDAL_GCP *GetGCPs() override;\n    CPLErr SetGCPs( int nGCPCountIn, const GDAL_GCP *pasGCPListIn,\n                    const OGRSpatialReference* poSRS ) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n    virtual char **GetFileList() override;\n\n    virtual CPLErr IBuildOverviews( const char *, int, int *, int, int *,\n                                    GDALProgressFunc, void * ) override;\n\n    CPLErr         OpenOffset( TIFF *,\n                               toff_t nDirOffset, GDALAccess,\n                               bool bAllowRGBAInterface = true,\n                               bool bReadGeoTransform = false );\n\n    static GDALDataset *OpenDir( GDALOpenInfo * );\n    static GDALDataset *Open( GDALOpenInfo * );\n    static int          Identify( GDALOpenInfo * );\n    static GDALDataset *Create( const char * pszFilename,\n                                int nXSize, int nYSize, int nBands,\n                                GDALDataType eType, char ** papszParmList );\n    static GDALDataset *CreateCopy( const char * pszFilename,\n                                    GDALDataset *poSrcDS,\n                                    int bStrict, char ** papszOptions,\n                                    GDALProgressFunc pfnProgress,\n                                    void * pProgressData );\n    virtual void    FlushCache() override;\n\n    virtual char  **GetMetadataDomainList() override;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override;\n    virtual const char *GetMetadataItem( const char * pszName,\n                                         const char * pszDomain = \"\" ) override;\n    virtual void   *GetInternalHandle( const char * ) override;\n\n    virtual CPLErr          CreateMaskBand( int nFlags ) override;\n\n    bool GetRawBinaryLayout(GDALDataset::RawBinaryLayout\u0026) override;\n\n    // Only needed by createcopy and close code.\n    static void     WriteRPC( GDALDataset *, TIFF *, int, GTiffProfile, \n                              const char *, char **,\n                              bool bWriteOnlyInPAMIfNeeded = false );\n    static bool     WriteMetadata( GDALDataset *, TIFF *, bool, GTiffProfile,\n                                   const char *, char **,\n                                   bool bExcludeRPBandIMGFileWriting = false );\n    static void     WriteNoDataValue( TIFF *, double );\n    static void     UnsetNoDataValue( TIFF * );\n\n    static TIFF *   CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString\u0026 osTmpFilename );\n\n    CPLErr   WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                      int bPreserveDataBuffer );\n\n    static void SaveICCProfile( GTiffDataset *pDS, TIFF *hTIFF,\n                                char **papszParmList, uint32 nBitsPerSample );\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                        GTiffJPEGOverviewDS                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffJPEGOverviewDS final : public GDALDataset\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffJPEGOverviewDS)\n\n    friend class GTiffJPEGOverviewBand;\n    GTiffDataset* m_poParentDS = nullptr;\n    int           m_nOverviewLevel = 0;\n\n    int        m_nJPEGTableSize = 0;\n    GByte     *m_pabyJPEGTable = nullptr;\n    CPLString  m_osTmpFilenameJPEGTable{};\n\n    CPLString    m_osTmpFilename{};\n    GDALDataset* m_poJPEGDS = nullptr;\n    // Valid block id of the parent DS that match poJPEGDS.\n    int          m_nBlockId = -1;\n\n  public:\n    GTiffJPEGOverviewDS( GTiffDataset* poParentDS, int nOverviewLevel,\n                         const void* pJPEGTable, int nJPEGTableSize );\n    virtual ~GTiffJPEGOverviewDS();\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n};\n\nclass GTiffJPEGOverviewBand final : public GDALRasterBand\n{\n  public:\n    GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDS, int nBand );\n    virtual ~GTiffJPEGOverviewBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::GTiffJPEGOverviewDS( GTiffDataset* poParentDSIn,\n                                          int nOverviewLevelIn,\n                                          const void* pJPEGTable,\n                                          int nJPEGTableSizeIn ) :\n    m_poParentDS(poParentDSIn),\n    m_nOverviewLevel(nOverviewLevelIn),\n    m_nJPEGTableSize(nJPEGTableSizeIn)\n{\n    ShareLockWithParentDataset(poParentDSIn);\n\n    m_osTmpFilenameJPEGTable.Printf(\"/vsimem/jpegtable_%p\", this);\n\n    const GByte abyAdobeAPP14RGB[] = {\n        0xFF, 0xEE, 0x00, 0x0E, 0x41, 0x64, 0x6F, 0x62, 0x65, 0x00,\n        0x64, 0x00, 0x00, 0x00, 0x00, 0x00 };\n    const bool bAddAdobe =\n        m_poParentDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        m_poParentDS-\u003em_nPhotometric != PHOTOMETRIC_YCBCR \u0026\u0026\n        m_poParentDS-\u003enBands == 3;\n    m_pabyJPEGTable =\n        static_cast\u003cGByte*\u003e( CPLMalloc(\n            m_nJPEGTableSize + (bAddAdobe ? sizeof(abyAdobeAPP14RGB) : 0)) );\n    memcpy(m_pabyJPEGTable, pJPEGTable, m_nJPEGTableSize);\n    if( bAddAdobe )\n    {\n        memcpy( m_pabyJPEGTable + m_nJPEGTableSize, abyAdobeAPP14RGB,\n                sizeof(abyAdobeAPP14RGB) );\n        m_nJPEGTableSize += sizeof(abyAdobeAPP14RGB);\n    }\n    CPL_IGNORE_RET_VAL(\n        VSIFCloseL(\n            VSIFileFromMemBuffer(\n                m_osTmpFilenameJPEGTable, m_pabyJPEGTable, m_nJPEGTableSize, TRUE )));\n\n    const int nScaleFactor = 1 \u003c\u003c m_nOverviewLevel;\n    nRasterXSize = (m_poParentDS-\u003enRasterXSize + nScaleFactor - 1) / nScaleFactor;\n    nRasterYSize = (m_poParentDS-\u003enRasterYSize + nScaleFactor - 1) / nScaleFactor;\n\n    for( int i = 1; i \u003c= m_poParentDS-\u003enBands; ++i )\n        SetBand(i, new GTiffJPEGOverviewBand(this, i));\n\n    SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    if( m_poParentDS-\u003em_nPhotometric == PHOTOMETRIC_YCBCR )\n        SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n}\n\n/************************************************************************/\n/*                       ~GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::~GTiffJPEGOverviewDS()\n{\n    if( m_poJPEGDS != nullptr )\n        GDALClose( m_poJPEGDS );\n    VSIUnlink(m_osTmpFilenameJPEGTable);\n    if( !m_osTmpFilename.empty() )\n        VSIUnlink(m_osTmpFilename);\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewDS::IRasterIO(\n    GDALRWFlag eRWFlag,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace,\n    GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // For non-single strip JPEG-IN-TIFF, the block based strategy will\n    // be the most efficient one, to avoid decompressing the JPEG content\n    // for each requested band.\n    if( nBandCount \u003e 1 \u0026\u0026 m_poParentDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        (m_poParentDS-\u003em_nBlockXSize \u003c m_poParentDS-\u003enRasterXSize ||\n         m_poParentDS-\u003em_nBlockYSize \u003e 1) )\n    {\n        return BlockBasedRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                   pData, nBufXSize, nBufYSize,\n                                   eBufType, nBandCount, panBandMap,\n                                   nPixelSpace, nLineSpace, nBandSpace,\n                                   psExtraArg );\n    }\n\n    return GDALDataset::IRasterIO(\n        eRWFlag, nXOff, nYOff, nXSize, nYSize,\n        pData, nBufXSize, nBufYSize, eBufType,\n        nBandCount, panBandMap, nPixelSpace, nLineSpace, nBandSpace,\n        psExtraArg );\n}\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewBand()                       */\n/************************************************************************/\n\nGTiffJPEGOverviewBand::GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDSIn,\n                                              int nBandIn )\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n    eDataType =\n        poDSIn-\u003em_poParentDS-\u003eGetRasterBand(nBandIn)-\u003eGetRasterDataType();\n    poDSIn-\u003em_poParentDS-\u003eGetRasterBand(nBandIn)-\u003e\n        GetBlockSize(\u0026nBlockXSize, \u0026nBlockYSize);\n    const int nScaleFactor = 1 \u003c\u003c poDSIn-\u003em_nOverviewLevel;\n    nBlockXSize = (nBlockXSize + nScaleFactor - 1) / nScaleFactor;\n    nBlockYSize = (nBlockYSize + nScaleFactor - 1) / nScaleFactor;\n}\n\n/************************************************************************/\n/*                          IReadBlock()                                */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                          void *pImage )\n{\n    GTiffJPEGOverviewDS* m_poGDS = cpl::down_cast\u003cGTiffJPEGOverviewDS *\u003e(poDS);\n\n    // Compute the source block ID.\n    int nBlockId = 0;\n    int nParentBlockXSize, nParentBlockYSize;\n    m_poGDS-\u003em_poParentDS-\u003eGetRasterBand(1)-\u003e\n        GetBlockSize(\u0026nParentBlockXSize, \u0026nParentBlockYSize);\n    const bool bIsSingleStripAsSplit = (nParentBlockYSize == 1 \u0026\u0026\n                           m_poGDS-\u003em_poParentDS-\u003em_nBlockYSize != nParentBlockYSize);\n    if( !bIsSingleStripAsSplit )\n    {\n        int l_nBlocksPerRow = DIV_ROUND_UP(m_poGDS-\u003em_poParentDS-\u003enRasterXSize,\n                                               m_poGDS-\u003em_poParentDS-\u003em_nBlockXSize);\n        nBlockId = nBlockYOff * l_nBlocksPerRow + nBlockXOff;\n    }\n    if( m_poGDS-\u003em_poParentDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        nBlockId += (nBand-1) * m_poGDS-\u003em_poParentDS-\u003em_nBlocksPerBand;\n    }\n\n    // Make sure it is available.\n    const int nDataTypeSize = GDALGetDataTypeSizeBytes(eDataType);\n    vsi_l_offset nOffset = 0;\n    vsi_l_offset nByteCount = 0;\n    bool bErrOccurred = false;\n    if( !m_poGDS-\u003em_poParentDS-\u003eIsBlockAvailable(nBlockId, \u0026nOffset, \u0026nByteCount, \u0026bErrOccurred) )\n    {\n        memset(pImage, 0, static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize * nDataTypeSize );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    const int nScaleFactor = 1 \u003c\u003c m_poGDS-\u003em_nOverviewLevel;\n    if( m_poGDS-\u003em_poJPEGDS == nullptr || nBlockId != m_poGDS-\u003em_nBlockId )\n    {\n        if( nByteCount \u003c 2 )\n            return CE_Failure;\n        nOffset += 2;  // Skip leading 0xFF 0xF8.\n        nByteCount -= 2;\n\n        // Special case for last strip that might be smaller than other strips\n        // In which case we must invalidate the dataset.\n        TIFF* hTIFF = m_poGDS-\u003em_poParentDS-\u003em_hTIFF;\n        if( !TIFFIsTiled( hTIFF ) \u0026\u0026 !bIsSingleStripAsSplit \u0026\u0026\n            (nBlockYOff + 1 ==\n                 DIV_ROUND_UP( m_poGDS-\u003em_poParentDS-\u003enRasterYSize,\n                               m_poGDS-\u003em_poParentDS-\u003em_nBlockYSize ) ||\n             (m_poGDS-\u003em_poJPEGDS != nullptr \u0026\u0026\n              m_poGDS-\u003em_poJPEGDS-\u003eGetRasterYSize() !=\n              nBlockYSize * nScaleFactor)) )\n        {\n            if( m_poGDS-\u003em_poJPEGDS != nullptr )\n                GDALClose( m_poGDS-\u003em_poJPEGDS );\n            m_poGDS-\u003em_poJPEGDS = nullptr;\n        }\n\n        CPLString osFileToOpen;\n        m_poGDS-\u003em_osTmpFilename.Printf(\"/vsimem/sparse_%p\", m_poGDS);\n        VSILFILE* fp = VSIFOpenL(m_poGDS-\u003em_osTmpFilename, \"wb+\");\n\n        // If the size of the JPEG strip/tile is small enough, we will\n        // read it from the TIFF file and forge a in-memory JPEG file with\n        // the JPEG table followed by the JPEG data.\n        const bool bInMemoryJPEGFile = nByteCount \u003c 256 * 256;\n        if( bInMemoryJPEGFile )\n        {\n            // If the previous file was opened as a /vsisparse/, must re-open.\n            if( m_poGDS-\u003em_poJPEGDS != nullptr \u0026\u0026\n                STARTS_WITH(m_poGDS-\u003em_poJPEGDS-\u003eGetDescription(), \"/vsisparse/\") )\n            {\n                GDALClose( m_poGDS-\u003em_poJPEGDS );\n                m_poGDS-\u003em_poJPEGDS = nullptr;\n            }\n            osFileToOpen = m_poGDS-\u003em_osTmpFilename;\n\n            bool bError = false;\n            if( VSIFSeekL(fp, m_poGDS-\u003em_nJPEGTableSize + nByteCount - 1, SEEK_SET)\n                != 0 )\n                bError = true;\n            char ch = 0;\n            if( !bError \u0026\u0026 VSIFWriteL(\u0026ch, 1, 1, fp) != 1 )\n                bError = true;\n            GByte* pabyBuffer =\n                VSIGetMemFileBuffer( m_poGDS-\u003em_osTmpFilename, nullptr, FALSE);\n            memcpy(pabyBuffer, m_poGDS-\u003em_pabyJPEGTable, m_poGDS-\u003em_nJPEGTableSize);\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            if( !bError \u0026\u0026 VSIFSeekL(fpTIF, nOffset, SEEK_SET) != 0 )\n                bError = true;\n            if( VSIFReadL( pabyBuffer + m_poGDS-\u003em_nJPEGTableSize,\n                           static_cast\u003csize_t\u003e(nByteCount), 1, fpTIF) != 1 )\n                bError = true;\n            if( bError )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        else\n        {\n            // If the JPEG strip/tile is too big (e.g. a single-strip\n            // JPEG-in-TIFF), we will use /vsisparse mechanism to make a\n            // fake JPEG file.\n\n            // Always re-open.\n            GDALClose( m_poGDS-\u003em_poJPEGDS );\n            m_poGDS-\u003em_poJPEGDS = nullptr;\n\n            osFileToOpen =\n                CPLSPrintf(\"/vsisparse/%s\", m_poGDS-\u003em_osTmpFilename.c_str());\n\n            if( VSIFPrintfL(\n                    fp,\n                    \"\u003cVSISparseFile\u003e\u003cSubfileRegion\u003e\"\n                    \"\u003cFilename relative='0'\u003e%s\u003c/Filename\u003e\"\n                    \"\u003cDestinationOffset\u003e0\u003c/DestinationOffset\u003e\"\n                    \"\u003cSourceOffset\u003e0\u003c/SourceOffset\u003e\"\n                    \"\u003cRegionLength\u003e%d\u003c/RegionLength\u003e\"\n                    \"\u003c/SubfileRegion\u003e\"\n                    \"\u003cSubfileRegion\u003e\"\n                    \"\u003cFilename relative='0'\u003e%s\u003c/Filename\u003e\"\n                    \"\u003cDestinationOffset\u003e%d\u003c/DestinationOffset\u003e\"\n                    \"\u003cSourceOffset\u003e\" CPL_FRMT_GUIB \"\u003c/SourceOffset\u003e\"\n                    \"\u003cRegionLength\u003e\" CPL_FRMT_GUIB \"\u003c/RegionLength\u003e\"\n                    \"\u003c/SubfileRegion\u003e\u003c/VSISparseFile\u003e\",\n                    m_poGDS-\u003em_osTmpFilenameJPEGTable.c_str(),\n                    static_cast\u003cint\u003e(m_poGDS-\u003em_nJPEGTableSize),\n                    m_poGDS-\u003em_poParentDS-\u003eGetDescription(),\n                    static_cast\u003cint\u003e(m_poGDS-\u003em_nJPEGTableSize),\n                    nOffset,\n                    nByteCount) \u003c 0 )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n\n        if( m_poGDS-\u003em_poJPEGDS == nullptr )\n        {\n            const char* apszDrivers[] = { \"JPEG\", nullptr };\n\n            CPLString osOldVal;\n            if( m_poGDS-\u003em_poParentDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n                m_poGDS-\u003enBands == 4 )\n            {\n                osOldVal =\n                    CPLGetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"\");\n                CPLSetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"NO\");\n            }\n\n            m_poGDS-\u003em_poJPEGDS =\n                static_cast\u003cGDALDataset *\u003e( GDALOpenEx(\n                    osFileToOpen,\n                    GDAL_OF_RASTER | GDAL_OF_INTERNAL,\n                    apszDrivers, nullptr, nullptr) );\n\n            if( m_poGDS-\u003em_poJPEGDS != nullptr )\n            {\n                // Force all implicit overviews to be available, even for\n                // small tiles.\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               \"YES\");\n                GDALGetOverviewCount(GDALGetRasterBand(m_poGDS-\u003em_poJPEGDS, 1));\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               nullptr);\n\n                m_poGDS-\u003em_nBlockId = nBlockId;\n            }\n\n            if( m_poGDS-\u003em_poParentDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n                m_poGDS-\u003enBands == 4 )\n            {\n                CPLSetThreadLocalConfigOption(\n                    \"GDAL_JPEG_TO_RGB\",\n                    !osOldVal.empty() ? osOldVal.c_str() : nullptr );\n            }\n        }\n        else\n        {\n            // Trick: we invalidate the JPEG dataset to force a reload\n            // of the new content.\n            CPLErrorReset();\n            m_poGDS-\u003em_poJPEGDS-\u003eFlushCache();\n            if( CPLGetLastErrorNo() != 0 )\n            {\n                GDALClose( m_poGDS-\u003em_poJPEGDS );\n                m_poGDS-\u003em_poJPEGDS = nullptr;\n                return CE_Failure;\n            }\n            m_poGDS-\u003em_nBlockId = nBlockId;\n        }\n    }\n\n    CPLErr eErr = CE_Failure;\n    if( m_poGDS-\u003em_poJPEGDS )\n    {\n        GDALDataset* l_poDS = m_poGDS-\u003em_poJPEGDS;\n\n        int nReqXOff = 0;\n        int nReqYOff = 0;\n        int nReqXSize = 0;\n        int nReqYSize = 0;\n        if( bIsSingleStripAsSplit )\n        {\n            nReqYOff = nBlockYOff * nScaleFactor;\n            nReqXSize = l_poDS-\u003eGetRasterXSize();\n            nReqYSize = nScaleFactor;\n        }\n        else\n        {\n            if( nBlockXSize == m_poGDS-\u003eGetRasterXSize() )\n            {\n                nReqXSize = l_poDS-\u003eGetRasterXSize();\n            }\n            else\n            {\n                nReqXSize = nBlockXSize * nScaleFactor;\n            }\n            nReqYSize = nBlockYSize * nScaleFactor;\n        }\n        int nBufXSize = nBlockXSize;\n        int nBufYSize = nBlockYSize;\n        if( nBlockXOff == DIV_ROUND_UP(m_poGDS-\u003em_poParentDS-\u003enRasterXSize,\n                                       m_poGDS-\u003em_poParentDS-\u003em_nBlockXSize) - 1 )\n        {\n            nReqXSize = m_poGDS-\u003em_poParentDS-\u003enRasterXSize -\n                                nBlockXOff * m_poGDS-\u003em_poParentDS-\u003em_nBlockXSize;\n        }\n        if( nReqXOff + nReqXSize \u003e l_poDS-\u003eGetRasterXSize() )\n        {\n            nReqXSize = l_poDS-\u003eGetRasterXSize() - nReqXOff;\n        }\n        if( !bIsSingleStripAsSplit \u0026\u0026\n            nBlockYOff == DIV_ROUND_UP(m_poGDS-\u003em_poParentDS-\u003enRasterYSize,\n                                       m_poGDS-\u003em_poParentDS-\u003em_nBlockYSize) - 1 )\n        {\n            nReqYSize = m_poGDS-\u003em_poParentDS-\u003enRasterYSize -\n                                nBlockYOff * m_poGDS-\u003em_poParentDS-\u003em_nBlockYSize;\n        }\n        if( nReqYOff + nReqYSize \u003e l_poDS-\u003eGetRasterYSize() )\n        {\n            nReqYSize = l_poDS-\u003eGetRasterYSize() - nReqYOff;\n        }\n        if( nBlockXOff * nBlockXSize \u003e m_poGDS-\u003eGetRasterXSize() - nBufXSize )\n        {\n            memset(pImage, 0, static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize * nDataTypeSize);\n            nBufXSize = m_poGDS-\u003eGetRasterXSize() - nBlockXOff * nBlockXSize;\n        }\n        if( nBlockYOff * nBlockYSize \u003e m_poGDS-\u003eGetRasterYSize() - nBufYSize )\n        {\n            memset(pImage, 0, static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize * nDataTypeSize);\n            nBufYSize = m_poGDS-\u003eGetRasterYSize() - nBlockYOff * nBlockYSize;\n        }\n\n        const int nSrcBand =\n            m_poGDS-\u003em_poParentDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            1 : nBand;\n        if( nSrcBand \u003c= l_poDS-\u003eGetRasterCount() )\n        {\n            eErr = l_poDS-\u003eGetRasterBand(nSrcBand)-\u003eRasterIO(GF_Read,\n                                 nReqXOff, nReqYOff, nReqXSize, nReqYSize,\n                                 pImage,\n                                 nBufXSize, nBufYSize, eDataType,\n                                 0, static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nDataTypeSize, nullptr );\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        GTIFFSetJpegQuality()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg quality on the IFD   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast\u003cGTiffDataset *\u003e(hGTIFFDS);\n    poDS-\u003em_nJpegQuality = static_cast\u003csigned char\u003e(nJpegQuality);\n\n    poDS-\u003eScanDirectories();\n\n    for( int i = 0; i \u003c poDS-\u003em_nOverviewCount; ++i )\n        poDS-\u003em_papoOverviewDS[i]-\u003em_nJpegQuality = poDS-\u003em_nJpegQuality;\n}\n\n/************************************************************************/\n/*                        GTIFFSetWebPLevel()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg quality on the IFD   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetWebPLevel( GDALDatasetH hGTIFFDS, int nWebpLevel )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast\u003cGTiffDataset *\u003e(hGTIFFDS);\n    poDS-\u003em_nWebPLevel = static_cast\u003csigned char\u003e(nWebpLevel);\n\n    poDS-\u003eScanDirectories();\n\n    for( int i = 0; i \u003c poDS-\u003em_nOverviewCount; ++i )\n        poDS-\u003em_papoOverviewDS[i]-\u003em_nWebPLevel = poDS-\u003em_nWebPLevel;\n}\n\n/************************************************************************/\n/*                     GTIFFSetJpegTablesMode()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg tables mode on the   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast\u003cGTiffDataset *\u003e(hGTIFFDS);\n    poDS-\u003em_nJpegTablesMode = static_cast\u003csigned char\u003e(nJpegTablesMode);\n\n    poDS-\u003eScanDirectories();\n\n    for( int i = 0; i \u003c poDS-\u003em_nOverviewCount; ++i )\n        poDS-\u003em_papoOverviewDS[i]-\u003em_nJpegTablesMode = poDS-\u003em_nJpegTablesMode;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffRasterBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRasterBand CPL_NON_FINAL: public GDALPamRasterBand\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffRasterBand)\n\n    friend class GTiffDataset;\n\n    double             m_dfOffset = 0;\n    double             m_dfScale = 1;\n    CPLString          m_osUnitType{};\n    CPLString          m_osDescription{};\n    GDALColorInterp    m_eBandInterp = GCI_Undefined;\n    std::set\u003cGTiffRasterBand **\u003e m_aSetPSelf{};\n    bool               m_bHaveOffsetScale = false;\n\n    int                DirectIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    static void     DropReferenceVirtualMem( void* pUserData );\n    CPLVirtualMem * GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions );\n\n    void*           CacheMultiRange( int nXOff, int nYOff,\n                                     int nXSize, int nYSize,\n                                     int nBufXSize, int nBufYSize,\n                                     GDALRasterIOExtraArg* psExtraArg );\n\nprotected:\n    GTiffDataset       *m_poGDS = nullptr;\n    GDALMultiDomainMetadata m_oGTiffMDMD{};\n\n    double             m_dfNoDataValue = -9999.0;\n    bool               m_bNoDataSet = false;\n\n    void NullBlock( void *pData );\n    CPLErr FillCacheForOtherBands( int nBlockXOff, int nBlockYOff );\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    void CacheMaskForBlock( int nBlockXOff, int nBlockYOff );\n#endif\n\npublic:\n             GTiffRasterBand( GTiffDataset *, int );\n    virtual ~GTiffRasterBand();\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override final;\n\n    virtual const char *GetDescription() const override final;\n    virtual void        SetDescription( const char * ) override final;\n\n    virtual GDALColorInterp GetColorInterpretation() override /*final*/;\n    virtual GDALColorTable *GetColorTable() override /*final*/;\n    virtual CPLErr          SetColorTable( GDALColorTable * ) override final;\n    virtual double          GetNoDataValue( int * ) override final;\n    virtual CPLErr          SetNoDataValue( double ) override final;\n    virtual CPLErr DeleteNoDataValue() override final;\n\n    virtual double GetOffset( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetOffset( double dfNewValue ) override final;\n    virtual double GetScale( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetScale( double dfNewValue ) override final;\n    virtual const char* GetUnitType() override final;\n    virtual CPLErr SetUnitType( const char *pszNewValue ) override final;\n    virtual CPLErr SetColorInterpretation( GDALColorInterp ) override final;\n\n    virtual char      **GetMetadataDomainList() override final;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override final;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override final;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override final;\n    virtual const char *GetMetadataItem(\n        const char * pszName, const char * pszDomain = \"\" ) override final;\n    virtual int    GetOverviewCount()  override final;\n    virtual GDALRasterBand *GetOverview( int ) override final;\n\n    virtual GDALRasterBand *GetMaskBand() override final;\n    virtual int             GetMaskFlags() override final;\n    virtual CPLErr          CreateMaskBand( int nFlags )  override final;\n\n    virtual CPLVirtualMem  *GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions )  override final;\n\n    GDALRasterAttributeTable* GetDefaultRAT() override final;\n    virtual CPLErr  GetHistogram(\n        double dfMin, double dfMax,\n        int nBuckets, GUIntBig * panHistogram,\n        int bIncludeOutOfRange, int bApproxOK,\n        GDALProgressFunc, void *pProgressData )  override final;\n\n    virtual CPLErr GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                        int *pnBuckets,\n                                        GUIntBig ** ppanHistogram,\n                                        int bForce,\n                                        GDALProgressFunc,\n                                        void *pProgressData)  override final;\n};\n\n/************************************************************************/\n/*                           GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::GTiffRasterBand( GTiffDataset *poDSIn, int nBandIn ):\n    m_poGDS(poDSIn)\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n\n/* -------------------------------------------------------------------- */\n/*      Get the GDAL data type.                                         */\n/* -------------------------------------------------------------------- */\n    const uint16 nBitsPerSample = m_poGDS-\u003em_nBitsPerSample;\n    const uint16 nSampleFormat = m_poGDS-\u003em_nSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if( nBitsPerSample \u003c= 8 )\n    {\n        eDataType = GDT_Byte;\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            m_oGTiffMDMD.SetMetadataItem( \"PIXELTYPE\", \"SIGNEDBYTE\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nBitsPerSample \u003c= 16 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if( nBitsPerSample == 32 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt16;\n        else if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float32;\n        else if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if( nBitsPerSample == 64 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float64;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat32;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt32;\n    }\n    else if( nBitsPerSample == 128 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat64;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try to work out band color interpretation.                      */\n/* -------------------------------------------------------------------- */\n    bool bLookForExtraSamples = false;\n\n    if( m_poGDS-\u003em_poColorTable != nullptr \u0026\u0026 nBand == 1 )\n    {\n        m_eBandInterp = GCI_PaletteIndex;\n    }\n    else if( m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_RGB\n             || (m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_YCBCR\n                 \u0026\u0026 m_poGDS-\u003em_nCompression == COMPRESSION_JPEG\n                 \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                    \"YES\") )) )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_RedBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_GreenBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_BlueBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_YCbCr_YBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_YCbCr_CbBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_YCbCr_CrBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_SEPARATED )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_CyanBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_MagentaBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_YellowBand;\n        else if( nBand == 4 )\n            m_eBandInterp = GCI_BlackBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_MINISBLACK \u0026\u0026 nBand == 1 )\n    {\n        m_eBandInterp = GCI_GrayIndex;\n    }\n    else\n    {\n        bLookForExtraSamples = true;\n    }\n\n    if( bLookForExtraSamples )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( m_poGDS-\u003em_hTIFF, TIFFTAG_EXTRASAMPLES, \u0026count, \u0026v ) )\n        {\n            const int nBaseSamples = m_poGDS-\u003em_nSamplesPerPixel - count;\n            const int nExpectedBaseSamples =\n                (m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_MINISBLACK) ? 1 :\n                (m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_MINISWHITE) ? 1 :\n                (m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_RGB) ? 3 :\n                (m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_YCBCR) ? 3 :\n                (m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_SEPARATED) ? 4 : 0;\n\n            if( nExpectedBaseSamples \u003e 0 \u0026\u0026\n                nBand == nExpectedBaseSamples + 1 \u0026\u0026\n                nBaseSamples != nExpectedBaseSamples )\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Wrong number of ExtraSamples : %d. %d were expected\",\n                         count, m_poGDS-\u003em_nSamplesPerPixel - nExpectedBaseSamples);\n            }\n\n            if( nBand \u003e nBaseSamples\n                \u0026\u0026 nBand-nBaseSamples-1 \u003c count\n                \u0026\u0026 (v[nBand-nBaseSamples-1] == EXTRASAMPLE_ASSOCALPHA\n                    || v[nBand-nBaseSamples-1] == EXTRASAMPLE_UNASSALPHA) )\n                m_eBandInterp = GCI_AlphaBand;\n            else\n                m_eBandInterp = GCI_Undefined;\n        }\n        else\n        {\n            m_eBandInterp = GCI_Undefined;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Establish block size for strip or tiles.                        */\n/* -------------------------------------------------------------------- */\n    nBlockXSize = m_poGDS-\u003em_nBlockXSize;\n    nBlockYSize = m_poGDS-\u003em_nBlockYSize;\n}\n\n/************************************************************************/\n/*                          ~GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::~GTiffRasterBand()\n{\n    // So that any future DropReferenceVirtualMem() will not try to access the\n    // raster band object, but this would not conform to the advertised\n    // contract.\n    if( !m_aSetPSelf.empty() )\n    {\n        ReportError( CE_Warning, CPLE_AppDefined,\n                  \"Virtual memory objects still exist at GTiffRasterBand \"\n                  \"destruction\" );\n        std::set\u003cGTiffRasterBand**\u003e::iterator oIter = m_aSetPSelf.begin();\n        for( ; oIter != m_aSetPSelf.end(); ++oIter )\n            *(*oIter) = nullptr;\n    }\n}\n\n/************************************************************************/\n/*                        FetchBufferDirectIO                           */\n/************************************************************************/\n\nclass FetchBufferDirectIO final\n{\n    VSILFILE*    fp;\n    GByte       *pTempBuffer;\n    size_t       nTempBufferSize;\n\npublic:\n            FetchBufferDirectIO( VSILFILE* fpIn,\n                                 GByte* pTempBufferIn,\n                                 size_t nTempBufferSizeIn ) :\n                fp(fpIn),\n                pTempBuffer(pTempBufferIn),\n                nTempBufferSize(nTempBufferSizeIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( !FetchBytes(pTempBuffer, nOffset, nPixels, nDTSize, bIsByteSwapped,\n                        bIsComplex, nBlockId) )\n        {\n            return nullptr;\n        }\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        vsi_l_offset nSeekForward = 0;\n        if( nOffset \u003c= VSIFTellL(fp) ||\n            (nSeekForward = nOffset - VSIFTellL(fp)) \u003e nTempBufferSize )\n        {\n            if( VSIFSeekL(fp, nOffset, SEEK_SET) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO,\n                         \"Cannot seek to block %d\", nBlockId);\n                return false;\n            }\n        }\n        else\n        {\n            while( nSeekForward \u003e 0 )\n            {\n                vsi_l_offset nToRead = nSeekForward;\n                if( nToRead \u003e nTempBufferSize )\n                    nToRead = nTempBufferSize;\n                if( VSIFReadL(pTempBuffer, static_cast\u003csize_t\u003e(nToRead),\n                              1, fp) != 1 )\n                {\n                    CPLError(CE_Failure, CPLE_FileIO,\n                             \"Cannot seek to block %d\", nBlockId);\n                    return false;\n                }\n                nSeekForward -= nToRead;\n            }\n        }\n        if( VSIFReadL(pabyDstBuffer, nPixels * nDTSize, 1, fp) != 1 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2 );\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = true;\n};\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffRasterBand::DirectIO( GDALRWFlag eRWFlag,\n                               int nXOff, int nYOff, int nXSize, int nYSize,\n                               void * pData, int nBufXSize, int nBufYSize,\n                               GDALDataType eBufType,\n                               GSpacing nPixelSpace, GSpacing nLineSpace,\n                               GDALRasterIOExtraArg* psExtraArg )\n{\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read \u0026\u0026\n          m_poGDS-\u003em_nCompression == COMPRESSION_NONE \u0026\u0026\n          (m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_RGB ||\n           m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_PALETTE) \u0026\u0026\n          m_poGDS-\u003em_nBitsPerSample == nDTSizeBits) )\n    {\n        return -1;\n    }\n    m_poGDS-\u003eCrystalize();\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) \u0026\u0026\n        psExtraArg != nullptr \u0026\u0026\n        psExtraArg-\u003eeResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -\u003e %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( m_poGDS-\u003eGetAccess() == GA_Update )\n    {\n        m_poGDS-\u003eFlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS-\u003em_hTIFF ) );\n    }\n\n    if( TIFFIsTiled( m_poGDS-\u003em_hTIFF ) )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        const size_t nTempBufferForCommonDirectIOSize =\n                static_cast\u003csize_t\u003e(\n                    static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize * nDTSize *\n                    (m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG ?\n                     m_poGDS-\u003enBands : 1) );\n        if( m_poGDS-\u003em_pTempBufferForCommonDirectIO == nullptr )\n        {\n            m_poGDS-\u003em_pTempBufferForCommonDirectIO =\n                static_cast\u003cGByte *\u003e( VSI_MALLOC_VERBOSE(\n                    nTempBufferForCommonDirectIOSize ) );\n            if( m_poGDS-\u003em_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS-\u003em_hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_poGDS-\u003em_pTempBufferForCommonDirectIO,\n                                     nTempBufferForCommonDirectIOSize);\n\n        return m_poGDS-\u003eCommonDirectIO(\n            oFetcher,\n            nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize,\n            eBufType,\n            1, \u0026nBand,\n            nPixelSpace, nLineSpace,\n            0 );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_poGDS-\u003em_hTIFF, TIFFTAG_STRIPOFFSETS, \u0026panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    // TODO(schwehr): Make ppData be GByte**.\n    void** ppData = static_cast\u003cvoid **\u003e(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets = static_cast\u003cvsi_l_offset *\u003e(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes = static_cast\u003csize_t *\u003e(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands =\n        m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG ? m_poGDS-\u003enBands : 1;\n    int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n        eErr = CE_Failure;\n    else if( nXSize != nBufXSize || nYSize != nBufYSize ||\n             eBufType != eDataType ||\n             nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n             nContigBands \u003e 1 )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast\u003cdouble\u003e( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None \u0026\u0026 iLine \u003c nReqYSize; ++iLine )\n    {\n        if( pTmpBuffer == nullptr )\n            ppData[iLine] = static_cast\u003cGByte *\u003e(pData) + iLine * nLineSpace;\n        else\n            ppData[iLine] =\n                static_cast\u003cGByte *\u003e(pTmpBuffer) +\n                iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize \u003c nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast\u003cint\u003e((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n        if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            nBlockId += (nBand-1) * m_poGDS-\u003em_nBlocksPerBand;\n        }\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0 )  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS-\u003em_hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL( nReqYSize, ppData, panOffsets, panSizes, fp );\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None \u0026\u0026 TIFFIsByteSwapped(m_poGDS-\u003em_hTIFF) )\n    {\n        for( int iLine = 0; iLine \u003c nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2 );\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize );\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast\u003cdouble\u003e( nBufXSize );\n    if( eErr == CE_None \u0026\u0026 pTmpBuffer != nullptr )\n    {\n        for( int iY=0; iY \u003c nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize \u003c= nYSize ?\n                iY : static_cast\u003cint\u003e((iY + 0.5) * dfSrcYInc);\n\n            GByte* pabySrcData =\n                static_cast\u003cGByte*\u003e(ppData[iSrcY]) +\n                (nContigBands \u003e 1 ? (nBand-1) : 0) * nDTSize;\n            GByte* pabyDstData =\n                static_cast\u003cGByte *\u003e(pData) + iY * nLineSpace;\n            if( nBufXSize == nXSize )\n            {\n                GDALCopyWords( pabySrcData,\n                               eDataType,\n                               nSrcPixelSize,\n                               pabyDstData,\n                               eBufType,\n                               static_cast\u003cint\u003e(nPixelSpace),\n                               nBufXSize );\n            }\n            else\n            {\n                if( eDataType == GDT_Byte \u0026\u0026 eBufType == GDT_Byte )\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX \u003c nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast\u003cint\u003e(dfSrcX);\n                        pabyDstData[iX * nPixelSpace] =\n                            pabySrcData[iSrcX * nSrcPixelSize];\n                    }\n                }\n                else\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX \u003c nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast\u003cint\u003e(dfSrcX);\n                        GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                       eDataType, 0,\n                                       pabyDstData + iX * nPixelSpace,\n                                       eBufType, 0, 1 );\n                    }\n                }\n            }\n        }\n    }\n\n    // Cleanup.\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           GetVirtualMemAuto()                        */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                                   int *pnPixelSpace,\n                                                   GIntBig *pnLineSpace,\n                                                   char **papszOptions )\n{\n    const char* pszImpl = CSLFetchNameValueDef(\n            papszOptions, \"USE_DEFAULT_IMPLEMENTATION\", \"AUTO\");\n    if( EQUAL(pszImpl, \"YES\") || EQUAL(pszImpl, \"ON\") ||\n        EQUAL(pszImpl, \"1\") || EQUAL(pszImpl, \"TRUE\") )\n    {\n        return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                                  pnLineSpace, papszOptions );\n    }\n\n    CPLVirtualMem *psRet =\n        GetVirtualMemAutoInternal( eRWFlag, pnPixelSpace, pnLineSpace,\n                                   papszOptions );\n    if( psRet != nullptr )\n    {\n        CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Using memory file mapping\");\n        return psRet;\n    }\n\n    if( EQUAL(pszImpl, \"NO\") || EQUAL(pszImpl, \"OFF\") ||\n        EQUAL(pszImpl, \"0\") || EQUAL(pszImpl, \"FALSE\") )\n    {\n        return nullptr;\n    }\n\n    CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Defaulting to base implementation\");\n    return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                              pnLineSpace, papszOptions );\n}\n\n\n/************************************************************************/\n/*                           GetDefaultRAT()                            */\n/************************************************************************/\n\nGDALRasterAttributeTable *GTiffRasterBand::GetDefaultRAT()\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultRAT();\n}\n\n/************************************************************************/\n/*                           GetHistogram()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetHistogram(\n    double dfMin, double dfMax,\n    int nBuckets, GUIntBig * panHistogram,\n    int bIncludeOutOfRange, int bApproxOK,\n    GDALProgressFunc pfnProgress, void *pProgressData )\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetHistogram( dfMin, dfMax,\n                                            nBuckets, panHistogram,\n                                            bIncludeOutOfRange, bApproxOK,\n                                            pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                       GetDefaultHistogram()                          */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                             int *pnBuckets,\n                                             GUIntBig ** ppanHistogram,\n                                             int bForce,\n                                             GDALProgressFunc pfnProgress,\n                                             void *pProgressData )\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultHistogram( pdfMin, pdfMax,\n                                                   pnBuckets, ppanHistogram,\n                                                   bForce,\n                                                   pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                     DropReferenceVirtualMem()                        */\n/************************************************************************/\n\nvoid GTiffRasterBand::DropReferenceVirtualMem( void* pUserData )\n{\n    // This function may also be called when the dataset and rasterband\n    // objects have been destroyed.\n    // If they are still alive, it updates the reference counter of the\n    // base mapping to invalidate the pointer to it if needed.\n\n    GTiffRasterBand** ppoSelf = static_cast\u003cGTiffRasterBand **\u003e( pUserData );\n    GTiffRasterBand* poSelf = *ppoSelf;\n\n    if( poSelf != nullptr )\n    {\n        if( --(poSelf-\u003em_poGDS-\u003em_nRefBaseMapping) == 0 )\n        {\n            poSelf-\u003em_poGDS-\u003em_pBaseMapping = nullptr;\n        }\n        poSelf-\u003em_aSetPSelf.erase(ppoSelf);\n    }\n    CPLFree(pUserData);\n}\n\n/************************************************************************/\n/*                     GetVirtualMemAutoInternal()                      */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                                           int *pnPixelSpace,\n                                                           GIntBig *pnLineSpace,\n                                                           char **papszOptions )\n{\n    int nLineSize = nBlockXSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG )\n        nLineSize *= m_poGDS-\u003enBands;\n\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // In case of a pixel interleaved file, we save virtual memory space\n        // by reusing a base mapping that embraces the whole imagery.\n        if( m_poGDS-\u003em_pBaseMapping != nullptr )\n        {\n            // Offset between the base mapping and the requested mapping.\n            vsi_l_offset nOffset =\n                static_cast\u003cvsi_l_offset\u003e(nBand - 1) *\n                GDALGetDataTypeSizeBytes(eDataType);\n\n            GTiffRasterBand** ppoSelf =\n                static_cast\u003cGTiffRasterBand** \u003e(\n                    CPLCalloc(1, sizeof(GTiffRasterBand*)) );\n            *ppoSelf = this;\n\n            CPLVirtualMem* pVMem = CPLVirtualMemDerivedNew(\n                m_poGDS-\u003em_pBaseMapping,\n                nOffset,\n                CPLVirtualMemGetSize(m_poGDS-\u003em_pBaseMapping) - nOffset,\n                GTiffRasterBand::DropReferenceVirtualMem,\n                ppoSelf);\n            if( pVMem == nullptr )\n            {\n                CPLFree(ppoSelf);\n                return nullptr;\n            }\n\n            // Mechanism used so that the memory mapping object can be\n            // destroyed after the raster band.\n            m_aSetPSelf.insert(ppoSelf);\n            ++m_poGDS-\u003em_nRefBaseMapping;\n            *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n            if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG )\n                *pnPixelSpace *= m_poGDS-\u003enBands;\n            *pnLineSpace = nLineSize;\n            return pVMem;\n        }\n    }\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS-\u003em_hTIFF ));\n\n    vsi_l_offset nLength = static_cast\u003cvsi_l_offset\u003e(nRasterYSize) * nLineSize;\n\n    if( !(CPLIsVirtualMemFileMapAvailable() \u0026\u0026\n          VSIFGetNativeFileDescriptorL(fp) != nullptr \u0026\u0026\n#if SIZEOF_VOIDP == 4\n          nLength == static_cast\u003csize_t\u003e(nLength) \u0026\u0026\n#endif\n          m_poGDS-\u003em_nCompression == COMPRESSION_NONE \u0026\u0026\n          (m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_RGB ||\n           m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_PALETTE) \u0026\u0026\n          m_poGDS-\u003em_nBitsPerSample == GDALGetDataTypeSizeBits(eDataType) \u0026\u0026\n          !TIFFIsTiled( m_poGDS-\u003em_hTIFF ) \u0026\u0026 !TIFFIsByteSwapped(m_poGDS-\u003em_hTIFF)) )\n    {\n        return nullptr;\n    }\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( m_poGDS-\u003eGetAccess() == GA_Update )\n    {\n        m_poGDS-\u003eFlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS-\u003em_hTIFF ) );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_poGDS-\u003em_hTIFF, TIFFTAG_STRIPOFFSETS, \u0026panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return nullptr;\n    }\n\n    GPtrDiff_t nBlockSize =\n        static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG )\n        nBlockSize *= m_poGDS-\u003enBands;\n\n    int nBlocks = m_poGDS-\u003em_nBlocksPerBand;\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlocks *= m_poGDS-\u003enBands;\n    int i = 0;  // Used after for.\n    for( ; i \u003c nBlocks; ++i )\n    {\n        if( panTIFFOffsets[i] != 0 )\n            break;\n    }\n    if( i == nBlocks )\n    {\n        // All zeroes.\n        if( m_poGDS-\u003eeAccess == GA_Update )\n        {\n            // Initialize the file with empty blocks so that the file has\n            // the appropriate size.\n\n            toff_t* panByteCounts = nullptr;\n            if( !TIFFGetField( m_poGDS-\u003em_hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                               \u0026panByteCounts ) ||\n                panByteCounts == nullptr )\n            {\n                return nullptr;\n            }\n            if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n                return nullptr;\n            vsi_l_offset nBaseOffset = VSIFTellL(fp);\n\n            // Just write one tile with libtiff to put it in appropriate state.\n            GByte* pabyData =\n                static_cast\u003cGByte*\u003e(VSI_CALLOC_VERBOSE(1, nBlockSize));\n            if( pabyData == nullptr )\n            {\n                return nullptr;\n            }\n            const auto ret =\n                    TIFFWriteEncodedStrip( m_poGDS-\u003em_hTIFF, 0, pabyData,\n                                           nBlockSize );\n            VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS-\u003em_hTIFF ) );\n            VSIFree(pabyData);\n            if( ret != nBlockSize )\n            {\n                return nullptr;\n            }\n            CPLAssert(panTIFFOffsets[0] == nBaseOffset);\n            CPLAssert(panByteCounts[0] == static_cast\u003ctoff_t\u003e(nBlockSize));\n\n            // Now simulate the writing of other blocks.\n            const vsi_l_offset nDataSize =\n                static_cast\u003cvsi_l_offset\u003e(nBlockSize) * nBlocks;\n            if( VSIFTruncateL(fp, nBaseOffset + nDataSize) != 0 )\n                return nullptr;\n\n            for( i = 1; i \u003c nBlocks; ++i)\n            {\n                panTIFFOffsets[i] =\n                    nBaseOffset + i * static_cast\u003ctoff_t\u003e(nBlockSize);\n                panByteCounts[i] = nBlockSize;\n            }\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"Sparse files not supported in file mapping\" );\n            return nullptr;\n        }\n    }\n\n    GIntBig nBlockSpacing = 0;\n    bool bCompatibleSpacing = true;\n    toff_t nPrevOffset = 0;\n    for( i = 0; i \u003c m_poGDS-\u003em_nBlocksPerBand; ++i )\n    {\n        toff_t nCurOffset = 0;\n        if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            nCurOffset =\n                panTIFFOffsets[m_poGDS-\u003em_nBlocksPerBand * (nBand - 1) + i];\n        else\n            nCurOffset = panTIFFOffsets[i];\n        if( nCurOffset == 0 )\n        {\n            bCompatibleSpacing = false;\n            break;\n        }\n        if( i \u003e 0 )\n        {\n            const GIntBig nCurSpacing = nCurOffset - nPrevOffset;\n            if( i == 1 )\n            {\n                if( nCurSpacing !=\n                    static_cast\u003cGIntBig\u003e(nBlockYSize) * nLineSize )\n                {\n                    bCompatibleSpacing = false;\n                    break;\n                }\n                nBlockSpacing = nCurSpacing;\n            }\n            else if( nBlockSpacing != nCurSpacing )\n            {\n                bCompatibleSpacing = false;\n                break;\n            }\n        }\n        nPrevOffset = nCurOffset;\n    }\n\n    if( !bCompatibleSpacing )\n    {\n        return nullptr;\n    }\n\n    vsi_l_offset nOffset = 0;\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        CPLAssert( m_poGDS-\u003em_pBaseMapping == nullptr );\n        nOffset = panTIFFOffsets[0];\n    }\n    else\n    {\n        nOffset = panTIFFOffsets[m_poGDS-\u003em_nBlocksPerBand * (nBand - 1)];\n    }\n    CPLVirtualMem* pVMem = CPLVirtualMemFileMapNew(\n        fp, nOffset, nLength,\n        eRWFlag == GF_Write ? VIRTUALMEM_READWRITE : VIRTUALMEM_READONLY,\n        nullptr, nullptr);\n    if( pVMem == nullptr )\n    {\n        return nullptr;\n    }\n\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // TODO(schwehr): Revisit this block.\n        m_poGDS-\u003em_pBaseMapping = pVMem;\n        pVMem = GetVirtualMemAutoInternal( eRWFlag,\n                                           pnPixelSpace,\n                                           pnLineSpace,\n                                           papszOptions );\n        // Drop ref on base mapping.\n        CPLVirtualMemFree(m_poGDS-\u003em_pBaseMapping);\n        if( pVMem == nullptr )\n            m_poGDS-\u003em_pBaseMapping = nullptr;\n    }\n    else\n    {\n        *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n        if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG )\n            *pnPixelSpace *= m_poGDS-\u003enBands;\n        *pnLineSpace = nLineSize;\n    }\n    return pVMem;\n}\n\n/************************************************************************/\n/*                     HasOptimizedReadMultiRange()                     */\n/************************************************************************/\n\nbool GTiffDataset::HasOptimizedReadMultiRange()\n{\n    if( m_nHasOptimizedReadMultiRange \u003e= 0 )\n        return m_nHasOptimizedReadMultiRange != 0;\n    m_nHasOptimizedReadMultiRange = static_cast\u003csigned char\u003e(\n        VSIHasOptimizedReadMultiRange(m_pszFilename)\n        // Config option for debug and testing purposes only\n        || CPLTestBool(CPLGetConfigOption(\"GTIFF_HAS_OPTIMIZED_READ_MULTI_RANGE\", \"NO\"))\n    );\n    return m_nHasOptimizedReadMultiRange != 0;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffDataset::IRasterIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize \u003c nXSize \u0026\u0026 nBufYSize \u003c nYSize )\n    {\n        int bTried = FALSE;\n        ++m_nJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nBandCount, panBandMap,\n                                 nPixelSpace, nLineSpace,\n                                 nBandSpace,\n                                 psExtraArg,\n                                 \u0026bTried );\n        --m_nJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( m_eVirtualMemIOUsage != VirtualMemIOEnum::NO )\n    {\n        const int nErr = VirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr \u003e= 0 )\n            return static_cast\u003cCPLErr\u003e(nErr);\n    }\n    if( m_bDirectIO )\n    {\n        const int nErr = DirectIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr \u003e= 0 )\n            return static_cast\u003cCPLErr\u003e(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( eAccess == GA_ReadOnly \u0026\u0026\n        eRWFlag == GF_Read \u0026\u0026\n        m_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        HasOptimizedReadMultiRange() )\n    {\n        pBufferedData = cpl::down_cast\u003cGTiffRasterBand *\u003e(\n            GetRasterBand(1))-\u003eCacheMultiRange(nXOff, nYOff,\n                                               nXSize, nYSize,\n                                               nBufXSize, nBufYSize,\n                                               psExtraArg);\n    }\n\n    ++m_nJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamDataset::IRasterIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg);\n    m_nJPEGOverviewVisibilityCounter--;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( m_hTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        FetchBufferVirtualMemIO                       */\n/************************************************************************/\n\nclass FetchBufferVirtualMemIO final\n{\n    const GByte* pabySrcData;\n    size_t       nMappingSize;\n    GByte       *pTempBuffer;\n\npublic:\n            FetchBufferVirtualMemIO( const GByte* pabySrcDataIn,\n                                     size_t nMappingSizeIn,\n                                     GByte* pTempBufferIn ) :\n                pabySrcData(pabySrcDataIn),\n                nMappingSize(nMappingSizeIn),\n                pTempBuffer(pTempBufferIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize \u003e nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return nullptr;\n        }\n        if( !bIsByteSwapped )\n            return pabySrcData + nOffset;\n        memcpy(pTempBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsComplex )\n            GDALSwapWords( pTempBuffer, nDTSize / 2, 2 * nPixels, nDTSize / 2);\n        else\n            GDALSwapWords( pTempBuffer, nDTSize, nPixels, nDTSize);\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize \u003e nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n        memcpy(pabyDstBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2);\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = false;\n};\n\n/************************************************************************/\n/*                         VirtualMemIO()                               */\n/************************************************************************/\n\nint GTiffDataset::VirtualMemIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n{\n    if( eAccess == GA_Update || eRWFlag == GF_Write || m_bStreamingIn )\n        return -1;\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) \u0026\u0026\n        psExtraArg != nullptr \u0026\u0026\n        psExtraArg-\u003eeResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    const GDALDataType eDataType = GetRasterBand(1)-\u003eGetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(m_nCompression == COMPRESSION_NONE \u0026\u0026\n        (m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n        m_nPhotometric == PHOTOMETRIC_RGB ||\n        m_nPhotometric == PHOTOMETRIC_PALETTE) \u0026\u0026\n        m_nBitsPerSample == nDTSizeBits) )\n    {\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n        return -1;\n    }\n\n    size_t nMappingSize = 0;\n    GByte* pabySrcData = nullptr;\n    if( STARTS_WITH(m_pszFilename, \"/vsimem/\") )\n    {\n        vsi_l_offset nDataLength = 0;\n        pabySrcData =\n            VSIGetMemFileBuffer(m_pszFilename, \u0026nDataLength, FALSE);\n        nMappingSize = static_cast\u003csize_t\u003e(nDataLength);\n        if( pabySrcData == nullptr )\n            return -1;\n    }\n    else if( m_psVirtualMemIOMapping == nullptr )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n        if( !CPLIsVirtualMemFileMapAvailable() ||\n            VSIFGetNativeFileDescriptorL(fp) == nullptr )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        const vsi_l_offset nLength = VSIFTellL(fp);\n        if( static_cast\u003csize_t\u003e(nLength) != nLength )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        if( m_eVirtualMemIOUsage == VirtualMemIOEnum::IF_ENOUGH_RAM )\n        {\n            GIntBig nRAM = CPLGetUsablePhysicalRAM();\n            if( static_cast\u003cGIntBig\u003e(nLength) \u003e nRAM )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Not enough RAM to map whole file into memory.\" );\n                m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n                return -1;\n            }\n        }\n        m_psVirtualMemIOMapping = CPLVirtualMemFileMapNew(\n            fp, 0, nLength, VIRTUALMEM_READONLY, nullptr, nullptr);\n        if( m_psVirtualMemIOMapping == nullptr )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::YES;\n    }\n\n    if( m_psVirtualMemIOMapping )\n    {\n#ifdef DEBUG\n        CPLDebug(\"GTiff\", \"Using VirtualMemIO\");\n#endif\n        nMappingSize = CPLVirtualMemGetSize(m_psVirtualMemIOMapping);\n        pabySrcData = static_cast\u003cGByte *\u003e(\n            CPLVirtualMemGetAddr(m_psVirtualMemIOMapping) );\n    }\n\n    if( TIFFIsByteSwapped(m_hTIFF) \u0026\u0026 m_pTempBufferForCommonDirectIO == nullptr )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        size_t nTempBufferForCommonDirectIOSize =\n            static_cast\u003csize_t\u003e(m_nBlockXSize * nDTSize *\n                (m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1));\n        if( TIFFIsTiled(m_hTIFF) )\n            nTempBufferForCommonDirectIOSize *= m_nBlockYSize;\n\n        m_pTempBufferForCommonDirectIO =\n            static_cast\u003cGByte *\u003e(\n                VSI_MALLOC_VERBOSE(nTempBufferForCommonDirectIOSize) );\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n            return CE_Failure;\n    }\n    FetchBufferVirtualMemIO oFetcher( pabySrcData, nMappingSize,\n                                      m_pTempBufferForCommonDirectIO );\n\n    return CommonDirectIO( oFetcher,\n                           nXOff, nYOff, nXSize, nYSize,\n                           pData, nBufXSize, nBufYSize,\n                           eBufType,\n                           nBandCount, panBandMap,\n                           nPixelSpace, nLineSpace,\n                           nBandSpace );\n}\n\n/************************************************************************/\n/*                   CopyContigByteMultiBand()                          */\n/************************************************************************/\n\nstatic inline void CopyContigByteMultiBand(\n    const GByte* CPL_RESTRICT pabySrc, int nSrcStride,\n    GByte* CPL_RESTRICT pabyDest, int nDestStride,\n    int nIters, int nBandCount )\n{\n    if( nBandCount == 3 )\n    {\n        if( nSrcStride == 3 \u0026\u0026 nDestStride == 4 )\n        {\n            while( nIters \u003e= 8 )\n            {\n                pabyDest[4*0+0] = pabySrc[3*0+0];\n                pabyDest[4*0+1] = pabySrc[3*0+1];\n                pabyDest[4*0+2] = pabySrc[3*0+2];\n                pabyDest[4*1+0] = pabySrc[3*1+0];\n                pabyDest[4*1+1] = pabySrc[3*1+1];\n                pabyDest[4*1+2] = pabySrc[3*1+2];\n                pabyDest[4*2+0] = pabySrc[3*2+0];\n                pabyDest[4*2+1] = pabySrc[3*2+1];\n                pabyDest[4*2+2] = pabySrc[3*2+2];\n                pabyDest[4*3+0] = pabySrc[3*3+0];\n                pabyDest[4*3+1] = pabySrc[3*3+1];\n                pabyDest[4*3+2] = pabySrc[3*3+2];\n                pabyDest[4*4+0] = pabySrc[3*4+0];\n                pabyDest[4*4+1] = pabySrc[3*4+1];\n                pabyDest[4*4+2] = pabySrc[3*4+2];\n                pabyDest[4*5+0] = pabySrc[3*5+0];\n                pabyDest[4*5+1] = pabySrc[3*5+1];\n                pabyDest[4*5+2] = pabySrc[3*5+2];\n                pabyDest[4*6+0] = pabySrc[3*6+0];\n                pabyDest[4*6+1] = pabySrc[3*6+1];\n                pabyDest[4*6+2] = pabySrc[3*6+2];\n                pabyDest[4*7+0] = pabySrc[3*7+0];\n                pabyDest[4*7+1] = pabySrc[3*7+1];\n                pabyDest[4*7+2] = pabySrc[3*7+2];\n                pabySrc += 3 * 8;\n                pabyDest += 4 * 8;\n                nIters -= 8;\n            }\n            while( nIters-- \u003e 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += 3;\n                pabyDest += 4;\n            }\n        }\n        else\n        {\n            while( nIters-- \u003e 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += nSrcStride;\n                pabyDest += nDestStride;\n            }\n        }\n    }\n    else\n    {\n        while( nIters-- \u003e 0 )\n        {\n            for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                pabyDest[iBand] = pabySrc[iBand];\n            pabySrc += nSrcStride;\n            pabyDest += nDestStride;\n        }\n    }\n}\n\n/************************************************************************/\n/*                         CommonDirectIO()                             */\n/************************************************************************/\n\n// #define DEBUG_REACHED_VIRTUAL_MEM_IO\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\nstatic int anReachedVirtualMemIO[52] = { 0 };\n#define REACHED(x) anReachedVirtualMemIO[x] = 1\n#else\n#define REACHED(x)\n#endif\n\ntemplate\u003cclass FetchBuffer\u003e CPLErr GTiffDataset::CommonDirectIO(\n    FetchBuffer\u0026 oFetcher,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace )\n{\n    const GDALDataType eDataType = GetRasterBand(1)-\u003eGetRasterDataType();\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    const bool bIsComplex = CPL_TO_BOOL(GDALDataTypeIsComplex(eDataType));\n    const int nBufDTSize = GDALGetDataTypeSizeBytes(eBufType);\n\n    // Get strip offsets.\n    toff_t *panOffsets = nullptr;\n    if( !TIFFGetField( m_hTIFF, (TIFFIsTiled( m_hTIFF )) ?\n                       TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                       \u0026panOffsets ) ||\n        panOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    bool bUseContigImplementation =\n        m_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        nBandCount \u003e 1 \u0026\u0026\n        nBandSpace == nBufDTSize;\n    if( bUseContigImplementation )\n    {\n        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n        {\n            const int nBand = panBandMap[iBand];\n            if( nBand != iBand + 1 )\n            {\n                bUseContigImplementation = false;\n                break;\n            }\n        }\n    }\n\n    const int nBandsPerBlock =\n        m_nPlanarConfig == PLANARCONFIG_SEPARATE ? 1 : nBands;\n    const int nBandsPerBlockDTSize = nBandsPerBlock * nDTSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n    const bool bNoTypeChange = (eDataType == eBufType);\n    const bool bNoXResampling = (nXSize == nBufXSize );\n    const bool bNoXResamplingNoTypeChange = (bNoTypeChange \u0026\u0026 bNoXResampling);\n    const bool bByteOnly = (bNoTypeChange \u0026\u0026 nDTSize == 1 );\n    const bool bByteNoXResampling = ( bByteOnly \u0026\u0026 bNoXResamplingNoTypeChange );\n    const bool bIsByteSwapped = CPL_TO_BOOL(TIFFIsByteSwapped(m_hTIFF));\n    const double dfSrcXInc = nXSize / static_cast\u003cdouble\u003e( nBufXSize );\n    const double dfSrcYInc = nYSize / static_cast\u003cdouble\u003e( nBufYSize );\n\n    int bNoDataSetIn = FALSE;\n    double dfNoData = GetRasterBand(1)-\u003eGetNoDataValue( \u0026bNoDataSetIn );\n    GByte abyNoData = 0;\n    if( !bNoDataSetIn )\n        dfNoData = 0;\n    else if( dfNoData \u003e= 0 \u0026\u0026 dfNoData \u003c= 255 )\n        abyNoData = static_cast\u003cGByte\u003e(dfNoData + 0.5);\n\n    if( FetchBuffer::bMinimizeIO \u0026\u0026\n             TIFFIsTiled( m_hTIFF ) \u0026\u0026 bNoXResampling \u0026\u0026 (nYSize == nBufYSize ) \u0026\u0026\n             m_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 nBandCount \u003e 1 )\n    {\n        GByte* pabyData = static_cast\u003cGByte *\u003e(pData);\n        for( int y = 0; y \u003c nBufYSize; )\n        {\n            const int nSrcLine = nYOff + y;\n            const int nBlockYOff = nSrcLine / m_nBlockYSize;\n            const int nYOffsetInBlock = nSrcLine % m_nBlockYSize;\n            const int nUsedBlockHeight =\n                std::min( nBufYSize - y,\n                          m_nBlockYSize - nYOffsetInBlock );\n\n            int nBlockXOff = nXOff / m_nBlockXSize;\n            int nXOffsetInBlock = nXOff % m_nBlockXSize;\n            int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n            int x = 0;\n            while( x \u003c nBufXSize )\n            {\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                const int nUsedBlockWidth =\n                    std::min( m_nBlockXSize - nXOffsetInBlock,\n                              nBufXSize - x );\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(30);\n                    for( int k = 0; k \u003c nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                        {\n                            GByte* pabyLocalDataBand =\n                                pabyLocalData + iBand * nBandSpace;\n\n                            GDALCopyWords(\n                                \u0026dfNoData, GDT_Float64, 0,\n                                pabyLocalDataBand, eBufType,\n                                static_cast\u003cint\u003e(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                }\n                else\n                {\n                    const int nByteOffsetInBlock =\n                        nYOffsetInBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                    const GByte* pabyLocalSrcDataK0 = oFetcher.FetchBytes(\n                            nCurOffset + nByteOffsetInBlock,\n                            m_nBlockXSize *\n                            nUsedBlockHeight * nBandsPerBlock,\n                            nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                    if( pabyLocalSrcDataK0 == nullptr )\n                        return CE_Failure;\n\n                    for( int k = 0; k \u003c nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        const GByte* pabyLocalSrcData =\n                            pabyLocalSrcDataK0 +\n                            (k * m_nBlockXSize + nXOffsetInBlock) *\n                            nBandsPerBlockDTSize;\n\n                        if( bUseContigImplementation \u0026\u0026 nBands == nBandCount \u0026\u0026\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(31);\n                            GDALCopyWords( pabyLocalSrcData,\n                                           eDataType, nDTSize,\n                                           pabyLocalData,\n                                           eBufType, nBufDTSize,\n                                           nUsedBlockWidth * nBands );\n                        }\n                        else\n                        {\n                            REACHED(32);\n                            for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords(\n                                    pabyLocalSrcDataBand,\n                                    eDataType, nBandsPerBlockDTSize,\n                                    pabyLocalDataBand,\n                                    eBufType, static_cast\u003cint\u003e(nPixelSpace),\n                                    nUsedBlockWidth );\n                            }\n                        }\n                    }\n                }\n\n                nXOffsetInBlock = 0;\n                ++nBlockXOff;\n                ++nBlockId;\n                x += nUsedBlockWidth;\n            }\n\n            y += nUsedBlockHeight;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO \u0026\u0026\n             TIFFIsTiled( m_hTIFF ) \u0026\u0026 bNoXResampling \u0026\u0026\n             (nYSize == nBufYSize ) )\n             // \u0026\u0026 (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast\u003cGByte *\u003e(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            for( int y = 0; y \u003c nBufYSize; )\n            {\n                const int nSrcLine = nYOff + y;\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nUsedBlockHeight =\n                    std::min( nBufYSize - y,\n                              m_nBlockYSize - nYOffsetIm_nBlock);\n\n                int nBlockXOff = nXOff / m_nBlockXSize;\n                int nXOffsetInBlock = nXOff % m_nBlockXSize;\n                int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                {\n                    REACHED(33);\n                    nBlockId += m_nBlocksPerBand * (nBand - 1);\n                }\n                else\n                {\n                    REACHED(34);\n                }\n\n                int x = 0;\n                while( x \u003c nBufXSize )\n                {\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    const int nUsedBlockWidth =\n                        std::min(\n                            m_nBlockXSize - nXOffsetInBlock,\n                            nBufXSize - x);\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(35);\n                        for( int k = 0; k \u003c nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords(\n                                \u0026dfNoData, GDT_Float64, 0,\n                                pabyLocalData, eBufType,\n                                static_cast\u003cint\u003e(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                    else\n                    {\n                        const int nByteOffsetIm_nBlock =\n                            nYOffsetIm_nBlock * m_nBlockXSize *\n                            nBandsPerBlockDTSize;\n                        const GByte* pabyLocalSrcDataK0 =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nByteOffsetIm_nBlock,\n                                m_nBlockXSize *\n                                nUsedBlockHeight * nBandsPerBlock,\n                                nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataK0 == nullptr )\n                            return CE_Failure;\n\n                        if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                        {\n                            REACHED(36);\n                            pabyLocalSrcDataK0 += (nBand - 1) * nDTSize;\n                        }\n                        else\n                        {\n                            REACHED(37);\n                        }\n\n                        for( int k = 0; k \u003c nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace +\n                                x * nPixelSpace;\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (k * m_nBlockXSize + nXOffsetInBlock) *\n                                nBandsPerBlockDTSize;\n\n                            GDALCopyWords(\n                                pabyLocalSrcData,\n                                eDataType, nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                eBufType, static_cast\u003cint\u003e(nPixelSpace),\n                                nUsedBlockWidth);\n                        }\n                    }\n\n                    nXOffsetInBlock = 0;\n                    ++nBlockXOff;\n                    ++nBlockId;\n                    x += nUsedBlockWidth;\n                }\n\n                y += nUsedBlockHeight;\n            }\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO \u0026\u0026\n             TIFFIsTiled( m_hTIFF ) \u0026\u0026\n             m_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 nBandCount \u003e 1 )\n    {\n        GByte* pabyData = static_cast\u003cGByte *\u003e(pData);\n        int anSrcYOffset[256] = { 0 };\n        for( int y = 0; y \u003c nBufYSize; )\n        {\n            const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n            const int nSrcLine = static_cast\u003cint\u003e(dfYOffStart);\n            const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n            const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n            const int nBaseByteOffsetIm_nBlock =\n                nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n            int ychunk = 1;\n            int nLastSrcLineK = nSrcLine;\n            anSrcYOffset[0] = 0;\n            for( int k = 1; k \u003c nBufYSize - y; ++k )\n            {\n                int nSrcLineK =\n                    nYOff + static_cast\u003cint\u003e((y + k + 0.5) * dfSrcYInc);\n                const int nBlockYOffK = nSrcLineK / m_nBlockYSize;\n                if( k \u003c 256)\n                    anSrcYOffset[k] =\n                        ((nSrcLineK % m_nBlockYSize) - nYOffsetIm_nBlock) *\n                        m_nBlockXSize * nBandsPerBlockDTSize;\n                if( nBlockYOffK != m_nBlockYOff )\n                {\n                    break;\n                }\n                ++ychunk;\n                nLastSrcLineK = nSrcLineK;\n            }\n            const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n            // CPLAssert(nUsedBlockHeight \u003c= m_nBlockYSize);\n\n            double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n            int nCurBlockXOff = 0;\n            int nNextBlockXOff = 0;\n            toff_t nCurOffset = 0;\n            const GByte* pabyLocalSrcDataStartLine = nullptr;\n            for( int x = 0; x \u003c nBufXSize; ++x, dfSrcX += dfSrcXInc)\n            {\n                const int nSrcPixel = static_cast\u003cint\u003e(dfSrcX);\n                if( nSrcPixel \u003e= nNextBlockXOff )\n                {\n                    const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                    nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                    nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                    const int nBlockId =\n                        nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                    nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset != 0 )\n                    {\n                        pabyLocalSrcDataStartLine =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                m_nBlockXSize *\n                                nBandsPerBlock * nUsedBlockHeight,\n                                nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataStartLine == nullptr )\n                            return CE_Failure;\n                    }\n                }\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(38);\n\n                    for( int k = 0; k \u003c ychunk; ++k )\n                    {\n                        GByte* const pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                        {\n                            GDALCopyWords(\n                                \u0026dfNoData, GDT_Float64, 0,\n                                pabyLocalData + nBandSpace * iBand, eBufType, 0,\n                                1);\n                        }\n                    }\n                }\n                else\n                {\n                    const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                    double dfYOff = dfYOffStart;\n                    const GByte* const pabyLocalSrcDataK0 =\n                        pabyLocalSrcDataStartLine +\n                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                    GByte* pabyLocalData =\n                        pabyData + y * nLineSpace + x * nPixelSpace;\n                    for( int k = 0;\n                         k \u003c ychunk;\n                         ++k, pabyLocalData += nLineSpace )\n                    {\n                        const GByte* pabyLocalSrcData = nullptr;\n                        if( ychunk \u003c= 256 )\n                        {\n                            REACHED(39);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 + anSrcYOffset[k];\n                        }\n                        else\n                        {\n                            REACHED(40);\n                            const int nYOffsetIm_nBlockK =\n                                static_cast\u003cint\u003e(dfYOff) % m_nBlockYSize;\n                            // CPLAssert(\n                            //     nYOffsetIm_nBlockK - nYOffsetIm_nBlock \u003c=\n                            //     nUsedBlockHeight);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (nYOffsetIm_nBlockK - nYOffsetIm_nBlock) *\n                                m_nBlockXSize * nBandsPerBlockDTSize;\n                            dfYOff += dfSrcYInc;\n                        }\n\n                        if( bByteOnly )\n                        {\n                            REACHED(41);\n                            for( int iBand=0; iBand \u003c nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData + (panBandMap[iBand]-1);\n                                *pabyLocalDataBand = *pabyLocalSrcDataBand;\n                            }\n                        }\n                        else\n                        {\n                            REACHED(42);\n                            for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords( pabyLocalSrcDataBand,\n                                               eDataType, 0,\n                                               pabyLocalDataBand,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n            }\n\n            y += ychunk;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO \u0026\u0026\n             TIFFIsTiled( m_hTIFF ) )\n             // \u0026\u0026 (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast\u003cGByte*\u003e(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            int anSrcYOffset[256] = { 0 };\n            for( int y = 0; y \u003c nBufYSize; )\n            {\n                const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n                const int nSrcLine = static_cast\u003cint\u003e(dfYOffStart);\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nBaseByteOffsetIm_nBlock =\n                    nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                int ychunk = 1;\n                int nLastSrcLineK = nSrcLine;\n                anSrcYOffset[0] = 0;\n                for( int k = 1; k \u003c nBufYSize - y; ++k )\n                {\n                    const int nSrcLineK =\n                        nYOff + static_cast\u003cint\u003e((y + k + 0.5) * dfSrcYInc);\n                    const int nBlockYOffK = nSrcLineK / m_nBlockYSize;\n                    if( k \u003c 256)\n                        anSrcYOffset[k] =\n                            ((nSrcLineK % m_nBlockYSize) - nYOffsetIm_nBlock) *\n                            m_nBlockXSize * nBandsPerBlockDTSize;\n                    if( nBlockYOffK != m_nBlockYOff )\n                    {\n                        break;\n                    }\n                    ++ychunk;\n                    nLastSrcLineK = nSrcLineK;\n                }\n                const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n                // CPLAssert(nUsedBlockHeight \u003c= m_nBlockYSize);\n\n                double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                int nCurBlockXOff = 0;\n                int nNextBlockXOff = 0;\n                toff_t nCurOffset = 0;\n                const GByte* pabyLocalSrcDataStartLine = nullptr;\n                for( int x = 0; x \u003c nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                {\n                    int nSrcPixel = static_cast\u003cint\u003e(dfSrcX);\n                    if( nSrcPixel \u003e= nNextBlockXOff )\n                    {\n                        const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                        nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                        nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                        int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                        if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(43);\n                            nBlockId += m_nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(44);\n                        }\n                        nCurOffset = panOffsets[nBlockId];\n                        if( nCurOffset != 0 )\n                        {\n                            pabyLocalSrcDataStartLine =\n                                oFetcher.FetchBytes(\n                                    nCurOffset + nBaseByteOffsetIm_nBlock,\n                                    m_nBlockXSize *\n                                    nBandsPerBlock * nUsedBlockHeight,\n                                    nDTSize,\n                                    bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcDataStartLine == nullptr )\n                                return CE_Failure;\n\n                            if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                            {\n                                REACHED(45);\n                                pabyLocalSrcDataStartLine +=\n                                    (nBand - 1) * nDTSize;\n                            }\n                            else\n                            {\n                                REACHED(46);\n                            }\n                        }\n                    }\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(47);\n\n                        for( int k = 0; k \u003c ychunk; ++k )\n                        {\n                            GByte* const pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords( \u0026dfNoData, GDT_Float64, 0,\n                                           pabyLocalData, eBufType, 0,\n                                           1 );\n                        }\n                    }\n                    else\n                    {\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                        double dfYOff = dfYOffStart;\n                        const GByte* const pabyLocalSrcDataK0 =\n                            pabyLocalSrcDataStartLine +\n                            nXOffsetInBlock * nBandsPerBlockDTSize;\n                        GByte* pabyLocalData =\n                            pabyData + y * nLineSpace + x * nPixelSpace;\n                        for( int k = 0;\n                             k \u003c ychunk;\n                             ++k, pabyLocalData += nLineSpace )\n                        {\n                            const GByte* pabyLocalSrcData = nullptr;\n                            if( ychunk \u003c= 256 )\n                            {\n                                REACHED(48);\n                                pabyLocalSrcData =\n                                    pabyLocalSrcDataK0 + anSrcYOffset[k];\n                            }\n                            else\n                            {\n                                REACHED(49);\n                                const int nYOffsetIm_nBlockK =\n                                    static_cast\u003cint\u003e(dfYOff) % m_nBlockYSize;\n                                // CPLAssert(\n                                //     nYOffsetIm_nBlockK - nYOffsetIm_nBlock \u003c=\n                                //     nUsedBlockHeight);\n                                pabyLocalSrcData = pabyLocalSrcDataK0 +\n                                    (nYOffsetIm_nBlockK - nYOffsetIm_nBlock) *\n                                    m_nBlockXSize * nBandsPerBlockDTSize;\n                                dfYOff += dfSrcYInc;\n                            }\n\n                            if( bByteOnly )\n                            {\n                                REACHED(50);\n\n                                *pabyLocalData = *pabyLocalSrcData;\n                            }\n                            else\n                            {\n                                REACHED(51);\n\n                                GDALCopyWords( pabyLocalSrcData,\n                                               eDataType, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n\n                y += ychunk;\n            }\n        }\n    }\n    else if( bUseContigImplementation )\n    {\n        if( !FetchBuffer::bMinimizeIO \u0026\u0026 TIFFIsTiled( m_hTIFF ) )\n        {\n            GByte* pabyData = static_cast\u003cGByte *\u003e(pData);\n            for( int y = 0; y \u003c nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast\u003cint\u003e((y + 0.5) * dfSrcYInc);\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nBaseByteOffsetIm_nBlock =\n                    nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n\n                if( bNoXResampling )\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    int nBlockXOff = nXOff / m_nBlockXSize;\n                    int nXOffsetInBlock = nXOff % m_nBlockXSize;\n                    int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n\n                    int x = 0;\n                    while( x \u003c nBufXSize )\n                    {\n                        const int nByteOffsetIm_nBlock = nBaseByteOffsetIm_nBlock +\n                                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                        const toff_t nCurOffset = panOffsets[nBlockId];\n                        const int nUsedBlockWidth =\n                            std::min(\n                                m_nBlockXSize - nXOffsetInBlock,\n                                nBufXSize - x);\n\n                        int nIters = nUsedBlockWidth;\n                        if( nCurOffset == 0 )\n                        {\n                            if( bByteNoXResampling )\n                            {\n                                REACHED(0);\n                                while( nIters-- \u003e 0 )\n                                {\n                                    for( int iBand = 0;\n                                         iBand \u003c nBandCount;\n                                         ++iBand )\n                                    {\n                                        pabyLocalData[iBand] = abyNoData;\n                                    }\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                            else\n                            {\n                                REACHED(1);\n                                while( nIters-- \u003e 0 )\n                                {\n                                    GDALCopyWords(\n                                        \u0026dfNoData, GDT_Float64, 0,\n                                        pabyLocalData, eBufType,\n                                        static_cast\u003cint\u003e(nBandSpace),\n                                        nBandCount);\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if( bNoTypeChange \u0026\u0026 nBands == nBandCount \u0026\u0026\n                                nPixelSpace == nBandsPerBlockDTSize )\n                            {\n                                REACHED(2);\n                                if( !oFetcher.FetchBytes(\n                                        pabyLocalData,\n                                        nCurOffset + nByteOffsetIm_nBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId) )\n                                {\n                                    return CE_Failure;\n                                }\n                                pabyLocalData +=\n                                    nIters * nBandsPerBlock * nDTSize;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nByteOffsetIm_nBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcData == nullptr )\n                                    return CE_Failure;\n                                if( bByteNoXResampling )\n                                {\n                                    REACHED(3);\n                                    CopyContigByteMultiBand(\n                                        pabyLocalSrcData,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData,\n                                        static_cast\u003cint\u003e(nPixelSpace),\n                                        nIters,\n                                        nBandCount);\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    REACHED(4);\n                                    while( nIters-- \u003e 0 )\n                                    {\n                                        GDALCopyWords(\n                                            pabyLocalSrcData,\n                                            eDataType, nDTSize,\n                                            pabyLocalData,\n                                            eBufType,\n                                            static_cast\u003cint\u003e(nBandSpace),\n                                            nBandCount);\n                                        pabyLocalSrcData +=\n                                            nBandsPerBlockDTSize;\n                                        pabyLocalData += nPixelSpace;\n                                    }\n                                }\n                            }\n                        }\n\n                        nXOffsetInBlock = 0;\n                        ++nBlockXOff;\n                        ++nBlockId;\n                        x += nUsedBlockWidth;\n                    }\n                }\n                else  // Contig, tiled, potential resampling \u0026 data type change.\n                {\n                    const GByte* pabyLocalSrcDataStartLine = nullptr;\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                    int nCurBlockXOff = 0;\n                    int nNextBlockXOff = 0;\n                    toff_t nCurOffset = 0;\n                    for( int x = 0; x \u003c nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                    {\n                        int nSrcPixel = static_cast\u003cint\u003e(dfSrcX);\n                        if( nSrcPixel \u003e= nNextBlockXOff )\n                        {\n                            const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                            nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                            nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                            const int nBlockId =\n                                nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                            nCurOffset = panOffsets[nBlockId];\n                            if( nCurOffset != 0 )\n                            {\n                                pabyLocalSrcDataStartLine =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nBaseByteOffsetIm_nBlock,\n                                        m_nBlockXSize *\n                                        nBandsPerBlock,\n                                        nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcDataStartLine == nullptr )\n                                    return CE_Failure;\n                            }\n                        }\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n\n                        if( nCurOffset == 0 )\n                        {\n                            REACHED(5);\n                            GDALCopyWords(\n                                \u0026dfNoData, GDT_Float64, 0,\n                                pabyLocalData,\n                                eBufType,\n                                static_cast\u003cint\u003e(nBandSpace),\n                                nBandCount );\n                            pabyLocalData += nPixelSpace;\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataStartLine +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                            REACHED(6);\n                            if( bByteOnly )\n                            {\n                                for( int iBand = 0; iBand \u003c nBands; ++iBand )\n                                    pabyLocalData[iBand] =\n                                        pabyLocalSrcData[iBand];\n                            }\n                            else\n                            {\n                                GDALCopyWords(\n                                    pabyLocalSrcData,\n                                    eDataType, nDTSize,\n                                    pabyLocalData,\n                                    eBufType,\n                                    static_cast\u003cint\u003e(nBandSpace),\n                                    nBandCount );\n                            }\n                            pabyLocalData += nPixelSpace;\n                        }\n                    }\n                }\n            }\n        }\n        else  // Contig, striped organized.\n        {\n            GByte* pabyData = static_cast\u003cGByte*\u003e(pData);\n            for( int y = 0; y \u003c nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast\u003cint\u003e((y + 0.5) * dfSrcYInc);\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nBlockId = m_nBlockYOff;\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                if( nCurOffset == 0 )\n                {\n                    REACHED(7);\n                    for( int x = 0; x \u003c nBufXSize; ++x )\n                    {\n                        GDALCopyWords(\n                            \u0026dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace + x * nPixelSpace,\n                            eBufType, static_cast\u003cint\u003e(nBandSpace),\n                            nBandCount);\n                    }\n                }\n                else\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    const int nBaseByteOffsetIm_nBlock =\n                        (nYOffsetIm_nBlock * m_nBlockXSize + nXOff) *\n                        nBandsPerBlockDTSize;\n\n                    if( bNoXResamplingNoTypeChange \u0026\u0026 nBands == nBandCount \u0026\u0026\n                        nPixelSpace == nBandsPerBlockDTSize )\n                    {\n                        REACHED(8);\n                        if( !oFetcher.FetchBytes(\n                               pabyLocalData,\n                               nCurOffset + nBaseByteOffsetIm_nBlock,\n                               nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                               bIsComplex, nBlockId) )\n                        {\n                            return CE_Failure;\n                        }\n                    }\n                    else\n                    {\n                        const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                            nCurOffset + nBaseByteOffsetIm_nBlock,\n                            nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                            bIsComplex, nBlockId);\n                        if( pabyLocalSrcData == nullptr )\n                            return CE_Failure;\n\n                        if( bByteNoXResampling )\n                        {\n                            REACHED(9);\n                            CopyContigByteMultiBand(\n                                pabyLocalSrcData,\n                                nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                static_cast\u003cint\u003e(nPixelSpace),\n                                nBufXSize,\n                                nBandCount);\n                        }\n                        else if( bByteOnly )\n                        {\n                            REACHED(10);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x \u003c nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                const int nSrcPixelMinusXOff =\n                                    static_cast\u003cint\u003e(dfSrcX);\n                                for( int iBand = 0;\n                                     iBand \u003c nBandCount;\n                                     ++iBand )\n                                {\n                                    pabyLocalData[x * nPixelSpace + iBand] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize +\n                                                         iBand];\n                                }\n                            }\n                        }\n                        else\n                        {\n                            REACHED(11);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x \u003c nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                int nSrcPixelMinusXOff =\n                                    static_cast\u003cint\u003e(dfSrcX);\n                                GDALCopyWords(\n                                    pabyLocalSrcData +\n                                    nSrcPixelMinusXOff * nBandsPerBlockDTSize,\n                                    eDataType, nDTSize,\n                                    pabyLocalData + x * nPixelSpace,\n                                    eBufType,\n                                    static_cast\u003cint\u003e(nBandSpace),\n                                    nBandCount );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else  // Non-contig reading case.\n    {\n        if( !FetchBuffer::bMinimizeIO \u0026\u0026 TIFFIsTiled( m_hTIFF ) )\n        {\n            for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* const pabyData =\n                    static_cast\u003cGByte*\u003e(pData) + iBand * nBandSpace;\n                for( int y = 0; y \u003c nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast\u003cint\u003e((y + 0.5) * dfSrcYInc);\n                    const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                    const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n\n                    int nBaseByteOffsetIm_nBlock =\n                        nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                    if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                    {\n                        REACHED(12);\n                        nBaseByteOffsetIm_nBlock += (nBand - 1) * nDTSize;\n                    }\n                    else\n                    {\n                        REACHED(13);\n                    }\n\n                    if( bNoXResampling )\n                    {\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        int nBlockXOff = nXOff / m_nBlockXSize;\n                        int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                        if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(14);\n                            nBlockId += m_nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(15);\n                        }\n                        int nXOffsetInBlock = nXOff % m_nBlockXSize;\n\n                        int x = 0;\n                        while( x \u003c nBufXSize )\n                        {\n                            const int nByteOffsetIm_nBlock =\n                                nBaseByteOffsetIm_nBlock +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n                            const toff_t nCurOffset = panOffsets[nBlockId];\n                            const int nUsedBlockWidth =\n                                std::min(\n                                    m_nBlockXSize - nXOffsetInBlock,\n                                    nBufXSize - x );\n                            int nIters = nUsedBlockWidth;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(16);\n                                GDALCopyWords(\n                                    \u0026dfNoData, GDT_Float64, 0,\n                                    pabyLocalData, eBufType,\n                                    static_cast\u003cint\u003e(nPixelSpace),\n                                    nIters);\n                                pabyLocalData += nIters * nPixelSpace;\n                            }\n                            else\n                            {\n                                if( bNoTypeChange \u0026\u0026\n                                    nPixelSpace == nBandsPerBlockDTSize )\n                                {\n                                    REACHED(17);\n                                    if( !oFetcher.FetchBytes(\n                                           pabyLocalData,\n                                           nCurOffset + nByteOffsetIm_nBlock,\n                                           (nIters - 1) * nBandsPerBlock + 1,\n                                           nDTSize,\n                                           bIsByteSwapped, bIsComplex,\n                                           nBlockId) )\n                                    {\n                                        return CE_Failure;\n                                    }\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    const GByte* pabyLocalSrcData =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nByteOffsetIm_nBlock,\n                                            (nIters - 1) * nBandsPerBlock + 1,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId );\n                                    if( pabyLocalSrcData == nullptr )\n                                        return CE_Failure;\n\n                                    REACHED(18);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData, eDataType,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData, eBufType,\n                                        static_cast\u003cint\u003e(nPixelSpace),\n                                        nIters );\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                            }\n\n                            nXOffsetInBlock = 0;\n                            ++nBlockXOff;\n                            ++nBlockId;\n                            x += nUsedBlockWidth;\n                        }\n                    }\n                    else\n                    {\n                        // Non-contig reading, tiled, potential resampling and\n                        // data type change.\n\n                        const GByte* pabyLocalSrcDataStartLine = nullptr;\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                        int nCurBlockXOff = 0;\n                        int nNextBlockXOff = 0;\n                        toff_t nCurOffset = 0;\n                        for( int x = 0; x \u003c nBufXSize; ++x, dfSrcX += dfSrcXInc)\n                        {\n                            const int nSrcPixel = static_cast\u003cint\u003e(dfSrcX);\n                            if( nSrcPixel \u003e= nNextBlockXOff )\n                            {\n                                const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                                nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                                nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                                int nBlockId =\n                                    nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                                if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                                {\n                                    REACHED(19);\n                                    nBlockId += m_nBlocksPerBand * (nBand - 1);\n                                }\n                                else\n                                {\n                                    REACHED(20);\n                                }\n                                nCurOffset = panOffsets[nBlockId];\n                                if( nCurOffset != 0 )\n                                {\n                                    pabyLocalSrcDataStartLine =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nBaseByteOffsetIm_nBlock,\n                                            m_nBlockXSize * nBandsPerBlock,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId);\n                                    if( pabyLocalSrcDataStartLine == nullptr )\n                                        return CE_Failure;\n                                }\n                            }\n                            const int nXOffsetInBlock =\n                                nSrcPixel - nCurBlockXOff;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(21);\n                                GDALCopyWords( \u0026dfNoData, GDT_Float64, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                                pabyLocalData += nPixelSpace;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    pabyLocalSrcDataStartLine +\n                                    nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                                REACHED(22);\n                                if( bByteOnly )\n                                {\n                                    *pabyLocalData = *pabyLocalSrcData;\n                                }\n                                else\n                                {\n                                    GDALCopyWords(pabyLocalSrcData,\n                                                eDataType, 0,\n                                                pabyLocalData,\n                                                eBufType, 0,\n                                                1);\n                                }\n                                pabyLocalData += nPixelSpace;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else  // Non-contig reading, striped.\n        {\n            for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* pabyData =\n                    static_cast\u003cGByte *\u003e(pData) + iBand * nBandSpace;\n                for( int y = 0; y \u003c nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast\u003cint\u003e((y + 0.5) * dfSrcYInc);\n                    const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                    const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                    int nBlockId = m_nBlockYOff;\n                    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    {\n                        REACHED(23);\n                        nBlockId += m_nBlocksPerBand * (nBand - 1);\n                    }\n                    else\n                    {\n                        REACHED(24);\n                    }\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(25);\n                        GDALCopyWords(\n                            \u0026dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace,\n                            eBufType,\n                            static_cast\u003cint\u003e(nPixelSpace),\n                            nBufXSize);\n                    }\n                    else\n                    {\n                        int nBaseByteOffsetIm_nBlock =\n                            (nYOffsetIm_nBlock * m_nBlockXSize + nXOff) *\n                            nBandsPerBlockDTSize;\n                        if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                            nBaseByteOffsetIm_nBlock += (nBand - 1) * nDTSize;\n\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        if( bNoXResamplingNoTypeChange \u0026\u0026\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(26);\n                            if( !oFetcher.FetchBytes(\n                                pabyLocalData,\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId) )\n                            {\n                                return CE_Failure;\n                            }\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcData == nullptr )\n                                return CE_Failure;\n\n                            if( bNoXResamplingNoTypeChange )\n                            {\n                                REACHED(27);\n                                GDALCopyWords(pabyLocalSrcData,\n                                              eDataType, nBandsPerBlockDTSize,\n                                              pabyLocalData, eBufType,\n                                              static_cast\u003cint\u003e(nPixelSpace),\n                                              nBufXSize);\n                            }\n                            else if( bByteOnly )\n                            {\n                                REACHED(28);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x \u003c nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast\u003cint\u003e(dfSrcX);\n                                    pabyLocalData[x * nPixelSpace] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize];\n                                }\n                            }\n                            else\n                            {\n                                REACHED(29);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x \u003c nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast\u003cint\u003e(dfSrcX);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData +\n                                        nSrcPixelMinusXOff *\n                                        nBandsPerBlockDTSize,\n                                        eDataType, 0,\n                                        pabyLocalData + x * nPixelSpace,\n                                        eBufType, 0,\n                                        1 );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffDataset::DirectIO( GDALRWFlag eRWFlag,\n                            int nXOff, int nYOff, int nXSize, int nYSize,\n                            void * pData, int nBufXSize, int nBufYSize,\n                            GDALDataType eBufType,\n                            int nBandCount, int *panBandMap,\n                            GSpacing nPixelSpace, GSpacing nLineSpace,\n                            GSpacing nBandSpace,\n                            GDALRasterIOExtraArg* psExtraArg )\n{\n    const GDALDataType eDataType = GetRasterBand(1)-\u003eGetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read \u0026\u0026\n          m_nCompression == COMPRESSION_NONE \u0026\u0026\n          (m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_nPhotometric == PHOTOMETRIC_PALETTE) \u0026\u0026\n          m_nBitsPerSample == nDTSizeBits) )\n    {\n        return -1;\n    }\n    Crystalize();\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) \u0026\u0026\n        psExtraArg != nullptr \u0026\u0026\n        psExtraArg-\u003eeResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    // If the file is band interleave or only one band is requested, then\n    // fallback to band DirectIO.\n    bool bUseBandRasterIO = false;\n    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1 )\n    {\n        bUseBandRasterIO = true;\n    }\n    else\n    {\n        // For simplicity, only deals with \"naturally ordered\" bands.\n        for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n        {\n            if( panBandMap[iBand] != iBand + 1)\n            {\n                bUseBandRasterIO = true;\n                break;\n            }\n        }\n    }\n    if( bUseBandRasterIO )\n    {\n        CPLErr eErr = CE_None;\n        for( int iBand = 0; eErr == CE_None \u0026\u0026 iBand \u003c nBandCount; ++iBand )\n        {\n            eErr = GetRasterBand(panBandMap[iBand])-\u003eRasterIO(\n                eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                static_cast\u003cGByte *\u003e(pData) + iBand * nBandSpace,\n                nBufXSize, nBufYSize,\n                eBufType,\n                nPixelSpace, nLineSpace,\n                psExtraArg );\n        }\n        return eErr;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -\u003e %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // No need to look if overviews can satisfy the request as it has already */\n    // been done in GTiffDataset::IRasterIO().\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( GetAccess() == GA_Update )\n    {\n        FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_hTIFF ) );\n    }\n\n    if( TIFFIsTiled( m_hTIFF ) )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        const size_t nTempBufferForCommonDirectIOSize =\n            static_cast\u003csize_t\u003e(static_cast\u003cGPtrDiff_t\u003e(m_nBlockXSize) * m_nBlockYSize * nDTSize *\n            ((m_nPlanarConfig == PLANARCONFIG_CONTIG) ? nBands : 1));\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            m_pTempBufferForCommonDirectIO =\n                static_cast\u003cGByte *\u003e(\n                    VSI_MALLOC_VERBOSE(nTempBufferForCommonDirectIOSize) );\n            if( m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_pTempBufferForCommonDirectIO,\n                                     nTempBufferForCommonDirectIOSize);\n\n        return CommonDirectIO( oFetcher,\n                               nXOff, nYOff, nXSize, nYSize,\n                               pData, nBufXSize, nBufYSize,\n                               eBufType,\n                               nBandCount, panBandMap,\n                               nPixelSpace, nLineSpace,\n                              nBandSpace );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, \u0026panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    void** ppData =\n        static_cast\u003cvoid **\u003e( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets =\n        static_cast\u003cvsi_l_offset *\u003e(\n            VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes =\n        static_cast\u003csize_t *\u003e( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands = nBands;\n    const int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n    {\n        eErr = CE_Failure;\n    }\n    // For now we always allocate a temp buffer as it is easier.\n    else\n        // if( nXSize != nBufXSize || nYSize != nBufYSize ||\n        //   eBufType != eDataType ||\n        //   nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n        //   check if the user buffer is large enough )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast\u003cdouble\u003e( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None \u0026\u0026 iLine \u003c nReqYSize; ++iLine )\n    {\n        ppData[iLine] =\n            static_cast\u003cGByte *\u003e(pTmpBuffer) +\n            iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize \u003c nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast\u003cint\u003e((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / m_nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % m_nBlockYSize;\n        const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0)  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * m_nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL(nReqYSize, ppData, panOffsets, panSizes, fp);\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None \u0026\u0026 TIFFIsByteSwapped(m_hTIFF) )\n    {\n        for( int iLine = 0; iLine \u003c nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2);\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize);\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast\u003cdouble\u003e( nBufXSize );\n    if( eErr == CE_None \u0026\u0026 pTmpBuffer != nullptr )\n    {\n        for( int iY = 0; iY \u003c nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize \u003c= nYSize ?\n                iY : static_cast\u003cint\u003e((iY + 0.5) * dfSrcYInc);\n            // Optimization: no resampling, no data type change, number of\n            // bands requested == number of bands and buffer is packed\n            // pixel-interleaved.\n            if( nBufXSize == nXSize \u0026\u0026 nContigBands == nBandCount \u0026\u0026\n                eDataType == eBufType \u0026\u0026\n                nBandSpace == nDTSize \u0026\u0026\n                nPixelSpace == nBandCount * nBandSpace )\n            {\n                memcpy(\n                    static_cast\u003cGByte *\u003e(pData) + iY * nLineSpace,\n                    ppData[iSrcY],\n                    static_cast\u003csize_t\u003e(nReqXSize * nPixelSpace) );\n            }\n            // Other optimization: no resampling, no data type change,\n            // data type is Byte.\n            else if( nBufXSize == nXSize \u0026\u0026\n                     eDataType == eBufType \u0026\u0026 eDataType == GDT_Byte )\n            {\n                GByte* pabySrcData = static_cast\u003cGByte *\u003e(ppData[iSrcY]);\n                GByte* pabyDstData =\n                    static_cast\u003cGByte *\u003e(pData) + iY * nLineSpace;\n                if( nBandSpace == 1 \u0026\u0026 nPixelSpace \u003e nBandCount )\n                {\n                    // Buffer is pixel-interleaved (with some stridding\n                    // between pixels).\n                    CopyContigByteMultiBand( pabySrcData, nSrcPixelSize,\n                                             pabyDstData,\n                                             static_cast\u003cint\u003e(nPixelSpace),\n                                             nBufXSize, nBandCount );\n                }\n                else\n                {\n                    for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                    {\n                        GDALCopyWords(\n                            pabySrcData + iBand, GDT_Byte, nSrcPixelSize,\n                            pabyDstData + iBand * nBandSpace,\n                            GDT_Byte, static_cast\u003cint\u003e(nPixelSpace),\n                            nBufXSize );\n                    }\n                }\n            }\n            else  // General case.\n            {\n                for( int iBand = 0; iBand \u003c nBandCount; ++iBand )\n                {\n                    GByte* pabySrcData =\n                        static_cast\u003cGByte *\u003e(ppData[iSrcY]) + iBand * nDTSize;\n                    GByte* pabyDstData =\n                        static_cast\u003cGByte *\u003e(pData) +\n                        iBand * nBandSpace + iY * nLineSpace;\n                    if( eDataType == GDT_Byte \u0026\u0026 eBufType == GDT_Byte )\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX \u003c nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast\u003cint\u003e(dfSrcX);\n                            pabyDstData[iX * nPixelSpace] =\n                                pabySrcData[iSrcX * nSrcPixelSize];\n                        }\n                    }\n                    else\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX \u003c nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast\u003cint\u003e(dfSrcX);\n                            GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                        eDataType, 0,\n                                        pabyDstData + iX * nPixelSpace,\n                                        eBufType, 0, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                         CacheMultiRange()                            */\n/************************************************************************/\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\nstatic bool CheckTrailer(const GByte* strileData, vsi_l_offset nStrileSize)\n{\n    GByte abyTrailer[4];\n    memcpy(abyTrailer,strileData + nStrileSize, 4);\n    GByte abyLastBytes[4] = {};\n    if( nStrileSize \u003e= 4 )\n        memcpy(abyLastBytes, strileData + nStrileSize - 4, 4);\n    else\n    {\n        // The last bytes will be zero due to the above {} initialization,\n        // and that's what should be in abyTrailer too when the trailer is\n        // correct.\n        memcpy(abyLastBytes, strileData, static_cast\u003csize_t\u003e(nStrileSize));\n    }\n    return memcmp(abyTrailer, abyLastBytes, 4) == 0;\n}\n#endif\n\nvoid* GTiffRasterBand::CacheMultiRange( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nBufXSize, int nBufYSize,\n                                        GDALRasterIOExtraArg* psExtraArg )\n{\n    void* pBufferedData = nullptr;\n    // Same logic as in GDALRasterBand::IRasterIO()\n    double dfXOff = nXOff;\n    double dfYOff = nYOff;\n    double dfXSize = nXSize;\n    double dfYSize = nYSize;\n    if( psExtraArg-\u003ebFloatingPointWindowValidity )\n    {\n        dfXOff = psExtraArg-\u003edfXOff;\n        dfYOff = psExtraArg-\u003edfYOff;\n        dfXSize = psExtraArg-\u003edfXSize;\n        dfYSize = psExtraArg-\u003edfYSize;\n    }\n    const double dfSrcXInc = dfXSize / static_cast\u003cdouble\u003e( nBufXSize );\n    const double dfSrcYInc = dfYSize / static_cast\u003cdouble\u003e( nBufYSize );\n    const double EPS = 1e-10;\n    const int nBlockX1 = static_cast\u003cint\u003e(std::max(0.0, (0+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY1 = static_cast\u003cint\u003e(std::max(0.0, (0+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n    const int nBlockX2 = static_cast\u003cint\u003e(std::min(static_cast\u003cdouble\u003e(nRasterXSize - 1), (nBufXSize-1+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY2 = static_cast\u003cint\u003e(std::min(static_cast\u003cdouble\u003e(nRasterYSize - 1), (nBufYSize-1+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    const int nBlockXCount = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    const int nBlockYCount = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n    const int nBlockCount = nBlockXCount * nBlockYCount;\n    struct StrileData\n    {\n        vsi_l_offset nOffset;\n        vsi_l_offset nByteCount;\n        bool         bTryMask;\n    };\n    std::map\u003cint, StrileData\u003e oMapStrileToOffsetByteCount;\n\n    // Dedicated method to retrieved the offset and size in an efficient way\n    // when m_bBlockOrderRowMajor and m_bLeaderSizeAsUInt4 conditions are\n    // met.\n    // Except for the last block, we just read the offset from the TIFF offset\n    // array, and retrieve the size in the leader 4 bytes that come before the\n    // payload.\n    auto OptimizedRetrievalOfOffsetSize = [\u0026](int nBlockId,\n                                               vsi_l_offset\u0026 nOffset,\n                                               vsi_l_offset\u0026 nSize,\n                                               size_t nTotalSize,\n                                               size_t nMaxRawBlockCacheSize)\n    {\n        bool bTryMask = m_poGDS-\u003em_bMaskInterleavedWithImagery;\n        nOffset = TIFFGetStrileOffset(m_poGDS-\u003em_hTIFF, nBlockId);\n        if( nOffset \u003e= 4 )\n        {\n            if( nBlockId == nBlockCount - 1 )\n            {\n                // Special case for the last block. As there is no next block\n                // from which to retrieve an offset, use the good old method\n                // that consists in reading the ByteCount array.\n                if( bTryMask \u0026\u0026\n                    m_poGDS-\u003eGetRasterBand(1)-\u003eGetMaskBand() \u0026\u0026\n                    m_poGDS-\u003em_poMaskDS )\n                {\n                    auto nMaskOffset = TIFFGetStrileOffset(m_poGDS-\u003em_poMaskDS-\u003em_hTIFF, nBlockId);\n                    if( nMaskOffset )\n                    {\n                        nSize = nMaskOffset + TIFFGetStrileByteCount(m_poGDS-\u003em_poMaskDS-\u003em_hTIFF, nBlockId) - nOffset;\n                    }\n                    else\n                    {\n                        bTryMask = false;\n                    }\n                }\n                if( nSize == 0 )\n                {\n                    nSize = TIFFGetStrileByteCount(m_poGDS-\u003em_hTIFF, nBlockId);\n                }\n                if( nSize \u0026\u0026 m_poGDS-\u003em_bTrailerRepeatedLast4BytesRepeated )\n                {\n                    nSize += 4;\n                }\n            }\n            else\n            {\n                auto nOffsetNext = TIFFGetStrileOffset(m_poGDS-\u003em_hTIFF, nBlockId + 1);\n                if( nOffsetNext \u003e nOffset )\n                {\n                    nSize = nOffsetNext - nOffset;\n                }\n                else\n                {\n                    // Shouldn't happen for a compliant file\n                    if( nOffsetNext != 0 )\n                    {\n                        CPLDebug(\"GTiff\",\n                                    \"Tile %d is not located after %d\", nBlockId + 1, nBlockId);\n                    }\n                    bTryMask = false;\n                    nSize = TIFFGetStrileByteCount(m_poGDS-\u003em_hTIFF, nBlockId);\n                    if( m_poGDS-\u003em_bTrailerRepeatedLast4BytesRepeated )\n                        nSize += 4;\n                }\n            }\n            if( nSize )\n            {\n                nOffset -= 4;\n                nSize += 4;\n                if( nTotalSize + nSize \u003c nMaxRawBlockCacheSize )\n                {\n                    StrileData data;\n                    data.nOffset = nOffset;\n                    data.nByteCount = nSize;\n                    data.bTryMask = bTryMask;\n                    oMapStrileToOffsetByteCount[nBlockId] = data;\n                }\n            }\n        }\n        else\n        {\n            // Sparse tile\n            StrileData data;\n            data.nOffset = 0;\n            data.nByteCount = 0;\n            data.bTryMask = false;\n            oMapStrileToOffsetByteCount[nBlockId] = data;\n        }\n    };\n\n    // This lambda fills m_poDS-\u003em_oCacheStrileToOffsetByteCount (and\n    // m_poDS-\u003em_poMaskDS-\u003em_oCacheStrileToOffsetByteCount, when there is a mask)\n    // from the temporary oMapStrileToOffsetByteCount.\n    auto FillCacheStrileToOffsetByteCount = [\u0026](\n        const std::vector\u003cvsi_l_offset\u003e\u0026 anOffsets,\n        const std::vector\u003csize_t\u003e\u0026 anSizes,\n        const std::vector\u003cvoid*\u003e apData)\n    {\n        CPLAssert( m_poGDS-\u003em_bLeaderSizeAsUInt4 );\n        size_t i = 0;\n        vsi_l_offset nLastOffset = 0;\n        for( const auto\u0026 entry: oMapStrileToOffsetByteCount )\n        {\n            const auto nBlockId = entry.first;\n            const auto nOffset = entry.second.nOffset;\n            const auto nSize = entry.second.nByteCount;\n            if( nOffset == 0 )\n            {\n                // Sparse tile\n                m_poGDS-\u003em_oCacheStrileToOffsetByteCount.insert(\n                    nBlockId,\n                    std::pair\u003cvsi_l_offset, vsi_l_offset\u003e(0, 0));\n                continue;\n            }\n\n            if( nOffset \u003c nLastOffset )\n            {\n                // shouldn't happen normally if tiles are sorted\n                i = 0;\n            }\n            nLastOffset = nOffset;\n            while( i \u003c anOffsets.size() \u0026\u0026 !(\n                    nOffset \u003e= anOffsets[i] \u0026\u0026\n                    nOffset + nSize \u003c= anOffsets[i] + anSizes[i]) )\n            {\n                i++;\n            }\n            CPLAssert( i \u003c anOffsets.size() );\n            CPLAssert( nOffset \u003e= anOffsets[i] );\n            CPLAssert( nOffset + nSize \u003c= anOffsets[i] + anSizes[i] );\n            GUInt32 nSizeFromLeader;\n            memcpy(\u0026nSizeFromLeader,\n                    static_cast\u003cGByte*\u003e(apData[i]) + nOffset - anOffsets[i],\n                    sizeof(nSizeFromLeader));\n            CPL_LSBPTR32(\u0026nSizeFromLeader);\n            bool bOK = true;\n            constexpr int nLeaderSize = 4;\n            const int nTrailerSize =\n                (m_poGDS-\u003em_bTrailerRepeatedLast4BytesRepeated ? 4 : 0);\n            if( nSizeFromLeader \u003e nSize - nLeaderSize - nTrailerSize )\n            {\n                CPLDebug(\"GTiff\",\n                            \"Inconsistent block size from in leader of block %d\", nBlockId);\n                bOK = false;\n            }\n            else if( m_poGDS-\u003em_bTrailerRepeatedLast4BytesRepeated )\n            {\n                // Check trailer consistency\n                const GByte* strileData = static_cast\u003cGByte*\u003e(\n                    apData[i]) + nOffset - anOffsets[i] + nLeaderSize;\n                if( !CheckTrailer(strileData, nSizeFromLeader) )\n                {\n                    CPLDebug(\"GTiff\",\n                            \"Inconsistent trailer of block %d\", nBlockId);\n                    bOK = false;\n                }\n            }\n            if( !bOK )\n            {\n                return false;\n            }\n\n            {\n                const vsi_l_offset nRealOffset = nOffset + nLeaderSize;\n                const vsi_l_offset nRealSize = nSizeFromLeader;\n#ifdef DEBUG_VERBOSE\n                CPLDebug(\"GTiff\", \"Block %d found at offset \"\n                            CPL_FRMT_GUIB \" with size \" CPL_FRMT_GUIB,\n                            nBlockId, nRealOffset, nRealSize);\n#endif\n                m_poGDS-\u003em_oCacheStrileToOffsetByteCount.insert(\n                    nBlockId,\n                    std::pair\u003cvsi_l_offset, vsi_l_offset\u003e(nRealOffset, nRealSize));\n            }\n\n            // Processing of mask\n            if( !(entry.second.bTryMask \u0026\u0026\n                  m_poGDS-\u003em_bMaskInterleavedWithImagery \u0026\u0026\n                  m_poGDS-\u003eGetRasterBand(1)-\u003eGetMaskBand() \u0026\u0026\n                  m_poGDS-\u003em_poMaskDS ) )\n            {\n                continue;\n            }\n\n            bOK = false;\n            const vsi_l_offset nMaskOffsetWithLeader =\n                nOffset + nLeaderSize + nSizeFromLeader + nTrailerSize;\n            if( nMaskOffsetWithLeader + nLeaderSize \u003c= anOffsets[i] + anSizes[i] )\n            {\n                GUInt32 nMaskSizeFromLeader;\n                memcpy(\u0026nMaskSizeFromLeader,\n                        static_cast\u003cGByte*\u003e(apData[i]) + nMaskOffsetWithLeader - anOffsets[i],\n                        sizeof(nMaskSizeFromLeader));\n                CPL_LSBPTR32(\u0026nMaskSizeFromLeader);\n                if( nMaskOffsetWithLeader + nLeaderSize + nMaskSizeFromLeader + nTrailerSize \u003c= anOffsets[i] + anSizes[i] )\n                {\n                    bOK = true;\n                    if( m_poGDS-\u003em_bTrailerRepeatedLast4BytesRepeated )\n                    {\n                        // Check trailer consistency\n                        const GByte* strileMaskData = static_cast\u003cGByte*\u003e(\n                            apData[i]) + nOffset - anOffsets[i] + nLeaderSize + nSizeFromLeader + nTrailerSize + nLeaderSize;\n                        if( !CheckTrailer(strileMaskData, nMaskSizeFromLeader) )\n                        {\n                            CPLDebug(\"GTiff\",\n                                \"Inconsistent trailer of mask of block %d\", nBlockId);\n                            bOK = false;\n                        }\n                    }\n                }\n                if( bOK )\n                {\n                    const vsi_l_offset nRealOffset = nOffset + nLeaderSize + nSizeFromLeader + nTrailerSize + nLeaderSize;\n                    const vsi_l_offset nRealSize = nMaskSizeFromLeader;\n#ifdef DEBUG_VERBOSE\n                    CPLDebug(\"GTiff\", \"Mask of block %d found at offset \"\n                            CPL_FRMT_GUIB \" with size \" CPL_FRMT_GUIB,\n                            nBlockId, nRealOffset, nRealSize);\n#endif\n\n                    m_poGDS-\u003em_poMaskDS-\u003em_oCacheStrileToOffsetByteCount.insert(\n                        nBlockId,\n                        std::pair\u003cvsi_l_offset, vsi_l_offset\u003e(nRealOffset, nRealSize));\n                }\n            }\n            if( !bOK )\n            {\n                CPLDebug(\"GTiff\",\n                          \"Mask for block %d is not properly interleaved with imagery block\",\n                          nBlockId);\n            }\n        }\n        return true;\n    };\n#endif\n\n    thandle_t th = TIFFClientdata( m_poGDS-\u003em_hTIFF );\n    if( !VSI_TIFFHasCachedRanges(th) )\n    {\n        std::vector\u003c std::pair\u003cvsi_l_offset, size_t\u003e \u003e aOffsetSize;\n        size_t nTotalSize = 0;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        const unsigned int nMaxRawBlockCacheSize =\n            atoi(CPLGetConfigOption(\"GDAL_MAX_RAW_BLOCK_CACHE_SIZE\",\n                                    \"10485760\"));\n        bool bGoOn = true;\n        for( int iY = nBlockY1; bGoOn \u0026\u0026 iY \u003c= nBlockY2; iY ++)\n        {\n            for( int iX = nBlockX1; bGoOn \u0026\u0026 iX \u003c= nBlockX2; iX ++)\n            {\n                GDALRasterBlock* poBlock = TryGetLockedBlockRef(iX, iY);\n                if( poBlock != nullptr )\n                {\n                    poBlock-\u003eDropLock();\n                    continue;\n                }\n                int nBlockId = iX + iY * nBlocksPerRow;\n                if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    nBlockId += (nBand - 1) * m_poGDS-\u003em_nBlocksPerBand;\n                vsi_l_offset nOffset = 0;\n                vsi_l_offset nSize = 0;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n                if( (m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG || m_poGDS-\u003enBands == 1) \u0026\u0026\n                    !m_poGDS-\u003em_bStreamingIn \u0026\u0026\n                    m_poGDS-\u003em_bBlockOrderRowMajor \u0026\u0026 m_poGDS-\u003em_bLeaderSizeAsUInt4 )\n                {\n                    OptimizedRetrievalOfOffsetSize(nBlockId, nOffset, nSize, nTotalSize, nMaxRawBlockCacheSize);\n                }\n                else\n#endif\n                {\n                    CPL_IGNORE_RET_VAL(m_poGDS-\u003eIsBlockAvailable(nBlockId, \u0026nOffset, \u0026nSize));\n                }\n                if( nSize )\n                {\n                    if( nTotalSize + nSize \u003c nMaxRawBlockCacheSize )\n                    {\n#ifdef DEBUG_VERBOSE\n                        CPLDebug(\"GTiff\",\n                                 \"Precaching for block (%d, %d), \"\n                                 CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB,\n                                 iX, iY,\n                                 nOffset,\n                                 nOffset + static_cast\u003csize_t\u003e(nSize) - 1);\n#endif\n                        aOffsetSize.push_back(\n                            std::pair\u003cvsi_l_offset, size_t\u003e\n                                (nOffset, static_cast\u003csize_t\u003e(nSize)) );\n                        nTotalSize += static_cast\u003csize_t\u003e(nSize);\n                    }\n                    else\n                    {\n                        bGoOn = false;\n                    }\n                }\n            }\n        }\n\n        std::sort(aOffsetSize.begin(), aOffsetSize.end());\n\n        if( nTotalSize \u003e 0 )\n        {\n            pBufferedData = VSI_MALLOC_VERBOSE(nTotalSize);\n            if( pBufferedData )\n            {\n                std::vector\u003cvsi_l_offset\u003e anOffsets;\n                std::vector\u003csize_t\u003e anSizes;\n                std::vector\u003cvoid*\u003e apData;\n                anOffsets.push_back(aOffsetSize[0].first);\n                apData.push_back(static_cast\u003cGByte *\u003e(pBufferedData));\n                size_t nChunkSize = aOffsetSize[0].second;\n                size_t nAccOffset = 0;\n                // Try to merge contiguous or slightly overlapping ranges\n                for( size_t i = 0; i \u003c aOffsetSize.size()-1; i++ )\n                {\n                    if ( aOffsetSize[i].first \u003c aOffsetSize[i+1].first \u0026\u0026\n                         aOffsetSize[i].first + aOffsetSize[i].second \u003e= aOffsetSize[i+1].first )\n                    {\n                        const auto overlap = aOffsetSize[i].first + aOffsetSize[i].second - aOffsetSize[i+1].first;\n                        // That should always be the case for well behaved\n                        // TIFF files.\n                        if( aOffsetSize[i+1].second \u003e overlap )\n                        {\n                            nChunkSize += static_cast\u003csize_t\u003e(\n                                aOffsetSize[i+1].second - overlap);\n                        }\n                    }\n                    else \n                    {\n                        //terminate current block\n                        anSizes.push_back(nChunkSize);\n#ifdef DEBUG_VERBOSE\n                        CPLDebug(\"GTiff\", \"Requesting range [\" CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB \"]\",\n                                 anOffsets.back(), anOffsets.back() + anSizes.back() - 1);\n#endif\n                        nAccOffset += nChunkSize;\n                        //start a new range\n                        anOffsets.push_back(aOffsetSize[i+1].first);\n                        apData.push_back(static_cast\u003cGByte*\u003e(pBufferedData) + nAccOffset);\n                        nChunkSize = aOffsetSize[i+1].second;\n                    }\n                }\n                //terminate last block \n                anSizes.push_back(nChunkSize);\n#ifdef DEBUG_VERBOSE\n                CPLDebug(\"GTiff\", \"Requesting range [\" CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB \"]\",\n                            anOffsets.back(), anOffsets.back() + anSizes.back() - 1);\n#endif\n\n                VSILFILE* fp = VSI_TIFFGetVSILFile(th);\n\n\n                if( VSIFReadMultiRangeL(\n                                    static_cast\u003cint\u003e(anSizes.size()),\n                                    \u0026apData[0],\n                                    \u0026anOffsets[0],\n                                    \u0026anSizes[0],\n                                    fp ) == 0 )\n                {\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n                    if( !oMapStrileToOffsetByteCount.empty() \u0026\u0026\n                        !FillCacheStrileToOffsetByteCount(\n                                                anOffsets, anSizes, apData) )\n                    {\n                        // Retry without optimization\n                        CPLFree(pBufferedData);\n                        m_poGDS-\u003em_bLeaderSizeAsUInt4 = false;\n                        void* pRet = CacheMultiRange(\n                            nXOff, nYOff, nXSize, nYSize,\n                            nBufXSize, nBufYSize, psExtraArg );\n                        m_poGDS-\u003em_bLeaderSizeAsUInt4 = true;\n                        return pRet;\n                    }\n\n#endif\n                    VSI_TIFFSetCachedRanges( th,\n                                             static_cast\u003cint\u003e(anSizes.size()),\n                                             \u0026apData[0],\n                                             \u0026anOffsets[0],\n                                             \u0026anSizes[0] );\n                }\n            }\n        }\n    }\n    return pBufferedData;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IRasterIO( GDALRWFlag eRWFlag,\n                                   int nXOff, int nYOff, int nXSize, int nYSize,\n                                   void * pData, int nBufXSize, int nBufYSize,\n                                   GDALDataType eBufType,\n                                   GSpacing nPixelSpace, GSpacing nLineSpace,\n                                   GDALRasterIOExtraArg* psExtraArg )\n{\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"RasterIO(%d, %d, %d, %d, %d, %d)\",\n              nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize );\n#endif\n\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize \u003c nXSize \u0026\u0026 nBufYSize \u003c nYSize )\n    {\n        int bTried = FALSE;\n        ++m_poGDS-\u003em_nJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nPixelSpace, nLineSpace,\n                                 psExtraArg,\n                                 \u0026bTried );\n        --m_poGDS-\u003em_nJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( m_poGDS-\u003em_eVirtualMemIOUsage != GTiffDataset::VirtualMemIOEnum::NO )\n    {\n        const int nErr = m_poGDS-\u003eVirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            1, \u0026nBand, nPixelSpace, nLineSpace, 0, psExtraArg);\n        if( nErr \u003e= 0 )\n            return static_cast\u003cCPLErr\u003e(nErr);\n    }\n    if( m_poGDS-\u003em_bDirectIO )\n    {\n        int nErr = DirectIO(eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                            pData, nBufXSize, nBufYSize, eBufType,\n                            nPixelSpace, nLineSpace, psExtraArg);\n        if( nErr \u003e= 0 )\n            return static_cast\u003cCPLErr\u003e(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( m_poGDS-\u003eeAccess == GA_ReadOnly \u0026\u0026\n        eRWFlag == GF_Read \u0026\u0026\n        m_poGDS-\u003eHasOptimizedReadMultiRange() )\n    {\n        GTiffRasterBand* poBandForCache = this;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n        if( !m_poGDS-\u003em_bStreamingIn \u0026\u0026\n            m_poGDS-\u003em_bBlockOrderRowMajor \u0026\u0026\n            m_poGDS-\u003em_bLeaderSizeAsUInt4 \u0026\u0026\n            m_poGDS-\u003em_bMaskInterleavedWithImagery \u0026\u0026\n            m_poGDS-\u003em_poImageryDS )\n        {\n            poBandForCache = cpl::down_cast\u003cGTiffRasterBand*\u003e(\n                m_poGDS-\u003em_poImageryDS-\u003eGetRasterBand(1));\n        }\n#endif\n        pBufferedData = poBandForCache-\u003eCacheMultiRange(\n                                        nXOff, nYOff, nXSize, nYSize,\n                                        nBufXSize, nBufYSize,\n                                        psExtraArg);\n    }\n\n    if( m_poGDS-\u003enBands != 1 \u0026\u0026\n        m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        eRWFlag == GF_Read \u0026\u0026\n        nXSize == nBufXSize \u0026\u0026 nYSize == nBufYSize )\n    {\n        const int nBlockX1 = nXOff / nBlockXSize;\n        const int nBlockY1 = nYOff / nBlockYSize;\n        const int nBlockX2 = (nXOff + nXSize - 1) / nBlockXSize;\n        const int nBlockY2 = (nYOff + nYSize - 1) / nBlockYSize;\n        const int nXBlocks = nBlockX2 - nBlockX1 + 1;\n        const int nYBlocks = nBlockY2 - nBlockY1 + 1;\n        const GIntBig nRequiredMem =\n            static_cast\u003cGIntBig\u003e(m_poGDS-\u003enBands) * nXBlocks * nYBlocks *\n            nBlockXSize * nBlockYSize *\n            GDALGetDataTypeSizeBytes(eDataType);\n        if( nRequiredMem \u003e GDALGetCacheMax64() )\n        {\n            if( !m_poGDS-\u003em_bHasWarnedDisableAggressiveBandCaching )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Disable aggressive band caching. \"\n                          \"Cache not big enough. \"\n                          \"At least \" CPL_FRMT_GIB \" bytes necessary\",\n                          nRequiredMem );\n                m_poGDS-\u003em_bHasWarnedDisableAggressiveBandCaching = true;\n            }\n            m_poGDS-\u003em_bLoadingOtherBands = true;\n        }\n    }\n\n    ++m_poGDS-\u003em_nJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamRasterBand::IRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                      pData, nBufXSize, nBufYSize, eBufType,\n                                      nPixelSpace, nLineSpace, psExtraArg );\n    --m_poGDS-\u003em_nJPEGOverviewVisibilityCounter;\n\n    m_poGDS-\u003em_bLoadingOtherBands = false;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( m_poGDS-\u003em_hTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRasterBand::IGetDataCoverageStatus( int nXOff, int nYOff,\n                                             int nXSize, int nYSize,\n                                             int nMaskFlagStop,\n                                             double* pdfDataPct)\n{\n    if( eAccess == GA_Update )\n        m_poGDS-\u003eFlushCache();\n\n    const int iXBlockStart = nXOff / nBlockXSize;\n    const int iXBlockEnd = (nXOff + nXSize - 1) / nBlockXSize;\n    const int iYBlockStart = nYOff / nBlockYSize;\n    const int iYBlockEnd = (nYOff + nYSize - 1) / nBlockYSize;\n    int nStatus = 0;\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS-\u003em_hTIFF ));\n    GIntBig nPixelsData = 0;\n    // We need to compute this here as it might not have been computed\n    // previously (which sucks...)\n    nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    for( int iY = iYBlockStart; iY \u003c= iYBlockEnd; ++iY )\n    {\n        for( int iX = iXBlockStart; iX \u003c= iXBlockEnd; ++iX )\n        {\n            const int nBlockIdBand0 =\n                iX + iY * nBlocksPerRow;\n            int nBlockId = nBlockIdBand0;\n            if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                nBlockId = nBlockIdBand0 + (nBand - 1) * m_poGDS-\u003em_nBlocksPerBand;\n            vsi_l_offset nOffset = 0;\n            vsi_l_offset nLength = 0;\n            bool bHasData = false;\n            if( !m_poGDS-\u003eIsBlockAvailable(nBlockId,\u0026nOffset,\u0026nLength) )\n            {\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n            }\n            else\n            {\n                if( m_poGDS-\u003em_nCompression == COMPRESSION_NONE \u0026\u0026\n                    m_poGDS-\u003eeAccess == GA_ReadOnly \u0026\u0026\n                    (!m_bNoDataSet || m_dfNoDataValue == 0.0) )\n                {\n                    VSIRangeStatus eStatus =\n                          VSIFGetRangeStatusL( fp, nOffset, nLength );\n                    if( eStatus == VSI_RANGE_STATUS_HOLE )\n                    {\n                        nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n                    }\n                    else\n                    {\n                        bHasData = true;\n                    }\n                }\n                else\n                {\n                    bHasData = true;\n                }\n            }\n            if( bHasData )\n            {\n                const int nXBlockRight =\n                    ( iX * nBlockXSize \u003e INT_MAX - nBlockXSize ) ? INT_MAX :\n                    (iX + 1) * nBlockXSize;\n                const int nYBlockBottom =\n                    ( iY * nBlockYSize \u003e INT_MAX - nBlockYSize ) ? INT_MAX :\n                    (iY + 1) * nBlockYSize;\n\n                nPixelsData +=\n                    (std::min( nXBlockRight, nXOff + nXSize ) -\n                     std::max( iX * nBlockXSize, nXOff )) *\n                    (std::min( nYBlockBottom, nYOff + nYSize ) -\n                     std::max( iY * nBlockYSize, nYOff ));\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_DATA;\n            }\n            if( nMaskFlagStop != 0 \u0026\u0026 (nMaskFlagStop \u0026 nStatus) != 0 )\n            {\n                if( pdfDataPct )\n                    *pdfDataPct = -1.0;\n                return nStatus;\n            }\n        }\n    }\n    if( pdfDataPct )\n        *pdfDataPct =\n          100.0 * nPixelsData /\n          (static_cast\u003cGIntBig\u003e(nXSize) * nYSize);\n    return nStatus;\n}\n\n/************************************************************************/\n/*                             ReadStrile()                             */\n/************************************************************************/\n\nbool GTiffDataset::ReadStrile(int nBlockId,\n                              void* pOutputBuffer,\n                              GPtrDiff_t nBlockReqSize)\n{\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    std::pair\u003cvsi_l_offset, vsi_l_offset\u003e oPair;\n    if( m_oCacheStrileToOffsetByteCount.tryGet(nBlockId, oPair) )\n    {\n        // For the mask, use the parent TIFF handle to get cached ranges\n        auto th = TIFFClientdata(\n            m_poImageryDS \u0026\u0026 m_bMaskInterleavedWithImagery ?\n                m_poImageryDS-\u003em_hTIFF : m_hTIFF);\n        void* pInputBuffer = VSI_TIFFGetCachedRange( th, oPair.first,\n                                                static_cast\u003csize_t\u003e(oPair.second) );\n        if( pInputBuffer \u0026\u0026\n            TIFFReadFromUserBuffer( m_hTIFF, nBlockId,\n                                    pInputBuffer, static_cast\u003csize_t\u003e(oPair.second),\n                                    pOutputBuffer, nBlockReqSize ) )\n        {\n            return true;\n        }\n    }\n#endif\n\n    // For debugging\n    if( m_poBaseDS )\n        m_poBaseDS-\u003em_bHasUsedReadEncodedAPI = true;\n    else\n        m_bHasUsedReadEncodedAPI = true;\n\n    if( TIFFIsTiled( m_hTIFF ) )\n    {\n        if( TIFFReadEncodedTile( m_hTIFF, nBlockId, pOutputBuffer,\n                                    nBlockReqSize ) == -1\n            \u0026\u0026 !m_bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                        \"TIFFReadEncodedTile() failed.\" );\n\n            return false;\n        }\n    }\n    else\n    {\n        if( TIFFReadEncodedStrip( m_hTIFF, nBlockId, pOutputBuffer,\n                                    nBlockReqSize ) == -1\n            \u0026\u0026 !m_bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                    \"TIFFReadEncodedStrip() failed.\" );\n\n            return false;\n        }\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    m_poGDS-\u003eCrystalize();\n\n    GPtrDiff_t nBlockBufSize = 0;\n    if( TIFFIsTiled(m_poGDS-\u003em_hTIFF) )\n    {\n        nBlockBufSize = static_cast\u003cGPtrDiff_t\u003e(TIFFTileSize( m_poGDS-\u003em_hTIFF ));\n    }\n    else\n    {\n        CPLAssert( nBlockXOff == 0 );\n        nBlockBufSize = static_cast\u003cGPtrDiff_t\u003e(TIFFStripSize( m_poGDS-\u003em_hTIFF ));\n    }\n\n    CPLAssert(nBlocksPerRow != 0);\n    const int nBlockIdBand0 =\n        nBlockXOff + nBlockYOff * nBlocksPerRow;\n    int nBlockId = nBlockIdBand0;\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId = nBlockIdBand0 + (nBand - 1) * m_poGDS-\u003em_nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    auto nBlockReqSize = nBlockBufSize;\n\n    if( nBlockYOff * nBlockYSize \u003e nRasterYSize - nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize)\n            * (nBlockYSize - static_cast\u003cint\u003e(\n                (static_cast\u003cGIntBig\u003e(nBlockYOff + 1) * nBlockYSize)\n                    % nRasterYSize));\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip or tile that doesn't exist yet.      */\n/*      Just set to zeros and return.                                   */\n/* -------------------------------------------------------------------- */\n    vsi_l_offset nOffset = 0;\n    bool bErrOccurred = false;\n    if( nBlockId != m_poGDS-\u003em_nLoadedBlock \u0026\u0026\n        !m_poGDS-\u003eIsBlockAvailable(nBlockId, \u0026nOffset, nullptr, \u0026bErrOccurred) )\n    {\n        NullBlock( pImage );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    if( m_poGDS-\u003em_bStreamingIn \u0026\u0026\n        !(m_poGDS-\u003enBands \u003e 1 \u0026\u0026\n          m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n          nBlockId == m_poGDS-\u003em_nLoadedBlock) )\n    {\n        if( nOffset \u003c VSIFTellL(m_poGDS-\u003em_fpL) )\n        {\n            ReportError( CE_Failure, CPLE_NotSupported,\n                      \"Trying to load block %d at offset \" CPL_FRMT_GUIB\n                      \" whereas current pos is \" CPL_FRMT_GUIB\n                      \" (backward read not supported)\",\n                      nBlockId, static_cast\u003cGUIntBig\u003e(nOffset),\n                      static_cast\u003cGUIntBig\u003e(VSIFTellL(m_poGDS-\u003em_fpL)) );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case (separate, onesampleperpixel)                */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( m_poGDS-\u003enBands == 1\n        || m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        if( nBlockReqSize \u003c nBlockBufSize )\n            memset( pImage, 0, nBlockBufSize );\n\n        if( !m_poGDS-\u003eReadStrile(nBlockId, pImage, nBlockReqSize) )\n        {\n            memset( pImage, 0, nBlockBufSize );\n            return CE_Failure;\n        }\n    }\n    else\n    {\n/* -------------------------------------------------------------------- */\n/*      Load desired block                                              */\n/* -------------------------------------------------------------------- */\n        eErr = m_poGDS-\u003eLoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n        {\n            memset( pImage, 0,\n                    static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize\n                    * GDALGetDataTypeSizeBytes(eDataType) );\n            return eErr;\n        }\n\n        const int nWordBytes = m_poGDS-\u003em_nBitsPerSample / 8;\n        GByte* pabyImage = m_poGDS-\u003em_pabyBlockBuf + (nBand - 1) * nWordBytes;\n\n        GDALCopyWords64(pabyImage, eDataType, m_poGDS-\u003enBands * nWordBytes,\n                    pImage, eDataType, nWordBytes,\n                    static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize);\n\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n    }\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    CacheMaskForBlock(nBlockXOff,nBlockYOff);\n#endif\n    return eErr;\n}\n\n/************************************************************************/\n/*                           CacheMaskForBlock()                       */\n/************************************************************************/\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\nvoid GTiffRasterBand::CacheMaskForBlock( int nBlockXOff, int nBlockYOff )\n\n{\n    // Preload mask data if layout compatible and we have cached ranges\n    if( m_poGDS-\u003em_bMaskInterleavedWithImagery \u0026\u0026\n        m_poGDS-\u003eGetRasterBand(1)-\u003eGetMaskBand() \u0026\u0026\n        m_poGDS-\u003em_poMaskDS \u0026\u0026\n        VSI_TIFFHasCachedRanges( TIFFClientdata(m_poGDS-\u003em_hTIFF) ) \u0026\u0026\n        m_poGDS-\u003em_poMaskDS-\u003em_oCacheStrileToOffsetByteCount.contains(\n            nBlockXOff + nBlockYOff * nBlocksPerRow) )\n    {\n        GDALRasterBlock *poBlock = m_poGDS-\u003em_poMaskDS-\u003eGetRasterBand(1)-\u003e\n            GetLockedBlockRef(nBlockXOff,nBlockYOff);\n        if( poBlock )\n            poBlock-\u003eDropLock();\n    }\n}\n#endif\n\n/************************************************************************/\n/*                       FillCacheForOtherBands()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::FillCacheForOtherBands( int nBlockXOff, int nBlockYOff )\n\n{\n/* -------------------------------------------------------------------- */\n/*      In the fairly common case of pixel interleaved 8bit data        */\n/*      that is multi-band, lets push the rest of the data into the     */\n/*      block cache too, to avoid (hopefully) having to redecode it.    */\n/*                                                                      */\n/*      Our following logic actually depends on the fact that the       */\n/*      this block is already loaded, so subsequent calls will end      */\n/*      up back in this method and pull from the loaded block.          */\n/*                                                                      */\n/*      Be careful not entering this portion of code from               */\n/*      the other bands, otherwise we'll get very deep nested calls     */\n/*      and O(nBands^2) performance !                                   */\n/*                                                                      */\n/*      If there are many bands and the block cache size is not big     */\n/*      enough to accommodate the size of all the blocks, don't enter   */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( m_poGDS-\u003enBands != 1 \u0026\u0026\n        m_poGDS-\u003enBands \u003c 128 \u0026\u0026 // avoid caching for datasets with too many bands\n        !m_poGDS-\u003em_bLoadingOtherBands \u0026\u0026\n        static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType) \u003c\n        GDALGetCacheMax64() / m_poGDS-\u003enBands )\n    {\n        m_poGDS-\u003em_bLoadingOtherBands = true;\n\n        for( int iOtherBand = 1; iOtherBand \u003c= m_poGDS-\u003enBands; ++iOtherBand )\n        {\n            if( iOtherBand == nBand )\n                continue;\n\n            GDALRasterBlock *poBlock = m_poGDS-\u003eGetRasterBand(iOtherBand)-\u003e\n                GetLockedBlockRef(nBlockXOff,nBlockYOff);\n            if( poBlock == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n            poBlock-\u003eDropLock();\n        }\n\n        m_poGDS-\u003em_bLoadingOtherBands = false;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    m_poGDS-\u003eCrystalize();\n\n    if( m_poGDS-\u003em_bDebugDontWriteBlocks )\n        return CE_None;\n\n    if( m_poGDS-\u003em_bWriteError )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        return CE_Failure;\n    }\n\n    CPLAssert(nBlocksPerRow != 0);\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images                                */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE\n        || m_poGDS-\u003enBands == 1 )\n    {\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow\n            + (nBand - 1) * m_poGDS-\u003em_nBlocksPerBand;\n\n        const CPLErr eErr =\n            m_poGDS-\u003eWriteEncodedTileOrStrip(nBlockId, pImage, true);\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n     // Why 10 ? Somewhat arbitrary\n    constexpr int MAX_BANDS_FOR_DIRTY_CHECK = 10;\n    GDALRasterBlock* apoBlocks[MAX_BANDS_FOR_DIRTY_CHECK] = {};\n    const int nBands = m_poGDS-\u003enBands;\n    bool bAllBlocksDirty = false;\n\n/* -------------------------------------------------------------------- */\n/*     If all blocks are cached and dirty then we do not need to reload */\n/*     the tile/strip from disk                                         */\n/* -------------------------------------------------------------------- */\n    if( nBands \u003c= MAX_BANDS_FOR_DIRTY_CHECK )\n    {\n        bAllBlocksDirty = true;\n        for( int iBand = 0; iBand \u003c nBands; ++iBand )\n        {\n            if( iBand + 1 != nBand )\n            {\n                apoBlocks[iBand] =\n                    cpl::down_cast\u003cGTiffRasterBand *\u003e(\n                        m_poGDS-\u003eGetRasterBand( iBand + 1 ))\n                            -\u003eTryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n                if( apoBlocks[iBand] == nullptr )\n                {\n                    bAllBlocksDirty = false;\n                }\n                else if( !apoBlocks[iBand]-\u003eGetDirty() )\n                {\n                    apoBlocks[iBand]-\u003eDropLock();\n                    apoBlocks[iBand] = nullptr;\n                    bAllBlocksDirty = false;\n                }\n            }\n            else\n                apoBlocks[iBand] = nullptr;\n        }\n#if DEBUG_VERBOSE\n        if( bAllBlocksDirty )\n            CPLDebug(\"GTIFF\", \"Saved reloading block %d\", nBlockId);\n        else\n            CPLDebug(\"GTIFF\", \"Must reload block %d\", nBlockId);\n#endif\n    }\n\n    {\n        const CPLErr eErr = m_poGDS-\u003eLoadBlockBuf( nBlockId, !bAllBlocksDirty );\n        if( eErr != CE_None )\n        {\n            if( nBands \u003c= MAX_BANDS_FOR_DIRTY_CHECK )\n            {\n                for( int iBand = 0; iBand \u003c nBands; ++iBand )\n                {\n                    if( apoBlocks[iBand] != nullptr )\n                        apoBlocks[iBand]-\u003eDropLock();\n                }\n            }\n            return eErr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    const int nWordBytes = m_poGDS-\u003em_nBitsPerSample / 8;\n\n    for( int iBand = 0; iBand \u003c nBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast\u003cGByte *\u003e( pImage );\n        }\n        else\n        {\n            if( nBands \u003c= MAX_BANDS_FOR_DIRTY_CHECK )\n                poBlock = apoBlocks[iBand];\n            else\n                poBlock = cpl::down_cast\u003cGTiffRasterBand *\u003e(\n                    m_poGDS-\u003eGetRasterBand( iBand + 1 ))\n                        -\u003eTryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock-\u003eGetDirty() )\n            {\n                poBlock-\u003eDropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast\u003cGByte *\u003e( poBlock-\u003eGetDataRef() );\n        }\n\n        GByte *pabyOut = m_poGDS-\u003em_pabyBlockBuf + iBand*nWordBytes;\n\n        GDALCopyWords64(pabyThisImage, eDataType, nWordBytes,\n                      pabyOut, eDataType, nWordBytes * nBands,\n                      static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize);\n\n        if( poBlock != nullptr )\n        {\n            poBlock-\u003eMarkClean();\n            poBlock-\u003eDropLock();\n        }\n    }\n\n    if( bAllBlocksDirty )\n    {\n        // We can synchronously write the block now.\n        const CPLErr eErr =\n            m_poGDS-\u003eWriteEncodedTileOrStrip(nBlockId, m_poGDS-\u003em_pabyBlockBuf, true);\n        m_poGDS-\u003em_bLoadedBlockDirty = false;\n        return eErr;\n    }\n\n    m_poGDS-\u003em_bLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           SetDescription()                           */\n/************************************************************************/\n\nvoid GTiffRasterBand::SetDescription( const char *pszDescription )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( pszDescription == nullptr )\n        pszDescription = \"\";\n\n    if( m_osDescription != pszDescription )\n        m_poGDS-\u003em_bMetadataChanged = true;\n\n    m_osDescription = pszDescription;\n}\n\n/************************************************************************/\n/*                           GetDescription()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetDescription() const\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    return m_osDescription;\n}\n\n/************************************************************************/\n/*                             GetOffset()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetOffset( int *pbSuccess )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = m_bHaveOffsetScale;\n    return m_dfOffset;\n}\n\n/************************************************************************/\n/*                             SetOffset()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetOffset( double dfNewValue )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( !m_bHaveOffsetScale || dfNewValue != m_dfOffset )\n        m_poGDS-\u003em_bMetadataChanged = true;\n\n    m_bHaveOffsetScale = true;\n    m_dfOffset = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                              GetScale()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetScale( int *pbSuccess )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = m_bHaveOffsetScale;\n    return m_dfScale;\n}\n\n/************************************************************************/\n/*                              SetScale()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetScale( double dfNewValue )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( !m_bHaveOffsetScale || dfNewValue != m_dfScale )\n        m_poGDS-\u003em_bMetadataChanged = true;\n\n    m_bHaveOffsetScale = true;\n    m_dfScale = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            GetUnitType()                             */\n/************************************************************************/\n\nconst char* GTiffRasterBand::GetUnitType()\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    if( m_osUnitType.empty() )\n    {\n        m_poGDS-\u003eLookForProjection();\n        if( m_poGDS-\u003em_pszVertUnit )\n            return m_poGDS-\u003em_pszVertUnit;\n    }\n\n    return m_osUnitType.c_str();\n}\n\n/************************************************************************/\n/*                           SetUnitType()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetUnitType( const char* pszNewValue )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    CPLString osNewValue(pszNewValue ? pszNewValue : \"\");\n    if( osNewValue.compare(m_osUnitType) != 0 )\n        m_poGDS-\u003em_bMetadataChanged = true;\n\n    m_osUnitType = osNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadataDomainList()\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    return CSLDuplicate(m_oGTiffMDMD.GetDomainList());\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return m_oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( m_poGDS-\u003em_bStreamingOut \u0026\u0026 m_poGDS-\u003em_bCrystalized )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        if( papszMD != nullptr || GetMetadata(pszDomain) != nullptr )\n        {\n            m_poGDS-\u003em_bMetadataChanged = true;\n            // Cancel any existing metadata from PAM file.\n            if( eAccess == GA_Update \u0026\u0026\n                GDALPamRasterBand::GetMetadata(pszDomain) != nullptr )\n                GDALPamRasterBand::SetMetadata(nullptr, pszDomain);\n        }\n    }\n\n    return m_oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetMetadataItem( const char * pszName,\n                                              const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszName != nullptr \u0026\u0026 pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"TIFF\") )\n    {\n        int nBlockXOff = 0;\n        int nBlockYOff = 0;\n\n        if( EQUAL(pszName, \"JPEGTABLES\") )\n        {\n            uint32 nJPEGTableSize = 0;\n            void* pJPEGTable = nullptr;\n            if( TIFFGetField( m_poGDS-\u003em_hTIFF, TIFFTAG_JPEGTABLES,\n                              \u0026nJPEGTableSize, \u0026pJPEGTable ) != 1 ||\n                pJPEGTable == nullptr || nJPEGTableSize \u003e INT_MAX )\n            {\n                return nullptr;\n            }\n            char* const pszHex =\n                CPLBinaryToHex( nJPEGTableSize, static_cast\u003cconst GByte*\u003e(pJPEGTable) );\n            const char* pszReturn = CPLSPrintf(\"%s\", pszHex);\n            CPLFree(pszHex);\n\n            return pszReturn;\n        }\n\n        if( EQUAL(pszName, \"IFD_OFFSET\") )\n        {\n            return CPLSPrintf( CPL_FRMT_GUIB,\n                               static_cast\u003cGUIntBig\u003e(m_poGDS-\u003em_nDirOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_OFFSET_%d_%d\",\n                         \u0026nBlockXOff, \u0026nBlockYOff ) == 2 )\n        {\n            nBlocksPerRow =\n                DIV_ROUND_UP(m_poGDS-\u003enRasterXSize, m_poGDS-\u003em_nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(m_poGDS-\u003enRasterYSize, m_poGDS-\u003em_nBlockYSize);\n            if( nBlockXOff \u003c 0 || nBlockXOff \u003e= nBlocksPerRow ||\n                nBlockYOff \u003c 0 || nBlockYOff \u003e= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * m_poGDS-\u003em_nBlocksPerBand;\n            }\n\n            vsi_l_offset nOffset = 0;\n            if( !m_poGDS-\u003eIsBlockAvailable(nBlockId, \u0026nOffset) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf( CPL_FRMT_GUIB, static_cast\u003cGUIntBig\u003e(nOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_SIZE_%d_%d\",\n                    \u0026nBlockXOff, \u0026nBlockYOff ) == 2 )\n        {\n            nBlocksPerRow =\n                DIV_ROUND_UP(m_poGDS-\u003enRasterXSize, m_poGDS-\u003em_nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(m_poGDS-\u003enRasterYSize, m_poGDS-\u003em_nBlockYSize);\n            if( nBlockXOff \u003c 0 || nBlockXOff \u003e= nBlocksPerRow ||\n                nBlockYOff \u003c 0 || nBlockYOff \u003e= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * m_poGDS-\u003em_nBlocksPerBand;\n            }\n\n            vsi_l_offset nByteCount = 0;\n            if( !m_poGDS-\u003eIsBlockAvailable(nBlockId, nullptr, \u0026nByteCount) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf(CPL_FRMT_GUIB, static_cast\u003cGUIntBig\u003e(nByteCount));\n        }\n    }\n    return m_oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadataItem( const char *pszName,\n                                         const char *pszValue,\n                                         const char *pszDomain )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( m_poGDS-\u003em_bStreamingOut \u0026\u0026 m_poGDS-\u003em_bCrystalized )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        m_poGDS-\u003em_bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update \u0026\u0026\n            GDALPamRasterBand::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamRasterBand::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    return m_oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRasterBand::GetColorInterpretation()\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    return m_eBandInterp;\n}\n\n/************************************************************************/\n/*                         GTiffGetAlphaValue()                         */\n/************************************************************************/\n\nuint16 GTiffGetAlphaValue(const char* pszValue, uint16 nDefault)\n{\n    if( pszValue == nullptr )\n        return nDefault;\n    if( EQUAL(pszValue, \"YES\") )\n        return DEFAULT_ALPHA_TYPE;\n    if( EQUAL(pszValue, \"PREMULTIPLIED\") )\n        return EXTRASAMPLE_ASSOCALPHA;\n    if( EQUAL(pszValue, \"NON-PREMULTIPLIED\") )\n        return EXTRASAMPLE_UNASSALPHA;\n    if( EQUAL(pszValue, \"NO\") ||\n        EQUAL(pszValue, \"UNSPECIFIED\") )\n        return EXTRASAMPLE_UNSPECIFIED;\n\n    return nDefault;\n}\n\n/************************************************************************/\n/*                       SetColorInterpretation()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorInterpretation( GDALColorInterp eInterp )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( eInterp == m_eBandInterp )\n        return CE_None;\n\n    m_eBandInterp = eInterp;\n\n    if( eAccess != GA_Update )\n    {\n        CPLDebug( \"GTIFF\", \"ColorInterpretation %s for band %d goes to PAM \"\n                  \"instead of TIFF tag\",\n                  GDALGetColorInterpretationName(eInterp), nBand );\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n    }\n\n    m_poGDS-\u003em_bNeedsRewrite = true;\n    m_poGDS-\u003em_bMetadataChanged = true;\n\n    // Try to autoset TIFFTAG_PHOTOMETRIC = PHOTOMETRIC_RGB if possible.\n    if( m_poGDS-\u003enBands \u003e= 3 \u0026\u0026\n        m_poGDS-\u003em_nCompression != COMPRESSION_JPEG \u0026\u0026\n        m_poGDS-\u003em_nPhotometric != PHOTOMETRIC_RGB \u0026\u0026\n        CSLFetchNameValue( m_poGDS-\u003em_papszCreationOptions,\n                           \"PHOTOMETRIC\" ) == nullptr \u0026\u0026\n        ((nBand == 1 \u0026\u0026 eInterp == GCI_RedBand) ||\n         (nBand == 2 \u0026\u0026 eInterp == GCI_GreenBand) ||\n         (nBand == 3 \u0026\u0026 eInterp == GCI_BlueBand)) )\n    {\n        if( m_poGDS-\u003eGetRasterBand(1)-\u003eGetColorInterpretation() == GCI_RedBand \u0026\u0026\n            m_poGDS-\u003eGetRasterBand(2)-\u003eGetColorInterpretation() == GCI_GreenBand \u0026\u0026\n            m_poGDS-\u003eGetRasterBand(3)-\u003eGetColorInterpretation() == GCI_BlueBand )\n        {\n            m_poGDS-\u003em_nPhotometric = PHOTOMETRIC_RGB;\n            TIFFSetField( m_poGDS-\u003em_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          m_poGDS-\u003em_nPhotometric );\n\n            // We need to update the number of extra samples.\n            uint16 *v = nullptr;\n            uint16 count = 0;\n            const uint16 nNewExtraSamplesCount =\n                static_cast\u003cuint16\u003e(m_poGDS-\u003enBands - 3);\n            if( m_poGDS-\u003enBands \u003e= 4 \u0026\u0026\n                TIFFGetField( m_poGDS-\u003em_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              \u0026count, \u0026v ) \u0026\u0026\n                count \u003e nNewExtraSamplesCount )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast\u003cuint16 *\u003e( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v + count - nNewExtraSamplesCount,\n                        nNewExtraSamplesCount * sizeof(uint16) );\n\n                TIFFSetField( m_poGDS-\u003em_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n        return CE_None;\n    }\n\n    // On the contrary, cancel the above if needed\n    if( m_poGDS-\u003em_nCompression != COMPRESSION_JPEG \u0026\u0026\n        m_poGDS-\u003em_nPhotometric == PHOTOMETRIC_RGB \u0026\u0026\n        CSLFetchNameValue( m_poGDS-\u003em_papszCreationOptions,\n                           \"PHOTOMETRIC\") == nullptr \u0026\u0026\n        ((nBand == 1 \u0026\u0026 eInterp != GCI_RedBand) ||\n         (nBand == 2 \u0026\u0026 eInterp != GCI_GreenBand) ||\n         (nBand == 3 \u0026\u0026 eInterp != GCI_BlueBand)) )\n    {\n        m_poGDS-\u003em_nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(m_poGDS-\u003em_hTIFF, TIFFTAG_PHOTOMETRIC, m_poGDS-\u003em_nPhotometric);\n\n        // We need to update the number of extra samples.\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        const uint16 nNewExtraSamplesCount =\n            static_cast\u003cuint16\u003e(m_poGDS-\u003enBands - 1);\n        if( m_poGDS-\u003enBands \u003e= 2 )\n        {\n            TIFFGetField( m_poGDS-\u003em_hTIFF, TIFFTAG_EXTRASAMPLES, \u0026count, \u0026v );\n            if( nNewExtraSamplesCount \u003e count )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast\u003cuint16 *\u003e( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                for( int i = 0;\n                     i \u003c static_cast\u003cint\u003e(nNewExtraSamplesCount - count);\n                     ++i )\n                    pasNewExtraSamples[i] = EXTRASAMPLE_UNSPECIFIED;\n                if( count \u003e 0 )\n                {\n                    memcpy( pasNewExtraSamples + nNewExtraSamplesCount - count,\n                            v,\n                            count * sizeof(uint16) );\n                }\n\n                TIFFSetField( m_poGDS-\u003em_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n    // Mark alpha band / undefined in extrasamples.\n    if( eInterp == GCI_AlphaBand || eInterp == GCI_Undefined )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( m_poGDS-\u003em_hTIFF, TIFFTAG_EXTRASAMPLES, \u0026count, \u0026v ) )\n        {\n            const int nBaseSamples = m_poGDS-\u003em_nSamplesPerPixel - count;\n\n            if( eInterp == GCI_AlphaBand )\n            {\n                for( int i = 1; i \u003c= m_poGDS-\u003enBands; ++i )\n                {\n                    if( i != nBand \u0026\u0026\n                        m_poGDS-\u003eGetRasterBand(i)-\u003eGetColorInterpretation() ==\n                        GCI_AlphaBand )\n                    {\n                        if( i == nBaseSamples + 1 \u0026\u0026\n                            CSLFetchNameValue( m_poGDS-\u003em_papszCreationOptions,\n                                            \"ALPHA\" ) != nullptr )\n                        {\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too. \"\n                                \"Presumably ALPHA creation option is not needed\",\n                                i, nBand );\n                        }\n                        else\n                        {\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too\",\n                                i, nBand );\n                        }\n                    }\n                }\n            }\n\n            if( nBand \u003e nBaseSamples \u0026\u0026 nBand - nBaseSamples - 1 \u003c count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast\u003cuint16 *\u003e(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                if( eInterp == GCI_AlphaBand )\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        GTiffGetAlphaValue(CPLGetConfigOption(\"GTIFF_ALPHA\", nullptr),\n                                            DEFAULT_ALPHA_TYPE);\n                }\n                else\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        EXTRASAMPLE_UNSPECIFIED;\n                }\n\n                TIFFSetField( m_poGDS-\u003em_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              count, pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n\n                return CE_None;\n            }\n        }\n    }\n\n    if( m_poGDS-\u003em_nPhotometric != PHOTOMETRIC_MINISBLACK \u0026\u0026\n        CSLFetchNameValue( m_poGDS-\u003em_papszCreationOptions, \"PHOTOMETRIC\") == nullptr )\n    {\n        m_poGDS-\u003em_nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(m_poGDS-\u003em_hTIFF, TIFFTAG_PHOTOMETRIC, m_poGDS-\u003em_nPhotometric);\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffRasterBand::GetColorTable()\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( nBand == 1 )\n        return m_poGDS-\u003em_poColorTable;\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           SetColorTable()                            */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorTable( GDALColorTable * poCT )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n/* -------------------------------------------------------------------- */\n/*      Check if this is even a candidate for applying a PCT.           */\n/* -------------------------------------------------------------------- */\n    if( nBand != 1)\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() can only be called on band 1.\" );\n        return CE_Failure;\n    }\n\n    if( m_poGDS-\u003em_nSamplesPerPixel != 1 \u0026\u0026 m_poGDS-\u003em_nSamplesPerPixel != 2)\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() not supported for multi-sample TIFF \"\n                  \"files.\" );\n        return CE_Failure;\n    }\n\n    if( eDataType != GDT_Byte \u0026\u0026 eDataType != GDT_UInt16 )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() only supported for Byte or UInt16 bands \"\n                  \"in TIFF format.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Is this really a request to clear the color table?              */\n/* -------------------------------------------------------------------- */\n    if( poCT == nullptr || poCT-\u003eGetColorEntryCount() == 0 )\n    {\n        TIFFSetField( m_poGDS-\u003em_hTIFF, TIFFTAG_PHOTOMETRIC,\n                      PHOTOMETRIC_MINISBLACK );\n\n        TIFFUnsetField( m_poGDS-\u003em_hTIFF, TIFFTAG_COLORMAP );\n\n        if( m_poGDS-\u003em_poColorTable )\n        {\n            delete m_poGDS-\u003em_poColorTable;\n            m_poGDS-\u003em_poColorTable = nullptr;\n        }\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the colortable, and update the configuration.         */\n/* -------------------------------------------------------------------- */\n    int nColors = 65536;\n\n    if( eDataType == GDT_Byte )\n        nColors = 256;\n\n    unsigned short *panTRed = static_cast\u003cunsigned short *\u003e(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTGreen = static_cast\u003cunsigned short *\u003e(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTBlue = static_cast\u003cunsigned short *\u003e(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n\n    for( int iColor = 0; iColor \u003c nColors; ++iColor )\n    {\n        if( iColor \u003c poCT-\u003eGetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n            poCT-\u003eGetColorEntryAsRGB( iColor, \u0026sRGB );\n\n            panTRed[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c1);\n            panTGreen[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c2);\n            panTBlue[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c3);\n        }\n        else\n        {\n            panTRed[iColor] = 0;\n            panTGreen[iColor] = 0;\n            panTBlue[iColor] = 0;\n        }\n    }\n\n    TIFFSetField( m_poGDS-\u003em_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n    TIFFSetField( m_poGDS-\u003em_hTIFF, TIFFTAG_COLORMAP,\n                  panTRed, panTGreen, panTBlue );\n\n    CPLFree( panTRed );\n    CPLFree( panTGreen );\n    CPLFree( panTBlue );\n\n    if( m_poGDS-\u003em_poColorTable )\n        delete m_poGDS-\u003em_poColorTable;\n\n    // libtiff 3.X needs setting this in all cases (creation or update)\n    // whereas libtiff 4.X would just need it if there\n    // was no color table before.\n    m_poGDS-\u003em_bNeedsRewrite = true;\n\n    m_poGDS-\u003em_poColorTable = poCT-\u003eClone();\n    m_eBandInterp = GCI_PaletteIndex;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetNoDataValue()                           */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetNoDataValue( int * pbSuccess )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( m_bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return m_dfNoDataValue;\n    }\n\n    if( m_poGDS-\u003em_bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return m_poGDS-\u003em_dfNoDataValue;\n    }\n\n    return GDALPamRasterBand::GetNoDataValue( pbSuccess );\n}\n\n/************************************************************************/\n/*                           SetNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetNoDataValue( double dfNoData )\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( m_poGDS-\u003em_bNoDataSet \u0026\u0026 m_poGDS-\u003em_dfNoDataValue == dfNoData )\n    {\n        m_bNoDataSet = true;\n        m_dfNoDataValue = dfNoData;\n        return CE_None;\n    }\n\n    if( m_poGDS-\u003enBands \u003e 1 \u0026\u0026 m_poGDS-\u003em_eProfile == GTiffProfile::GDALGEOTIFF )\n    {\n        int bOtherBandHasNoData = FALSE;\n        const int nOtherBand = nBand \u003e 1 ? 1 : 2;\n        double dfOtherNoData = m_poGDS-\u003eGetRasterBand(nOtherBand)-\u003e\n                                    GetNoDataValue(\u0026bOtherBandHasNoData);\n        if( bOtherBandHasNoData \u0026\u0026 dfOtherNoData != dfNoData )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                 \"Setting nodata to %.18g on band %d, but band %d has nodata \"\n                 \"at %.18g. The TIFFTAG_GDAL_NODATA only support one value \"\n                 \"per dataset. This value of %.18g will be used for all bands \"\n                 \"on re-opening\",\n                 dfNoData, nBand, nOtherBand, dfOtherNoData, dfNoData);\n        }\n    }\n\n    if( m_poGDS-\u003em_bStreamingOut \u0026\u0026 m_poGDS-\u003em_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    m_poGDS-\u003em_bNoDataSet = true;\n    m_poGDS-\u003em_dfNoDataValue = dfNoData;\n\n    m_poGDS-\u003em_bNoDataChanged = true;\n\n    m_bNoDataSet = true;\n    m_dfNoDataValue = dfNoData;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                        DeleteNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::DeleteNoDataValue()\n\n{\n    m_poGDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( !m_poGDS-\u003em_bNoDataSet )\n        return CE_None;\n\n    if( m_poGDS-\u003em_bStreamingOut \u0026\u0026 m_poGDS-\u003em_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    m_poGDS-\u003em_bNoDataSet = false;\n    m_poGDS-\u003em_dfNoDataValue = -9999.0;\n\n    m_poGDS-\u003em_bNoDataChanged = true;\n\n    m_bNoDataSet = false;\n    m_dfNoDataValue = -9999.0;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             NullBlock()                              */\n/*                                                                      */\n/*      Set the block data to the null value if it is set, or zero      */\n/*      if there is no null data value.                                 */\n/************************************************************************/\n\nvoid GTiffRasterBand::NullBlock( void *pData )\n\n{\n    const GPtrDiff_t nWords = static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize;\n    const int nChunkSize = std::max(1, GDALGetDataTypeSizeBytes(eDataType));\n\n    int bNoDataSetIn = FALSE;\n    const double dfNoData = GetNoDataValue( \u0026bNoDataSetIn );\n    if( !bNoDataSetIn )\n    {\n#ifdef ESRI_BUILD\n        if( m_poGDS-\u003em_nBitsPerSample \u003e= 2 )\n            memset( pData, 0, nWords * nChunkSize );\n        else\n            memset( pData, 1, nWords * nChunkSize );\n#else\n        memset( pData, 0, nWords * nChunkSize );\n#endif\n    }\n    else\n    {\n        // Will convert nodata value to the right type and copy efficiently.\n        GDALCopyWords64( \u0026dfNoData, GDT_Float64, 0,\n                       pData, eDataType, nChunkSize, nWords);\n    }\n}\n\n/************************************************************************/\n/*                          GetOverviewCount()                          */\n/************************************************************************/\n\nint GTiffRasterBand::GetOverviewCount()\n\n{\n    m_poGDS-\u003eScanDirectories();\n\n    if( m_poGDS-\u003em_nOverviewCount \u003e 0 )\n    {\n        return m_poGDS-\u003em_nOverviewCount;\n    }\n\n    const int nOverviewCount = GDALRasterBand::GetOverviewCount();\n    if( nOverviewCount \u003e 0 )\n        return nOverviewCount;\n\n    // Implicit JPEG overviews are normally hidden, except when doing\n    // IRasterIO() operations.\n    if( m_poGDS-\u003em_nJPEGOverviewVisibilityCounter )\n        return m_poGDS-\u003eGetJPEGOverviewCount();\n\n    return 0;\n}\n\n/************************************************************************/\n/*                            GetOverview()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetOverview( int i )\n\n{\n    m_poGDS-\u003eScanDirectories();\n\n    if( m_poGDS-\u003em_nOverviewCount \u003e 0 )\n    {\n        // Do we have internal overviews?\n        if( i \u003c 0 || i \u003e= m_poGDS-\u003em_nOverviewCount )\n            return nullptr;\n\n        return m_poGDS-\u003em_papoOverviewDS[i]-\u003eGetRasterBand(nBand);\n    }\n\n    GDALRasterBand* const poOvrBand = GDALRasterBand::GetOverview( i );\n    if( poOvrBand != nullptr )\n        return poOvrBand;\n\n    // For consistency with GetOverviewCount(), we should also test\n    // m_nJPEGOverviewVisibilityCounter, but it is also convenient to be able\n    // to query them for testing purposes.\n    if( i \u003e= 0 \u0026\u0026 i \u003c m_poGDS-\u003eGetJPEGOverviewCount() )\n        return m_poGDS-\u003em_papoJPEGOverviewDS[i]-\u003eGetRasterBand(nBand);\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           GetMaskFlags()                             */\n/************************************************************************/\n\nint GTiffRasterBand::GetMaskFlags()\n{\n    m_poGDS-\u003eScanDirectories();\n\n    if( m_poGDS-\u003em_poExternalMaskDS != nullptr )\n    {\n        return GMF_PER_DATASET;\n    }\n\n    if( m_poGDS-\u003em_poMaskDS != nullptr )\n    {\n        if( m_poGDS-\u003em_poMaskDS-\u003eGetRasterCount() == 1)\n        {\n            return GMF_PER_DATASET;\n        }\n\n        return 0;\n    }\n\n    if( m_poGDS-\u003em_bIsOverview )\n    {\n        return m_poGDS-\u003em_poBaseDS-\u003eGetRasterBand(nBand)-\u003eGetMaskFlags();\n    }\n\n    return GDALPamRasterBand::GetMaskFlags();\n}\n\n/************************************************************************/\n/*                            GetMaskBand()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetMaskBand()\n{\n    m_poGDS-\u003eScanDirectories();\n\n    if( m_poGDS-\u003em_poExternalMaskDS != nullptr )\n    {\n        return m_poGDS-\u003em_poExternalMaskDS-\u003eGetRasterBand(1);\n    }\n\n    if( m_poGDS-\u003em_poMaskDS != nullptr )\n    {\n        if( m_poGDS-\u003em_poMaskDS-\u003eGetRasterCount() == 1 )\n            return m_poGDS-\u003em_poMaskDS-\u003eGetRasterBand(1);\n\n        return m_poGDS-\u003em_poMaskDS-\u003eGetRasterBand(nBand);\n    }\n\n    if( m_poGDS-\u003em_bIsOverview )\n    {\n        GDALRasterBand* poBaseMask =\n            m_poGDS-\u003em_poBaseDS-\u003eGetRasterBand(nBand)-\u003eGetMaskBand();\n        if( poBaseMask )\n        {\n            const int nOverviews = poBaseMask-\u003eGetOverviewCount();\n            for( int i = 0; i \u003c nOverviews; i++ )\n            {\n                GDALRasterBand* poOvr = poBaseMask-\u003eGetOverview(i);\n                if( poOvr \u0026\u0026\n                    poOvr-\u003eGetXSize() == GetXSize() \u0026\u0026\n                    poOvr-\u003eGetYSize() == GetYSize() )\n                {\n                    return poOvr;\n                }\n            }\n        }\n    }\n\n    return GDALPamRasterBand::GetMaskBand();\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffSplitBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n             GTiffSplitBand( GTiffDataset *, int );\n    virtual ~GTiffSplitBand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffSplitBand()                           */\n/************************************************************************/\n\nGTiffSplitBand::GTiffSplitBand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    nBlockXSize = poDS-\u003eGetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                   void * pImage )\n\n{\n    m_poGDS-\u003eCrystalize();\n\n    // Optimization when reading the same line in a contig multi-band TIFF.\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 m_poGDS-\u003enBands \u003e 1 \u0026\u0026\n        m_poGDS-\u003em_nLoadedBlock == nBlockYOff )\n    {\n        goto extract_band_data;\n    }\n\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        m_poGDS-\u003enBands \u003e 1 )\n    {\n        if( m_poGDS-\u003em_pabyBlockBuf == nullptr )\n        {\n            m_poGDS-\u003em_pabyBlockBuf =\n                static_cast\u003cGByte *\u003e(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(m_poGDS-\u003em_hTIFF)) );\n            if( m_poGDS-\u003em_pabyBlockBuf == nullptr )\n            {\n                return CE_Failure;\n            }\n        }\n    }\n    else\n    {\n        CPLAssert(TIFFScanlineSize(m_poGDS-\u003em_hTIFF) == nBlockXSize);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS-\u003em_nLoadedBlock \u003e= nBlockYOff )\n        m_poGDS-\u003em_nLoadedBlock = -1;\n\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE \u0026\u0026 m_poGDS-\u003enBands \u003e 1 )\n    {\n        // If we change of band, we must start reading the\n        // new strip from its beginning.\n        if( m_poGDS-\u003em_nLastBandRead != nBand )\n            m_poGDS-\u003em_nLoadedBlock = -1;\n        m_poGDS-\u003em_nLastBandRead = nBand;\n    }\n\n    while( m_poGDS-\u003em_nLoadedBlock \u003c nBlockYOff )\n    {\n        ++m_poGDS-\u003em_nLoadedBlock;\n        if( TIFFReadScanline(\n                m_poGDS-\u003em_hTIFF,\n                m_poGDS-\u003em_pabyBlockBuf ? m_poGDS-\u003em_pabyBlockBuf : pImage,\n                m_poGDS-\u003em_nLoadedBlock,\n                (m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE) ?\n                 static_cast\u003cuint16\u003e(nBand - 1) : 0 ) == -1\n            \u0026\u0026 !m_poGDS-\u003em_bIgnoreReadErrors )\n        {\n            ReportError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            m_poGDS-\u003em_nLoadedBlock = -1;\n            return CE_Failure;\n        }\n    }\n\nextract_band_data:\n/* -------------------------------------------------------------------- */\n/*      Extract band data from contig buffer.                           */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS-\u003em_pabyBlockBuf != nullptr )\n    {\n        for( int iPixel = 0, iSrcOffset= nBand - 1, iDstOffset = 0;\n             iPixel \u003c nBlockXSize;\n             ++iPixel, iSrcOffset += m_poGDS-\u003enBands, ++iDstOffset )\n        {\n            static_cast\u003cGByte *\u003e(pImage)[iDstOffset] =\n                m_poGDS-\u003em_pabyBlockBuf[iSrcOffset];\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IWriteBlock( int /* nBlockXOff */, int /* nBlockYOff */,\n                                    void * /* pImage */ )\n\n{\n    ReportError( CE_Failure, CPLE_AppDefined,\n              \"Split bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffRGBABand                            */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRGBABand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n                   GTiffRGBABand( GTiffDataset *, int );\n    virtual ~GTiffRGBABand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n};\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock( int, int, void * )\n\n{\n    ReportError( CE_Failure, CPLE_AppDefined,\n              \"RGBA interpreted raster bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                  void * pImage )\n\n{\n    m_poGDS-\u003eCrystalize();\n\n    CPLAssert( nBlocksPerRow != 0 );\n    const auto nBlockBufSize = 4 * static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        for( int iBand = 0; iBand \u003c m_poGDS-\u003em_nSamplesPerPixel; iBand ++ )\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS-\u003em_nBlocksPerBand;\n            if( !m_poGDS-\u003eIsBlockAvailable(nBlockIdBand) )\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if( !m_poGDS-\u003eIsBlockAvailable(nBlockId) )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS-\u003em_pabyBlockBuf == nullptr )\n    {\n        m_poGDS-\u003em_pabyBlockBuf =\n            static_cast\u003cGByte *\u003e(\n                VSI_MALLOC3_VERBOSE( 4, nBlockXSize, nBlockYSize ) );\n        if( m_poGDS-\u003em_pabyBlockBuf == nullptr )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if( m_poGDS-\u003em_nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( m_poGDS-\u003em_hTIFF ) )\n        {\n#if TIFFLIB_VERSION \u003e 20161119\n            if( TIFFReadRGBATileExt(\n                   m_poGDS-\u003em_hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast\u003cuint32 *\u003e(m_poGDS-\u003em_pabyBlockBuf),\n                   !m_poGDS-\u003em_bIgnoreReadErrors) == 0\n                \u0026\u0026 !m_poGDS-\u003em_bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBATile(\n                   m_poGDS-\u003em_hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast\u003cuint32 *\u003e(m_poGDS-\u003em_pabyBlockBuf)) == 0\n                \u0026\u0026 !m_poGDS-\u003em_bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n\n                memset( m_poGDS-\u003em_pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n#if TIFFLIB_VERSION \u003e 20161119\n            if( TIFFReadRGBAStripExt(\n                   m_poGDS-\u003em_hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast\u003cuint32 *\u003e(m_poGDS-\u003em_pabyBlockBuf),\n                   !m_poGDS-\u003em_bIgnoreReadErrors) == 0\n                \u0026\u0026 !m_poGDS-\u003em_bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBAStrip(\n                   m_poGDS-\u003em_hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast\u003cuint32 *\u003e(m_poGDS-\u003em_pabyBlockBuf)) == 0\n                \u0026\u0026 !m_poGDS-\u003em_bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n\n                memset( m_poGDS-\u003em_pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS-\u003em_nLoadedBlock = nBlockId;\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if( nBlockYOff * nBlockYSize \u003e GetYSize() - nBlockYSize\n        \u0026\u0026 !TIFFIsTiled( m_poGDS-\u003em_hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for( int iDestLine = 0; iDestLine \u003c nThisBlockYSize; ++iDestLine )\n    {\n        const auto nSrcOffset =\n            static_cast\u003cGPtrDiff_t\u003e(nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords(\n            m_poGDS-\u003em_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n            static_cast\u003cGByte *\u003e(pImage)+static_cast\u003cGPtrDiff_t\u003e(iDestLine)*nBlockXSize, GDT_Byte, 1,\n            nBlockXSize );\n    }\n\n    if( eErr == CE_None )\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if( nBand == 1 )\n        return GCI_RedBand;\n    if( nBand == 2 )\n        return GCI_GreenBand;\n    if( nBand == 3 )\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffOddBitsBand                         */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffOddBitsBand CPL_NON_FINAL: public GTiffRasterBand\n{\n    friend class GTiffDataset;\n  public:\n\n                   GTiffOddBitsBand( GTiffDataset *, int );\n    virtual ~GTiffOddBitsBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffOddBitsBand()                         */\n/************************************************************************/\n\nGTiffOddBitsBand::GTiffOddBitsBand( GTiffDataset *m_poGDSIn, int nBandIn )\n        : GTiffRasterBand( m_poGDSIn, nBandIn )\n\n{\n    eDataType = GDT_Unknown;\n    if( (m_poGDS-\u003em_nBitsPerSample == 16 || m_poGDS-\u003em_nBitsPerSample == 24) \u0026\u0026\n        m_poGDS-\u003em_nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        eDataType = GDT_Float32;\n    // FIXME ? in autotest we currently open gcore/data/int24.tif\n    // which is declared as signed, but we consider it as unsigned\n    else if( (m_poGDS-\u003em_nSampleFormat == SAMPLEFORMAT_UINT ||\n              m_poGDS-\u003em_nSampleFormat == SAMPLEFORMAT_INT) \u0026\u0026\n             m_poGDS-\u003em_nBitsPerSample \u003c 8 )\n        eDataType = GDT_Byte;\n    else if( (m_poGDS-\u003em_nSampleFormat == SAMPLEFORMAT_UINT ||\n              m_poGDS-\u003em_nSampleFormat == SAMPLEFORMAT_INT) \u0026\u0026\n             m_poGDS-\u003em_nBitsPerSample \u003e 8 \u0026\u0026 m_poGDS-\u003em_nBitsPerSample \u003c 16 )\n        eDataType = GDT_UInt16;\n    else if( (m_poGDS-\u003em_nSampleFormat == SAMPLEFORMAT_UINT ||\n              m_poGDS-\u003em_nSampleFormat == SAMPLEFORMAT_INT) \u0026\u0026\n             m_poGDS-\u003em_nBitsPerSample \u003e 16 \u0026\u0026 m_poGDS-\u003em_nBitsPerSample \u003c 32 )\n        eDataType = GDT_UInt32;\n}\n\n/************************************************************************/\n/*                            FloatToHalf()                             */\n/************************************************************************/\n\nstatic GUInt16 FloatToHalf( GUInt32 iFloat32, bool\u0026 bHasWarned )\n{\n    GUInt32 iSign =     (iFloat32 \u003e\u003e 31) \u0026 0x00000001;\n    GUInt32 iExponent = (iFloat32 \u003e\u003e 23) \u0026 0x000000ff;\n    GUInt32 iMantissa = iFloat32         \u0026 0x007fffff;\n\n    if (iExponent == 255)\n    {\n        if (iMantissa == 0)\n        {\n/* -------------------------------------------------------------------- */\n/*       Positive or negative infinity.                                 */\n/* -------------------------------------------------------------------- */\n\n            return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) | 0x7C00);\n        }\n        else\n        {\n/* -------------------------------------------------------------------- */\n/*       NaN -- preserve sign and significand bits.                     */\n/* -------------------------------------------------------------------- */\n            if( iMantissa \u003e\u003e 13 )\n                return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) | 0x7C00 |\n                                                            (iMantissa \u003e\u003e 13));\n\n            return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) | 0x7E00);\n        }\n    }\n\n    if( iExponent \u003c= 127 - 15 )\n    {\n        // Zero, float32 denormalized number or float32 too small normalized\n        // number\n        if( 13 + 1 + 127 - 15 - iExponent \u003e= 32 )\n            return static_cast\u003cGUInt16\u003e(iSign \u003c\u003c 15);\n\n        // Return a denormalized number\n        return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) |\n                ((iMantissa | 0x00800000) \u003e\u003e (13 + 1 + 127 - 15 - iExponent)));\n    }\n    if( iExponent - (127 - 15) \u003e= 31 )\n    {\n        if( !bHasWarned )\n        {\n            bHasWarned = true;\n            float fVal = 0.0f;\n            memcpy(\u0026fVal, \u0026iFloat32, 4);\n            CPLError(\n                CE_Failure, CPLE_AppDefined,\n                \"Value %.8g is beyond range of float16. Converted to %sinf\",\n                fVal, (fVal \u003e 0) ? \"+\" : \"-\");\n        }\n        return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) | 0x7C00);  // Infinity\n    }\n\n/* -------------------------------------------------------------------- */\n/*       Normalized number.                                             */\n/* -------------------------------------------------------------------- */\n\n    iExponent = iExponent - (127 - 15);\n    iMantissa = iMantissa \u003e\u003e 13;\n\n/* -------------------------------------------------------------------- */\n/*       Assemble sign, exponent and mantissa.                          */\n/* -------------------------------------------------------------------- */\n\n    // coverity[overflow_sink]\n    return static_cast\u003cGUInt16\u003e((iSign \u003c\u003c 15) | (iExponent \u003c\u003c 10) | iMantissa);\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffOddBitsBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                      void *pImage )\n\n{\n    m_poGDS-\u003eCrystalize();\n\n    if( m_poGDS-\u003em_bWriteError )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        return CE_Failure;\n    }\n\n    if( eDataType == GDT_Float32 \u0026\u0026 m_poGDS-\u003em_nBitsPerSample != 16 )\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Writing float data with nBitsPerSample = %d is unsupported\",\n                 m_poGDS-\u003em_nBitsPerSample);\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * m_poGDS-\u003em_nBlocksPerBand;\n\n    // Only read content from disk in the CONTIG case.\n    {\n        const CPLErr eErr =\n            m_poGDS-\u003eLoadBlockBuf( nBlockId,\n                                 m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n                                 m_poGDS-\u003enBands \u003e 1 );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    const GUInt32 nMaxVal = (1U \u003c\u003c m_poGDS-\u003em_nBitsPerSample) - 1;\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images or single band images where    */\n/*      no interleaving with other data is required.                    */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE\n        || m_poGDS-\u003enBands == 1 )\n    {\n        // TODO(schwehr): Create a CplNumBits8Aligned.\n        // Bits per line rounds up to next byte boundary.\n        GInt64 nBitsPerLine = static_cast\u003cGInt64\u003e(nBlockXSize) * m_poGDS-\u003em_nBitsPerSample;\n        if( (nBitsPerLine \u0026 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) \u0026 (~7);\n\n        GPtrDiff_t iPixel = 0;\n\n        // Small optimization in 1 bit case.\n        if( m_poGDS-\u003em_nBitsPerSample == 1 )\n        {\n            for( int iY = 0; iY \u003c nBlockYSize; ++iY, iPixel += nBlockXSize )\n            {\n                GInt64 iBitOffset = iY * nBitsPerLine;\n\n                const GByte* pabySrc =\n                    static_cast\u003cconst GByte*\u003e(pImage) + iPixel;\n                auto iByteOffset = iBitOffset / 8;\n                int iX = 0;  // Used after for.\n                for( ; iX + 7 \u003c nBlockXSize; iX += 8, iByteOffset++ )\n                {\n                    int nRes = (!(!pabySrc[iX+0])) \u003c\u003c 7;\n                    nRes |= (!(!pabySrc[iX+1])) \u003c\u003c 6;\n                    nRes |= (!(!pabySrc[iX+2])) \u003c\u003c 5;\n                    nRes |= (!(!pabySrc[iX+3])) \u003c\u003c 4;\n                    nRes |= (!(!pabySrc[iX+4])) \u003c\u003c 3;\n                    nRes |= (!(!pabySrc[iX+5])) \u003c\u003c 2;\n                    nRes |= (!(!pabySrc[iX+6])) \u003c\u003c 1;\n                    nRes |= (!(!pabySrc[iX+7])) \u003c\u003c 0;\n                    m_poGDS-\u003em_pabyBlockBuf[iByteOffset] = static_cast\u003cGByte\u003e(nRes);\n                }\n                iBitOffset = iByteOffset * 8;\n                if( iX \u003c nBlockXSize )\n                {\n                    int nRes = 0;\n                    for( ; iX \u003c nBlockXSize; ++iX )\n                    {\n                        if( pabySrc[iX] )\n                            nRes |= (0x80 \u003e\u003e(iBitOffset \u0026 7) );\n                        ++iBitOffset;\n                    }\n                    m_poGDS-\u003em_pabyBlockBuf[iBitOffset\u003e\u003e3] =\n                        static_cast\u003cGByte\u003e(nRes);\n                }\n            }\n\n            m_poGDS-\u003em_bLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        if( eDataType == GDT_Float32 \u0026\u0026 m_poGDS-\u003em_nBitsPerSample == 16 )\n        {\n            for( ; iPixel \u003c static_cast\u003cGPtrDiff_t\u003e(nBlockYSize) * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = static_cast\u003cGUInt32 *\u003e(pImage)[iPixel];\n                bool bClipWarn = m_poGDS-\u003em_bClipWarn;\n                GUInt16 nHalf = FloatToHalf(nInWord, bClipWarn);\n                m_poGDS-\u003em_bClipWarn = bClipWarn;\n                reinterpret_cast\u003cGUInt16*\u003e(m_poGDS-\u003em_pabyBlockBuf)[iPixel] = nHalf;\n            }\n\n            m_poGDS-\u003em_bLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        // Initialize to zero as we set the buffer with binary or operations.\n        if( m_poGDS-\u003em_nBitsPerSample != 24 )\n            memset(m_poGDS-\u003em_pabyBlockBuf, 0, static_cast\u003csize_t\u003e((nBitsPerLine / 8) * nBlockYSize));\n\n        for( int iY = 0; iY \u003c nBlockYSize; ++iY )\n        {\n            GInt64 iBitOffset = iY * nBitsPerLine;\n\n            if( m_poGDS-\u003em_nBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord = static_cast\u003cGUInt16 *\u003e(pImage)[iPixel++];\n                    if( nInWord \u003e nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !m_poGDS-\u003em_bClipWarn )\n                        {\n                            m_poGDS-\u003em_bClipWarn = true;\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", m_poGDS-\u003em_nBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        m_poGDS-\u003em_pabyBlockBuf[iBitOffset\u003e\u003e3] =\n                            static_cast\u003cGByte\u003e(nInWord \u003e\u003e 4);\n                        // Let 4 lower bits to zero as they're going to be\n                        // overridden by the next word.\n                        m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3)+1] =\n                            static_cast\u003cGByte\u003e((nInWord \u0026 0xf) \u003c\u003c 4);\n                    }\n                    else\n                    {\n                        // Must or to preserve the 4 upper bits written\n                        // for the previous word.\n                        m_poGDS-\u003em_pabyBlockBuf[iBitOffset\u003e\u003e3] |=\n                            static_cast\u003cGByte\u003e(nInWord \u003e\u003e 8);\n                        m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3)+1] =\n                            static_cast\u003cGByte\u003e(nInWord \u0026 0xff);\n                    }\n\n                    iBitOffset += m_poGDS-\u003em_nBitsPerSample;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord = static_cast\u003cGByte *\u003e(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = static_cast\u003cGUInt16 *\u003e(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = static_cast\u003cGUInt32 *\u003e(pImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord \u003e nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !m_poGDS-\u003em_bClipWarn )\n                    {\n                        m_poGDS-\u003em_bClipWarn = true;\n                        ReportError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            m_poGDS-\u003em_nBitsPerSample );\n                    }\n                }\n\n                if( m_poGDS-\u003em_nBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 0] =\n                        static_cast\u003cGByte\u003e( nInWord );\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 1] =\n                        static_cast\u003cGByte\u003e( nInWord \u003e\u003e 8 );\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 2] =\n                        static_cast\u003cGByte\u003e( nInWord \u003e\u003e 16 );\n#else\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 0] =\n                        static_cast\u003cGByte\u003e( nInWord \u003e\u003e 16 );\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 1] =\n                        static_cast\u003cGByte\u003e( nInWord \u003e\u003e 8 );\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 2] =\n                        static_cast\u003cGByte\u003e( nInWord );\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit \u003c m_poGDS-\u003em_nBitsPerSample; ++iBit )\n                    {\n                        if( nInWord \u0026\n                            (1 \u003c\u003c (m_poGDS-\u003em_nBitsPerSample - 1 - iBit)) )\n                            m_poGDS-\u003em_pabyBlockBuf[iBitOffset\u003e\u003e3] |=\n                                ( 0x80 \u003e\u003e (iBitOffset \u0026 7) );\n                        ++iBitOffset;\n                    }\n                }\n            }\n        }\n\n        m_poGDS-\u003em_bLoadedBlockDirty = true;\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand \u003c m_poGDS-\u003enBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast\u003cGByte *\u003e( pImage );\n        }\n        else\n        {\n            poBlock =\n                cpl::down_cast\u003cGTiffOddBitsBand *\u003e(\n                    m_poGDS-\u003eGetRasterBand( iBand + 1 ))\n                        -\u003eTryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock-\u003eGetDirty() )\n            {\n                poBlock-\u003eDropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast\u003cGByte *\u003e(poBlock-\u003eGetDataRef());\n        }\n\n        const int iPixelBitSkip = m_poGDS-\u003em_nBitsPerSample * m_poGDS-\u003enBands;\n        const int iBandBitOffset = iBand * m_poGDS-\u003em_nBitsPerSample;\n\n        // Bits per line rounds up to next byte boundary.\n        GInt64 nBitsPerLine = static_cast\u003cGInt64\u003e(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine \u0026 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) \u0026 (~7);\n\n        GPtrDiff_t iPixel = 0;\n\n        if( eDataType == GDT_Float32 \u0026\u0026 m_poGDS-\u003em_nBitsPerSample == 16 )\n        {\n            for( ; iPixel \u003c static_cast\u003cGPtrDiff_t\u003e(nBlockYSize) * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = reinterpret_cast\u003cconst GUInt32 *\u003e(\n                                                        pabyThisImage)[iPixel];\n                bool bClipWarn = m_poGDS-\u003em_bClipWarn;\n                GUInt16 nHalf = FloatToHalf(nInWord, bClipWarn);\n                m_poGDS-\u003em_bClipWarn = bClipWarn;\n                reinterpret_cast\u003cGUInt16*\u003e(m_poGDS-\u003em_pabyBlockBuf)[\n                                    iPixel * m_poGDS-\u003enBands + iBand] = nHalf;\n            }\n\n            if( poBlock != nullptr )\n            {\n                poBlock-\u003eMarkClean();\n                poBlock-\u003eDropLock();\n            }\n            continue;\n        }\n\n        for( int iY = 0; iY \u003c nBlockYSize; ++iY )\n        {\n            GInt64 iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            if( m_poGDS-\u003em_nBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord =\n                        reinterpret_cast\u003cconst GUInt16 *\u003e(\n                            pabyThisImage)[iPixel++];\n                    if( nInWord \u003e nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !m_poGDS-\u003em_bClipWarn )\n                        {\n                            m_poGDS-\u003em_bClipWarn = true;\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", m_poGDS-\u003em_nBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        m_poGDS-\u003em_pabyBlockBuf[iBitOffset\u003e\u003e3] =\n                            static_cast\u003cGByte\u003e( nInWord \u003e\u003e 4 );\n                        m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3)+1] =\n                            static_cast\u003cGByte\u003e(\n                                ((nInWord \u0026 0xf) \u003c\u003c 4) |\n                                (m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3)+1] \u0026\n                                 0xf) );\n                    }\n                    else\n                    {\n                        m_poGDS-\u003em_pabyBlockBuf[iBitOffset\u003e\u003e3] =\n                            static_cast\u003cGByte\u003e(\n                                (m_poGDS-\u003em_pabyBlockBuf[iBitOffset\u003e\u003e3] \u0026\n                                 0xf0) |\n                                (nInWord \u003e\u003e 8));\n                        m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3)+1] =\n                            static_cast\u003cGByte\u003e(nInWord \u0026 0xff);\n                    }\n\n                    iBitOffset += iPixelBitSkip;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord =\n                        static_cast\u003cconst GByte *\u003e(pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = reinterpret_cast\u003cconst GUInt16 *\u003e(\n                        pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = reinterpret_cast\u003cconst GUInt32 *\u003e(\n                        pabyThisImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord \u003e nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !m_poGDS-\u003em_bClipWarn )\n                    {\n                        m_poGDS-\u003em_bClipWarn = true;\n                        ReportError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            m_poGDS-\u003em_nBitsPerSample );\n                    }\n                }\n\n                if( m_poGDS-\u003em_nBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 0] =\n                        static_cast\u003cGByte\u003e(nInWord);\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 1] =\n                        static_cast\u003cGByte\u003e(nInWord \u003e\u003e 8);\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 2] =\n                        static_cast\u003cGByte\u003e(nInWord \u003e\u003e 16);\n#else\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 0] =\n                        static_cast\u003cGByte\u003e(nInWord \u003e\u003e 16);\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 1] =\n                        static_cast\u003cGByte\u003e(nInWord \u003e\u003e 8);\n                    m_poGDS-\u003em_pabyBlockBuf[(iBitOffset\u003e\u003e3) + 2] =\n                        static_cast\u003cGByte\u003e(nInWord);\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit \u003c m_poGDS-\u003em_nBitsPerSample; ++iBit )\n                    {\n                        // TODO(schwehr): Revisit this block.\n                        if( nInWord \u0026\n                            (1 \u003c\u003c (m_poGDS-\u003em_nBitsPerSample - 1 - iBit)) )\n                        {\n                            m_poGDS-\u003em_pabyBlockBuf[iBitOffset\u003e\u003e3] |=\n                                ( 0x80 \u003e\u003e (iBitOffset \u0026 7) );\n                        }\n                        else\n                        {\n                            // We must explicitly unset the bit as we\n                            // may update an existing block.\n                            m_poGDS-\u003em_pabyBlockBuf[iBitOffset\u003e\u003e3] \u0026=\n                                ~(0x80 \u003e\u003e(iBitOffset \u0026 7));\n                        }\n\n                        ++iBitOffset;\n                    }\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - m_poGDS-\u003em_nBitsPerSample;\n            }\n        }\n\n        if( poBlock != nullptr )\n        {\n            poBlock-\u003eMarkClean();\n            poBlock-\u003eDropLock();\n        }\n    }\n\n    m_poGDS-\u003em_bLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nstatic void ExpandPacked8ToByte1( const GByte * const CPL_RESTRICT pabySrc,\n                                  GByte* const CPL_RESTRICT pabyDest,\n                                  GPtrDiff_t nBytes )\n{\n    for( decltype(nBytes) i = 0, j = 0; i \u003c nBytes; i++, j+= 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = (byVal \u003e\u003e 7) \u0026 0x1;\n        pabyDest[j+1] = (byVal \u003e\u003e 6) \u0026 0x1;\n        pabyDest[j+2] = (byVal \u003e\u003e 5) \u0026 0x1;\n        pabyDest[j+3] = (byVal \u003e\u003e 4) \u0026 0x1;\n        pabyDest[j+4] = (byVal \u003e\u003e 3) \u0026 0x1;\n        pabyDest[j+5] = (byVal \u003e\u003e 2) \u0026 0x1;\n        pabyDest[j+6] = (byVal \u003e\u003e 1) \u0026 0x1;\n        pabyDest[j+7] = (byVal \u003e\u003e 0) \u0026 0x1;\n    }\n}\n\n#if defined(__GNUC__) || defined(_MSC_VER)\n// Signedness of char implementation dependent, so be explicit.\n// Assumes 2-complement integer types and sign extension of right shifting\n// GCC guarantees such:\n// https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html#Integers-implementation\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return\n        static_cast\u003cGByte\u003e(static_cast\u003csigned char\u003e(byVal \u003c\u003c (7 - nBit)) \u003e\u003e 7);\n}\n#else\n// Portable way\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return (byVal \u0026 (1 \u003c\u003c nBit)) ? 255 : 0;\n}\n#endif\n\nstatic void ExpandPacked8ToByte255( const GByte * const CPL_RESTRICT pabySrc,\n                                    GByte* const CPL_RESTRICT pabyDest,\n                                    GPtrDiff_t nBytes )\n{\n    for( decltype(nBytes) i = 0, j = 0; i \u003c nBytes; i++, j += 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = ExtractBitAndConvertTo255(byVal, 7);\n        pabyDest[j+1] = ExtractBitAndConvertTo255(byVal, 6);\n        pabyDest[j+2] = ExtractBitAndConvertTo255(byVal, 5);\n        pabyDest[j+3] = ExtractBitAndConvertTo255(byVal, 4);\n        pabyDest[j+4] = ExtractBitAndConvertTo255(byVal, 3);\n        pabyDest[j+5] = ExtractBitAndConvertTo255(byVal, 2);\n        pabyDest[j+6] = ExtractBitAndConvertTo255(byVal, 1);\n        pabyDest[j+7] = ExtractBitAndConvertTo255(byVal, 0);\n    }\n}\n\nCPLErr GTiffOddBitsBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    m_poGDS-\u003eCrystalize();\n\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * m_poGDS-\u003em_nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip in a writable file that doesn't      */\n/*      exist yet, but that we want to read.  Just set to zeros and     */\n/*      return.                                                         */\n/* -------------------------------------------------------------------- */\n    if( nBlockId != m_poGDS-\u003em_nLoadedBlock )\n    {\n        bool bErrOccurred = false;\n        if( !m_poGDS-\u003eIsBlockAvailable(nBlockId, nullptr, nullptr, \u0026bErrOccurred) )\n        {\n            NullBlock( pImage );\n            if( bErrOccurred )\n                return CE_Failure;\n            return CE_None;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    {\n        const CPLErr eErr = m_poGDS-\u003eLoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    if( m_poGDS-\u003em_nBitsPerSample == 1 \u0026\u0026\n        (m_poGDS-\u003enBands == 1 || m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE ) )\n    {\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n        GPtrDiff_t iDstOffset = 0;\n        const GByte * const CPL_RESTRICT m_pabyBlockBuf = m_poGDS-\u003em_pabyBlockBuf;\n        GByte* CPL_RESTRICT pabyDest = static_cast\u003cGByte *\u003e(pImage);\n\n        for( int iLine = 0; iLine \u003c nBlockYSize; ++iLine )\n        {\n            GPtrDiff_t iSrcOffsetByte = static_cast\u003cGPtrDiff_t\u003e((nBlockXSize + 7) \u003e\u003e 3) * iLine;\n\n            if( !m_poGDS-\u003em_bPromoteTo8Bits )\n            {\n                ExpandPacked8ToByte1( m_pabyBlockBuf + iSrcOffsetByte,\n                                      pabyDest + iDstOffset,\n                                      nBlockXSize / 8 );\n            }\n            else\n            {\n                ExpandPacked8ToByte255( m_pabyBlockBuf + iSrcOffsetByte,\n                                        pabyDest + iDstOffset,\n                                        nBlockXSize / 8 );\n            }\n            GPtrDiff_t iSrcOffsetBit = (iSrcOffsetByte + nBlockXSize / 8) * 8;\n            iDstOffset += nBlockXSize \u0026 ~0x7;\n            const GByte bSetVal = m_poGDS-\u003em_bPromoteTo8Bits ? 255 : 1;\n            for( int iPixel = nBlockXSize \u0026 ~0x7 ;\n                 iPixel \u003c nBlockXSize;\n                 ++iPixel, ++iSrcOffsetBit )\n            {\n                if( m_pabyBlockBuf[iSrcOffsetBit \u003e\u003e3] \u0026\n                    (0x80 \u003e\u003e (iSrcOffsetBit \u0026 0x7)) )\n                    static_cast\u003cGByte *\u003e(pImage)[iDstOffset++] = bSetVal;\n                else\n                    static_cast\u003cGByte *\u003e(pImage)[iDstOffset++] = 0;\n            }\n        }\n    }\n/* -------------------------------------------------------------------- */\n/*      Handle the case of 16- and 24-bit floating point data as per    */\n/*      TIFF Technical Note 3.                                          */\n/* -------------------------------------------------------------------- */\n    else if( eDataType == GDT_Float32 )\n    {\n        const int nWordBytes = m_poGDS-\u003em_nBitsPerSample / 8;\n        const GByte *pabyImage = m_poGDS-\u003em_pabyBlockBuf +\n            ( ( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE ) ? 0 :\n              (nBand - 1) * nWordBytes );\n        const int iSkipBytes =\n            ( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE ) ?\n            nWordBytes : m_poGDS-\u003enBands * nWordBytes;\n\n        const auto nBlockPixels = static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize;\n        if( m_poGDS-\u003em_nBitsPerSample == 16 )\n        {\n            for( GPtrDiff_t i = 0; i \u003c nBlockPixels; ++i )\n            {\n                static_cast\u003cGUInt32 *\u003e(pImage)[i] =\n                    HalfToFloat( *reinterpret_cast\u003cconst GUInt16 *\u003e(pabyImage) );\n                pabyImage += iSkipBytes;\n            }\n        }\n        else if( m_poGDS-\u003em_nBitsPerSample == 24 )\n        {\n            for( GPtrDiff_t i = 0; i \u003c nBlockPixels; ++i )\n            {\n#ifdef CPL_MSB\n                static_cast\u003cGUInt32 *\u003e(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast\u003cGUInt32\u003e(*(pabyImage + 0)) \u003c\u003c 16)\n                        | (static_cast\u003cGUInt32\u003e(*(pabyImage + 1)) \u003c\u003c 8)\n                        | static_cast\u003cGUInt32\u003e(*(pabyImage + 2)) );\n#else\n                static_cast\u003cGUInt32 *\u003e(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast\u003cGUInt32\u003e(*(pabyImage + 2)) \u003c\u003c 16)\n                        | (static_cast\u003cGUInt32\u003e(*(pabyImage + 1)) \u003c\u003c 8)\n                        | static_cast\u003cGUInt32\u003e(*pabyImage) );\n#endif\n                pabyImage += iSkipBytes;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for moving 12bit data somewhat more efficiently.   */\n/* -------------------------------------------------------------------- */\n    else if( m_poGDS-\u003em_nBitsPerSample == 12 )\n    {\n        int iPixelBitSkip = 0;\n        int iBandBitOffset = 0;\n\n        if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = m_poGDS-\u003enBands * m_poGDS-\u003em_nBitsPerSample;\n            iBandBitOffset = (nBand - 1) * m_poGDS-\u003em_nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = m_poGDS-\u003em_nBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        GPtrDiff_t nBitsPerLine = static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine \u0026 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) \u0026 (~7);\n\n        int iPixel = 0;\n        for( int iY = 0; iY \u003c nBlockYSize; ++iY )\n        {\n            GPtrDiff_t iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n            {\n                const auto iByte = iBitOffset \u003e\u003e 3;\n\n                if( (iBitOffset \u0026 0x7) == 0 )\n                {\n                    // Starting on byte boundary.\n\n                    static_cast\u003cGUInt16 *\u003e(pImage)[iPixel++] =\n                        (m_poGDS-\u003em_pabyBlockBuf[iByte] \u003c\u003c 4)\n                        | (m_poGDS-\u003em_pabyBlockBuf[iByte+1] \u003e\u003e 4);\n                }\n                else\n                {\n                    // Starting off byte boundary.\n\n                    static_cast\u003cGUInt16 *\u003e(pImage)[iPixel++] =\n                        ((m_poGDS-\u003em_pabyBlockBuf[iByte] \u0026 0xf) \u003c\u003c 8)\n                        | (m_poGDS-\u003em_pabyBlockBuf[iByte+1]);\n                }\n                iBitOffset += iPixelBitSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n    else if( m_poGDS-\u003em_nBitsPerSample == 24 )\n    {\n        int iPixelByteSkip = 0;\n        int iBandByteOffset = 0;\n\n        if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelByteSkip = (m_poGDS-\u003enBands * m_poGDS-\u003em_nBitsPerSample) / 8;\n            iBandByteOffset = ((nBand - 1) * m_poGDS-\u003em_nBitsPerSample) / 8;\n        }\n        else\n        {\n            iPixelByteSkip = m_poGDS-\u003em_nBitsPerSample / 8;\n        }\n\n        const GPtrDiff_t nBytesPerLine = static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * iPixelByteSkip;\n\n        GPtrDiff_t iPixel = 0;\n        for( int iY = 0; iY \u003c nBlockYSize; ++iY )\n        {\n            GByte *pabyImage =\n                m_poGDS-\u003em_pabyBlockBuf + iBandByteOffset + iY * nBytesPerLine;\n\n            for( int iX = 0; iX \u003c nBlockXSize; ++iX )\n            {\n#ifdef CPL_MSB\n                static_cast\u003cGUInt32 *\u003e(pImage)[iPixel++] =\n                    ( static_cast\u003cGUInt32\u003e(*(pabyImage + 2)) \u003c\u003c 16)\n                    | (static_cast\u003cGUInt32\u003e(*(pabyImage + 1)) \u003c\u003c 8)\n                    | static_cast\u003cGUInt32\u003e(*(pabyImage + 0));\n#else\n                static_cast\u003cGUInt32 *\u003e(pImage)[iPixel++] =\n                    ( static_cast\u003cGUInt32\u003e(*(pabyImage + 0)) \u003c\u003c 16)\n                    | (static_cast\u003cGUInt32\u003e(*(pabyImage + 1)) \u003c\u003c 8)\n                    | static_cast\u003cGUInt32\u003e(*(pabyImage + 2));\n#endif\n                pabyImage += iPixelByteSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle 1-32 bit integer data.                                   */\n/* -------------------------------------------------------------------- */\n    else\n    {\n        unsigned iPixelBitSkip = 0;\n        unsigned iBandBitOffset = 0;\n\n        if( m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = m_poGDS-\u003enBands * m_poGDS-\u003em_nBitsPerSample;\n            iBandBitOffset = (nBand - 1) * m_poGDS-\u003em_nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = m_poGDS-\u003em_nBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        GUIntBig nBitsPerLine = static_cast\u003cGUIntBig\u003e(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine \u0026 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) \u0026 (~7);\n\n        const GByte * const m_pabyBlockBuf = m_poGDS-\u003em_pabyBlockBuf;\n        const unsigned nBitsPerSample = m_poGDS-\u003em_nBitsPerSample;\n        GPtrDiff_t iPixel = 0;\n\n        if( nBitsPerSample == 1 \u0026\u0026 eDataType == GDT_Byte )\n        {\n          for( unsigned iY = 0; iY \u003c static_cast\u003cunsigned\u003e(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX \u003c static_cast\u003cunsigned\u003e(nBlockXSize); ++iX )\n            {\n                if( m_pabyBlockBuf[iBitOffset\u003e\u003e3] \u0026 (0x80 \u003e\u003e(iBitOffset \u0026 7)) )\n                    static_cast\u003cGByte *\u003e(pImage)[iPixel] = 1;\n                else\n                    static_cast\u003cGByte *\u003e(pImage)[iPixel] = 0;\n                iBitOffset += iPixelBitSkip;\n                iPixel++;\n            }\n          }\n        }\n        else\n        {\n          for( unsigned iY = 0; iY \u003c static_cast\u003cunsigned\u003e(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX \u003c static_cast\u003cunsigned\u003e(nBlockXSize); ++iX )\n            {\n                unsigned nOutWord = 0;\n\n                for( unsigned iBit = 0; iBit \u003c nBitsPerSample; ++iBit )\n                {\n                    if( m_pabyBlockBuf[iBitOffset\u003e\u003e3]\n                        \u0026 (0x80 \u003e\u003e(iBitOffset \u0026 7)) )\n                        nOutWord |= (1 \u003c\u003c (nBitsPerSample - 1 - iBit));\n                    ++iBitOffset;\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - nBitsPerSample;\n\n                if( eDataType == GDT_Byte )\n                {\n                    static_cast\u003cGByte *\u003e(pImage)[iPixel++] =\n                        static_cast\u003cGByte\u003e(nOutWord);\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                  static_cast\u003cGUInt16 *\u003e(pImage)[iPixel++] =\n                      static_cast\u003cGUInt16\u003e(nOutWord);\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                  static_cast\u003cGUInt32 *\u003e(pImage)[iPixel++] = nOutWord;\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n            }\n          }\n        }\n    }\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    CacheMaskForBlock(nBlockXOff,nBlockYOff);\n#endif\n\n    return CE_None;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffBitmapBand                          */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand : public GTiffOddBitsBand\n{\n    friend class GTiffDataset;\n\n    GDALColorTable *m_poColorTable = nullptr;\n\n    CPL_DISALLOW_COPY_ASSIGN(GTiffBitmapBand)\n\n  public:\n\n                   GTiffBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffBitmapBand();\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n    virtual GDALColorTable *GetColorTable() override;\n};\n\n/************************************************************************/\n/*                           GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::GTiffBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffOddBitsBand( poDSIn, nBandIn )\n\n{\n    eDataType = GDT_Byte;\n\n    if( poDSIn-\u003em_poColorTable != nullptr )\n    {\n        m_poColorTable = poDSIn-\u003em_poColorTable-\u003eClone();\n    }\n    else\n    {\n#ifdef ESRI_BUILD\n        m_poColorTable = nullptr;\n#else\n        const GDALColorEntry oWhite = { 255, 255, 255, 255 };\n        const GDALColorEntry oBlack = { 0, 0, 0, 255 };\n\n        m_poColorTable = new GDALColorTable();\n\n        if( poDSIn-\u003em_nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            m_poColorTable-\u003eSetColorEntry( 0, \u0026oWhite );\n            m_poColorTable-\u003eSetColorEntry( 1, \u0026oBlack );\n        }\n        else\n        {\n            m_poColorTable-\u003eSetColorEntry( 0, \u0026oBlack );\n            m_poColorTable-\u003eSetColorEntry( 1, \u0026oWhite );\n        }\n#endif  // not defined ESRI_BUILD.\n    }\n}\n\n/************************************************************************/\n/*                          ~GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::~GTiffBitmapBand()\n\n{\n    delete m_poColorTable;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffBitmapBand::GetColorInterpretation()\n\n{\n    if( m_poGDS-\u003em_bPromoteTo8Bits )\n        return GCI_Undefined;\n\n    return GCI_PaletteIndex;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffBitmapBand::GetColorTable()\n\n{\n    if( m_poGDS-\u003em_bPromoteTo8Bits )\n        return nullptr;\n\n    return m_poColorTable;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffSplitBitmapBand                        */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBitmapBand final : public GTiffBitmapBand\n{\n    friend class GTiffDataset;\n    int m_nLastLineValid = -1;\n\n  public:\n\n                   GTiffSplitBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffSplitBitmapBand();\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                       GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::GTiffSplitBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffBitmapBand( poDSIn, nBandIn )\n\n{\n    nBlockXSize = poDS-\u003eGetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                      ~GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::~GTiffSplitBitmapBand() {}\n\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBitmapBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                         void * pImage )\n\n{\n    m_poGDS-\u003eCrystalize();\n\n    if( m_nLastLineValid \u003e= 0 \u0026\u0026 nBlockYOff \u003e m_nLastLineValid )\n        return CE_Failure;\n\n    if( m_poGDS-\u003em_pabyBlockBuf == nullptr )\n    {\n        m_poGDS-\u003em_pabyBlockBuf =\n            static_cast\u003cGByte *\u003e(\n                VSI_MALLOC_VERBOSE(TIFFScanlineSize(m_poGDS-\u003em_hTIFF)) );\n        if( m_poGDS-\u003em_pabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS-\u003em_nLoadedBlock \u003e= nBlockYOff )\n        m_poGDS-\u003em_nLoadedBlock = -1;\n\n    while( m_poGDS-\u003em_nLoadedBlock \u003c nBlockYOff )\n    {\n        ++m_poGDS-\u003em_nLoadedBlock;\n\n        std::vector\u003cCPLErrorHandlerAccumulatorStruct\u003e aoErrors;\n        CPLInstallErrorHandlerAccumulator(aoErrors);\n        int nRet = TIFFReadScanline( m_poGDS-\u003em_hTIFF, m_poGDS-\u003em_pabyBlockBuf,\n                                     m_poGDS-\u003em_nLoadedBlock, 0 );\n        CPLUninstallErrorHandlerAccumulator();\n\n        for( size_t iError = 0; iError \u003c aoErrors.size(); ++iError )\n        {\n            ReportError( aoErrors[iError].type,\n                      aoErrors[iError].no,\n                      \"%s\",\n                      aoErrors[iError].msg.c_str() );\n            // FAX decoding only handles EOF condition as a warning, so\n            // catch it so as to turn on error when attempting to read\n            // following lines, to avoid performance issues.\n            if(  !m_poGDS-\u003em_bIgnoreReadErrors \u0026\u0026\n                    aoErrors[iError].msg.find(\"Premature EOF\") !=\n                                                    std::string::npos )\n            {\n                m_nLastLineValid = nBlockYOff;\n                nRet = -1;\n            }\n        }\n\n        if( nRet == -1\n            \u0026\u0026 !m_poGDS-\u003em_bIgnoreReadErrors )\n        {\n            ReportError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            m_poGDS-\u003em_nLoadedBlock = -1;\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n    int iSrcOffset = 0;\n    int iDstOffset = 0;\n\n    for( int iPixel = 0; iPixel \u003c nBlockXSize; ++iPixel, ++iSrcOffset )\n    {\n        if( m_poGDS-\u003em_pabyBlockBuf[iSrcOffset \u003e\u003e3] \u0026 (0x80 \u003e\u003e (iSrcOffset \u0026 0x7)) )\n            static_cast\u003cGByte *\u003e(pImage)[iDstOffset++] = 1;\n        else\n            static_cast\u003cGByte *\u003e(pImage)[iDstOffset++] = 0;\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IWriteBlock( int /* nBlockXOff */,\n                                          int /* nBlockYOff */,\n                                          void * /* pImage */ )\n\n{\n    ReportError( CE_Failure, CPLE_AppDefined,\n              \"Split bitmap bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffDataset                              */\n/* ==================================================================== */\n/************************************************************************/\n\n/************************************************************************/\n/*                            GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::GTiffDataset():\n    m_bStreamingIn(false),\n    m_bStreamingOut(false),\n    m_bScanDeferred(true),\n    m_bSingleIFDOpened(false),\n    m_bLoadedBlockDirty(false),\n    m_bWriteError(false),\n    m_bLookedForProjection(false),\n    m_bLookedForMDAreaOrPoint(false),\n    m_bGeoTransformValid(false),\n    m_bCrystalized(true),\n    m_bGeoTIFFInfoChanged(false),\n    m_bForceUnsetGTOrGCPs(false),\n    m_bForceUnsetProjection(false),\n    m_bNoDataChanged(false),\n    m_bNoDataSet(false),\n    m_bMetadataChanged(false),\n    m_bColorProfileMetadataChanged(false),\n    m_bForceUnsetRPC(false),\n    m_bNeedsRewrite(false),\n    m_bLoadingOtherBands(false),\n    m_bIsOverview(false),\n    m_bWriteEmptyTiles(true),\n    m_bFillEmptyTilesAtClosing(false),\n    m_bTreatAsSplit(false),\n    m_bTreatAsSplitBitmap(false),\n    m_bClipWarn(false),\n    m_bIMDRPCMetadataLoaded(false),\n    m_bEXIFMetadataLoaded(false),\n    m_bICCMetadataLoaded(false),\n    m_bHasWarnedDisableAggressiveBandCaching(false),\n    m_bDontReloadFirstBlock(false),\n    m_bWebPLossless(false),\n    m_bPromoteTo8Bits(false),\n    m_bDebugDontWriteBlocks(CPLTestBool(CPLGetConfigOption(\"GTIFF_DONT_WRITE_BLOCKS\", \"NO\"))),\n    m_bIsFinalized(false),\n    m_bIgnoreReadErrors(CPLTestBool(CPLGetConfigOption(\"GTIFF_IGNORE_READ_ERRORS\", \"NO\"))),\n    m_bDirectIO(CPLTestBool(CPLGetConfigOption(\"GTIFF_DIRECT_IO\", \"NO\"))),\n    m_bReadGeoTransform(false),\n    m_bLoadPam(false),\n    m_bHasGotSiblingFiles(false),\n    m_bHasIdentifiedAuthorizedGeoreferencingSources(false),\n    m_bLayoutIFDSBeforeData(false),\n    m_bBlockOrderRowMajor(false),\n    m_bLeaderSizeAsUInt4(false),\n    m_bTrailerRepeatedLast4BytesRepeated(false),\n    m_bMaskInterleavedWithImagery(false),\n    m_bKnownIncompatibleEdition(false),\n    m_bWriteKnownIncompatibleEdition(false),\n    m_bHasUsedReadEncodedAPI(false),\n    m_bWriteCOGLayout(false)\n{\n    //CPLDebug(\"GDAL\", \"sizeof(GTiffDataset) = %d bytes\", static_cast\u003cint\u003e(\n    //    sizeof(GTiffDataset)));\n\n    const char* pszVirtualMemIO =\n        CPLGetConfigOption(\"GTIFF_VIRTUAL_MEM_IO\", \"NO\");\n    if( EQUAL(pszVirtualMemIO, \"IF_ENOUGH_RAM\") )\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::IF_ENOUGH_RAM;\n    else if( CPLTestBool(pszVirtualMemIO) )\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::YES;\n\n    m_oSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n}\n\n/************************************************************************/\n/*                           ~GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::~GTiffDataset()\n\n{\n    Finalize();\n    if( m_pszTmpFilename )\n    {\n        VSIUnlink(m_pszTmpFilename);\n        CPLFree(m_pszTmpFilename);\n    }\n}\n\n/************************************************************************/\n/*                             Finalize()                               */\n/************************************************************************/\n\nint GTiffDataset::Finalize()\n{\n    if( m_bIsFinalized )\n        return FALSE;\n\n    bool bHasDroppedRef = false;\n\n    Crystalize();\n\n    if( m_bColorProfileMetadataChanged )\n    {\n        SaveICCProfile(this, nullptr, nullptr, 0);\n        m_bColorProfileMetadataChanged = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = GTiffDataset::GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            GDALPamDataset::SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n    if( m_psVirtualMemIOMapping )\n        CPLVirtualMemFree( m_psVirtualMemIOMapping );\n    m_psVirtualMemIOMapping = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Fill in missing blocks with empty data.                         */\n/* -------------------------------------------------------------------- */\n    if( m_bFillEmptyTilesAtClosing )\n    {\n/* -------------------------------------------------------------------- */\n/*  Ensure any blocks write cached by GDAL gets pushed through libtiff. */\n/* -------------------------------------------------------------------- */\n        FlushCacheInternal( false /* do not call FlushDirectory */ );\n\n        FillEmptyTiles();\n        m_bFillEmptyTilesAtClosing = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Force a complete flush, including either rewriting(moving)      */\n/*      of writing in place the current directory.                      */\n/* -------------------------------------------------------------------- */\n    FlushCacheInternal( true );\n\n    // Destroy compression queue\n    if( m_poCompressQueue )\n    {\n        m_poCompressQueue-\u003eWaitCompletion();\n\n        for( int i = 0; i \u003c static_cast\u003cint\u003e(m_asCompressionJobs.size()); ++i )\n        {\n            CPLFree(m_asCompressionJobs[i].pabyBuffer);\n            if( m_asCompressionJobs[i].pszTmpFilename )\n            {\n                VSIUnlink(m_asCompressionJobs[i].pszTmpFilename);\n                CPLFree(m_asCompressionJobs[i].pszTmpFilename);\n            }\n        }\n        CPLDestroyMutex(m_hCompressThreadPoolMutex);\n        m_poCompressQueue.reset();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there is still changed metadata, then presumably we want     */\n/*      to push it into PAM.                                            */\n/* -------------------------------------------------------------------- */\n    if( m_bMetadataChanged )\n    {\n        PushMetadataToPam();\n        m_bMetadataChanged = false;\n        GDALPamDataset::FlushCache();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews.                                              */\n/* -------------------------------------------------------------------- */\n    if( !m_poBaseDS )\n    {\n        for( int i = 0; i \u003c m_nOverviewCount; ++i )\n        {\n            delete m_papoOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        m_nOverviewCount = 0;\n\n        for( int i = 0; i \u003c m_nJPEGOverviewCountOri; ++i )\n        {\n            delete m_papoJPEGOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        m_nJPEGOverviewCount = 0;\n        m_nJPEGOverviewCountOri = 0;\n        CPLFree( m_papoJPEGOverviewDS );\n        m_papoJPEGOverviewDS = nullptr;\n    }\n\n    // If we are a mask dataset, we can have overviews, but we don't\n    // own them. We can only free the array, not the overviews themselves.\n    CPLFree( m_papoOverviewDS );\n    m_papoOverviewDS = nullptr;\n\n    // m_poMaskDS is owned by the main image and the overviews\n    // so because of the latter case, we can delete it even if\n    // we are not the base image.\n    if( m_poMaskDS )\n    {\n        delete m_poMaskDS;\n        m_poMaskDS = nullptr;\n        bHasDroppedRef = true;\n    }\n\n    if( m_poColorTable != nullptr )\n        delete m_poColorTable;\n    m_poColorTable = nullptr;\n\n    if( m_hTIFF )\n    {\n        XTIFFClose( m_hTIFF );\n        m_hTIFF = nullptr;\n    }\n\n    if ( !m_poBaseDS ) \n    {\n        if( m_fpL != nullptr )\n        {\n            if( m_bWriteKnownIncompatibleEdition )\n            {\n                GByte abyHeader[4096];\n                VSIFSeekL( m_fpL, 0, SEEK_SET );\n                VSIFReadL( abyHeader, 1, sizeof(abyHeader), m_fpL );\n                const char* szKeyToLook = \"KNOWN_INCOMPATIBLE_EDITION=NO\\n \"; // trailing space intended\n                for( size_t i = 0; i \u003c sizeof(abyHeader) - strlen(szKeyToLook); i++ )\n                {\n                    if( memcmp(abyHeader + i, szKeyToLook, strlen(szKeyToLook)) == 0 )\n                    {\n                        const char* szNewKey = \"KNOWN_INCOMPATIBLE_EDITION=YES\\n\";\n                        CPLAssert( strlen(szKeyToLook) == strlen(szNewKey) );\n                        memcpy(abyHeader + i, szNewKey, strlen(szNewKey));\n                        VSIFSeekL( m_fpL, 0, SEEK_SET );\n                        VSIFWriteL( abyHeader, 1, sizeof(abyHeader), m_fpL );\n                        break;\n                    }\n                }\n            }\n            if( VSIFCloseL( m_fpL ) != 0 )\n            {\n                ReportError(CE_Failure, CPLE_FileIO, \"I/O error\");\n            }\n            m_fpL = nullptr;\n        }\n    }\n\n    if( m_fpToWrite != nullptr )\n    {\n        if( VSIFCloseL( m_fpToWrite ) != 0 )\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"I/O error\");\n        }\n        m_fpToWrite = nullptr;\n    }\n\n    if( m_nGCPCount \u003e 0 )\n    {\n        GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n        CPLFree( m_pasGCPList );\n        m_pasGCPList = nullptr;\n        m_nGCPCount = 0;\n    }\n\n    CSLDestroy( m_papszCreationOptions );\n    m_papszCreationOptions = nullptr;\n\n    CPLFree(m_pabyTempWriteBuffer);\n    m_pabyTempWriteBuffer = nullptr;\n\n    m_bIMDRPCMetadataLoaded = false;\n    CSLDestroy(m_papszMetadataFiles);\n    m_papszMetadataFiles = nullptr;\n\n    VSIFree(m_pTempBufferForCommonDirectIO);\n    m_pTempBufferForCommonDirectIO = nullptr;\n\n    CPLFree(m_panMaskOffsetLsb);\n    m_panMaskOffsetLsb = nullptr;\n\n    CPLFree(m_pszVertUnit);\n    m_pszVertUnit = nullptr;\n\n    CPLFree(m_pszFilename);\n    m_pszFilename = nullptr;\n\n    CPLFree(m_pszGeorefFilename);\n    m_pszGeorefFilename = nullptr;\n\n    m_bIsFinalized = true;\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        CloseDependentDatasets()                      */\n/************************************************************************/\n\nint GTiffDataset::CloseDependentDatasets()\n{\n    if( m_poBaseDS )\n        return FALSE;\n\n    int bHasDroppedRef = GDALPamDataset::CloseDependentDatasets();\n\n    bHasDroppedRef |= Finalize();\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        GetJPEGOverviewCount()                        */\n/************************************************************************/\n\nint GTiffDataset::GetJPEGOverviewCount()\n{\n    if( m_nJPEGOverviewCount \u003e= 0 )\n        return m_nJPEGOverviewCount;\n\n    m_nJPEGOverviewCount = 0;\n    if( m_poBaseDS || eAccess != GA_ReadOnly || m_nCompression != COMPRESSION_JPEG ||\n        (nRasterXSize \u003c 256 \u0026\u0026 nRasterYSize \u003c 256) ||\n        !CPLTestBool(CPLGetConfigOption(\"GTIFF_IMPLICIT_JPEG_OVR\", \"YES\")) ||\n        GDALGetDriverByName(\"JPEG\") == nullptr )\n    {\n        return 0;\n    }\n    const char* pszSourceColorSpace =\n        m_oGTiffMDMD.GetMetadataItem( \"SOURCE_COLOR_SPACE\", \"IMAGE_STRUCTURE\" );\n    if( pszSourceColorSpace != nullptr \u0026\u0026 EQUAL(pszSourceColorSpace, \"CMYK\") )\n    {\n        // We cannot handle implicit overviews on JPEG CMYK datasets converted\n        // to RGBA This would imply doing the conversion in\n        // GTiffJPEGOverviewBand.\n        return 0;\n    }\n\n    // libjpeg-6b only supports 2, 4 and 8 scale denominators.\n    // TODO: Later versions support more.\n    for( signed char i = 2; i \u003e= 0; i-- )\n    {\n        if( nRasterXSize \u003e= (256 \u003c\u003c i) || nRasterYSize \u003e= (256 \u003c\u003c i) )\n        {\n            m_nJPEGOverviewCount = i + 1;\n            break;\n        }\n    }\n    if( m_nJPEGOverviewCount == 0 )\n        return 0;\n\n    // Get JPEG tables.\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    GByte abyFFD8[] = { 0xFF, 0xD8 };\n    if( TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, \u0026nJPEGTableSize, \u0026pJPEGTable) )\n    {\n        if( pJPEGTable == nullptr ||\n            nJPEGTableSize \u003e INT_MAX ||\n            static_cast\u003cGByte*\u003e(pJPEGTable)[nJPEGTableSize-1] != 0xD9 )\n        {\n            m_nJPEGOverviewCount = 0;\n            return 0;\n        }\n        nJPEGTableSize--;  // Remove final 0xD9.\n    }\n    else\n    {\n        pJPEGTable = abyFFD8;\n        nJPEGTableSize = 2;\n    }\n\n    m_papoJPEGOverviewDS =\n        static_cast\u003cGTiffJPEGOverviewDS **\u003e(\n            CPLMalloc( sizeof(GTiffJPEGOverviewDS*) * m_nJPEGOverviewCount ) );\n    for( int i = 0; i \u003c m_nJPEGOverviewCount; ++i )\n    {\n        m_papoJPEGOverviewDS[i] =\n            new GTiffJPEGOverviewDS(\n                this, i + 1,\n                pJPEGTable, static_cast\u003cint\u003e(nJPEGTableSize) );\n    }\n\n    m_nJPEGOverviewCountOri = m_nJPEGOverviewCount;\n\n    return m_nJPEGOverviewCount;\n}\n\n/************************************************************************/\n/*                           FillEmptyTiles()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FillEmptyTiles()\n\n{\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    const int nBlockCount =\n        m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n        m_nBlocksPerBand * nBands :\n        m_nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    toff_t *panByteCounts = nullptr;\n\n    if( TIFFIsTiled( m_hTIFF ) )\n        TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, \u0026panByteCounts );\n    else\n        TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, \u0026panByteCounts );\n\n    if( panByteCounts == nullptr )\n    {\n        // Got here with libtiff 3.9.3 and tiff_write_8 test.\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"FillEmptyTiles() failed because panByteCounts == NULL\" );\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    const GPtrDiff_t nBlockBytes =\n        TIFFIsTiled( m_hTIFF ) ?\n        static_cast\u003cGPtrDiff_t\u003e(TIFFTileSize(m_hTIFF)) :\n        static_cast\u003cGPtrDiff_t\u003e(TIFFStripSize(m_hTIFF));\n\n    GByte *pabyData =\n        static_cast\u003cGByte *\u003e( VSI_CALLOC_VERBOSE(nBlockBytes, 1) );\n    if( pabyData == nullptr )\n    {\n        return;\n    }\n\n    // Force tiles completely filled with the nodata value to be written.\n    m_bWriteEmptyTiles = true;\n\n/* -------------------------------------------------------------------- */\n/*      If set, fill data buffer with no data value.                    */\n/* -------------------------------------------------------------------- */\n    if( m_bNoDataSet \u0026\u0026 m_dfNoDataValue != 0.0 )\n    {\n        const GDALDataType eDataType = GetRasterBand( 1 )-\u003eGetRasterDataType();\n        const int nDataTypeSize = GDALGetDataTypeSizeBytes( eDataType );\n        if( nDataTypeSize \u0026\u0026\n            nDataTypeSize * 8 == static_cast\u003cint\u003e(m_nBitsPerSample) )\n        {\n            GDALCopyWords64( \u0026m_dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockBytes / nDataTypeSize );\n        }\n        else if( nDataTypeSize )\n        {\n            // Handle non power-of-two depths.\n            // Ideally make a packed buffer, but that is a bit tedious,\n            // so use the normal I/O interfaces.\n\n            CPLFree( pabyData );\n\n            pabyData = static_cast\u003cGByte *\u003e(\n                VSI_MALLOC3_VERBOSE(m_nBlockXSize, m_nBlockYSize, nDataTypeSize) );\n            if( pabyData == nullptr )\n                return;\n            GDALCopyWords64( \u0026m_dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           static_cast\u003cGPtrDiff_t\u003e(m_nBlockXSize) * m_nBlockYSize );\n            const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockYSize);\n            for( int iBlock = 0; iBlock \u003c nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBands == 1 )\n                    {\n                        CPL_IGNORE_RET_VAL( GetRasterBand(\n                            1 + iBlock / m_nBlocksPerBand )-\u003eWriteBlock(\n                                (iBlock % m_nBlocksPerBand) % nBlocksPerRow,\n                                (iBlock % m_nBlocksPerBand) / nBlocksPerRow,\n                                pabyData ) );\n                    }\n                    else\n                    {\n                        // In contig case, don't directly call WriteBlock(), as\n                        // it could cause useless decompression-recompression.\n                        const int nXOff =\n                            (iBlock % nBlocksPerRow) * m_nBlockXSize;\n                        const int nYOff =\n                            (iBlock / nBlocksPerRow) * m_nBlockYSize;\n                        const int nXSize =\n                            (nXOff + m_nBlockXSize \u003c= nRasterXSize) ?\n                            m_nBlockXSize : nRasterXSize - nXOff;\n                        const int nYSize =\n                            (nYOff + m_nBlockYSize \u003c= nRasterYSize) ?\n                            m_nBlockYSize : nRasterYSize - nYOff;\n                        for( int iBand = 1; iBand \u003c= nBands; ++iBand )\n                        {\n                            CPL_IGNORE_RET_VAL( GetRasterBand( iBand )-\u003e\n                                RasterIO(\n                                    GF_Write, nXOff, nYOff, nXSize, nYSize,\n                                    pabyData, nXSize, nYSize,\n                                    eDataType, 0, 0, nullptr ) );\n                        }\n                    }\n                }\n            }\n            CPLFree( pabyData );\n            return;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      When we must fill with zeroes, try to create non-sparse file    */\n/*      w.r.t TIFF spec ... as a sparse file w.r.t filesystem, ie by    */\n/*      seeking to end of file instead of writing zero blocks.          */\n/* -------------------------------------------------------------------- */\n    else if( m_nCompression == COMPRESSION_NONE \u0026\u0026 (m_nBitsPerSample % 8) == 0 )\n    {\n        // Only use libtiff to write the first sparse block to ensure that it\n        // will serialize offset and count arrays back to disk.\n        int nCountBlocksToZero = 0;\n        for( int iBlock = 0; iBlock \u003c nBlockCount; ++iBlock )\n        {\n            if( panByteCounts[iBlock] == 0 )\n            {\n                if( nCountBlocksToZero == 0 )\n                {\n                    const bool bWriteEmptyTilesBak = m_bWriteEmptyTiles;\n                    m_bWriteEmptyTiles = true;\n                    const bool bOK =\n                        WriteEncodedTileOrStrip( iBlock, pabyData,\n                                                 FALSE ) == CE_None;\n                    m_bWriteEmptyTiles = bWriteEmptyTilesBak;\n                    if( !bOK )\n                        break;\n                }\n                nCountBlocksToZero++;\n            }\n        }\n        CPLFree( pabyData );\n\n        --nCountBlocksToZero;\n\n        // And then seek to end of file for other ones.\n        if( nCountBlocksToZero \u003e 0 )\n        {\n            toff_t *panByteOffsets = nullptr;\n\n            if( TIFFIsTiled( m_hTIFF ) )\n                TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, \u0026panByteOffsets );\n            else\n                TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, \u0026panByteOffsets );\n\n            if( panByteOffsets == nullptr )\n            {\n                ReportError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"FillEmptyTiles() failed because panByteOffsets == NULL\");\n                return;\n            }\n\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n            VSIFSeekL( fpTIF, 0, SEEK_END );\n            const vsi_l_offset nOffset = VSIFTellL(fpTIF);\n\n            vsi_l_offset iBlockToZero = 0;\n            for( int iBlock = 0; iBlock \u003c nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    panByteOffsets[iBlock] = static_cast\u003ctoff_t\u003e(\n                                        nOffset + iBlockToZero * nBlockBytes);\n                    panByteCounts[iBlock] = nBlockBytes;\n                    iBlockToZero++;\n                }\n            }\n            CPLAssert( iBlockToZero ==\n                       static_cast\u003cvsi_l_offset\u003e(nCountBlocksToZero) );\n\n            if( VSIFTruncateL( fpTIF,\n                               nOffset + iBlockToZero * nBlockBytes ) != 0 )\n            {\n                ReportError(CE_Failure, CPLE_FileIO,\n                         \"Cannot initialize empty blocks\");\n            }\n        }\n\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n\n    GByte* pabyRaw = nullptr;\n    vsi_l_offset nRawSize = 0;\n    for( int iBlock = 0; iBlock \u003c nBlockCount; ++iBlock )\n    {\n        if( panByteCounts[iBlock] == 0 )\n        {\n            if( pabyRaw == nullptr )\n            {\n                if( WriteEncodedTileOrStrip( iBlock, pabyData, FALSE\n                                                                ) != CE_None )\n                    break;\n\n                vsi_l_offset nOffset = 0;\n                bool b = IsBlockAvailable( iBlock, \u0026nOffset, \u0026nRawSize);\n                CPL_IGNORE_RET_VAL(b);\n                CPLAssert(b);\n\n                // When using compression, get back the compressed block\n                // so we can use the raw API to write it faster.\n                if( m_nCompression != COMPRESSION_NONE )\n                {\n                    pabyRaw = static_cast\u003cGByte*\u003e(\n                            VSI_MALLOC_VERBOSE(static_cast\u003csize_t\u003e(nRawSize)));\n                    if( pabyRaw )\n                    {\n                        VSILFILE* fp = VSI_TIFFGetVSILFile(\n                                                    TIFFClientdata( m_hTIFF ));\n                        const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                        VSIFSeekL(fp, nOffset, SEEK_SET);\n                        VSIFReadL(pabyRaw, 1, static_cast\u003csize_t\u003e(nRawSize), fp);\n                        VSIFSeekL(fp, nCurOffset, SEEK_SET);\n                    }\n                }\n            }\n            else\n            {\n                WriteRawStripOrTile( iBlock, pabyRaw,\n                                     static_cast\u003cGPtrDiff_t\u003e(nRawSize) );\n            }\n        }\n    }\n\n    CPLFree( pabyData );\n    VSIFree( pabyRaw );\n}\n\n/************************************************************************/\n/*                         HasOnlyNoData()                              */\n/************************************************************************/\n\ntemplate\u003cclass T\u003e\nstatic inline bool IsEqualToNoData( T value, T noDataValue )\n{\n    return value == noDataValue;\n}\n\ntemplate\u003c\u003e bool IsEqualToNoData\u003cfloat\u003e( float value, float noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate\u003c\u003e bool IsEqualToNoData\u003cdouble\u003e( double value, double noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate\u003cclass T\u003e\nbool GTiffDataset::HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                   int nLineStride, int nComponents ) const\n{\n    const T noDataValue = static_cast\u003cT\u003e((m_bNoDataSet) ? m_dfNoDataValue : 0.0);\n\n    CPLAssert(m_nBitsPerSample != 1 || noDataValue == 0);\n\n    // Fast test: check the 4 corners and the middle pixel.\n    for( int iBand = 0; iBand \u003c nComponents; iBand++ )\n    {\n        if( !(IsEqualToNoData(pBuffer[iBand], noDataValue) \u0026\u0026\n              IsEqualToNoData(\n                  pBuffer[static_cast\u003csize_t\u003e(nWidth - 1) * nComponents +\n                          iBand],\n                  noDataValue) \u0026\u0026\n              IsEqualToNoData(\n                  pBuffer[(static_cast\u003csize_t\u003e(nHeight-1)/2 * nLineStride +\n                           (nWidth - 1)/2) * nComponents + iBand],\n                  noDataValue) \u0026\u0026\n              IsEqualToNoData(\n                  pBuffer[static_cast\u003csize_t\u003e(nHeight - 1) * nLineStride *\n                          nComponents + iBand], noDataValue) \u0026\u0026\n              IsEqualToNoData(\n                  pBuffer[(static_cast\u003csize_t\u003e(nHeight - 1) * nLineStride +\n                           nWidth - 1) * nComponents + iBand], noDataValue) ) )\n        {\n            return false;\n        }\n    }\n\n    // Test all pixels.\n    for( int iY = 0; iY \u003c nHeight; iY++ )\n    {\n        for( int iX = 0; iX \u003c nWidth * nComponents; iX++ )\n        {\n            if( !IsEqualToNoData(\n                   pBuffer[iY * static_cast\u003csize_t\u003e(nLineStride) * nComponents +\n                           iX], noDataValue) )\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool GTiffDataset::HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                  int nLineStride, int nComponents )\n{\n    const GDALDataType eDT = GetRasterBand(1)-\u003eGetRasterDataType();\n\n    // In the case where the nodata is 0, we can compare several bytes at\n    // once. Select the largest natural integer type for the architecture.\n#if SIZEOF_VOIDP == 8 || defined(__x86_64__)\n    // We test __x86_64__ for x32 arch where SIZEOF_VOIDP == 4\n    typedef GUInt64 WordType;\n#else\n    typedef unsigned int WordType;\n#endif\n    if( (!m_bNoDataSet || m_dfNoDataValue == 0.0) \u0026\u0026 nWidth == nLineStride )\n    {\n        const GByte* pabyBuffer = static_cast\u003cconst GByte*\u003e(pBuffer);\n        const size_t nSize = (static_cast\u003csize_t\u003e(nWidth) * nHeight *\n                                nComponents * m_nBitsPerSample + 7) / 8;\n        size_t i = 0;\n        const size_t nInitialIters = std::min(\n            sizeof(WordType) -\n                (reinterpret_cast\u003cstd::uintptr_t\u003e(pabyBuffer) % sizeof(WordType)),\n            nSize);\n        for( ; i \u003c nInitialIters; i++ )\n        {\n            if( pabyBuffer[i] )\n                return false;\n        }\n        for( ; i + sizeof(WordType) - 1 \u003c nSize; i += sizeof(WordType) )\n        {\n            if( *(reinterpret_cast\u003cconst WordType*\u003e(pabyBuffer + i)) )\n                return false;\n        }\n        for( ; i \u003c nSize; i++ )\n        {\n            if( pabyBuffer[i] )\n                return false;\n        }\n        return true;\n    }\n\n    if( m_nBitsPerSample == 8 )\n    {\n        if( m_nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return HasOnlyNoDataT(static_cast\u003cconst signed char*\u003e(pBuffer),\n                                  nWidth, nHeight, nLineStride, nComponents);\n        }\n        return HasOnlyNoDataT(static_cast\u003cconst GByte*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 16 \u0026\u0026 eDT == GDT_UInt16 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst GUInt16*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 16 \u0026\u0026 eDT== GDT_Int16 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst GInt16*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 32 \u0026\u0026 eDT == GDT_UInt32 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst GUInt32*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 32 \u0026\u0026 eDT == GDT_Int32 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst GInt32*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 32 \u0026\u0026 eDT == GDT_Float32 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst float*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 64 \u0026\u0026 eDT == GDT_Float64 )\n    {\n        return HasOnlyNoDataT(static_cast\u003cconst double*\u003e(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                     IsFirstPixelEqualToNoData()                      */\n/************************************************************************/\n\ninline bool GTiffDataset::IsFirstPixelEqualToNoData( const void* pBuffer )\n{\n    const GDALDataType eDT = GetRasterBand(1)-\u003eGetRasterDataType();\n    const double dfEffectiveNoData = (m_bNoDataSet) ? m_dfNoDataValue : 0.0;\n    if( m_nBitsPerSample == 8 || (m_nBitsPerSample \u003c 8 \u0026\u0026 dfEffectiveNoData == 0) )\n    {\n        if( m_nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return GDALIsValueInRange\u003csigned char\u003e(dfEffectiveNoData) \u0026\u0026\n                   *(static_cast\u003cconst signed char*\u003e(pBuffer)) ==\n                        static_cast\u003csigned char\u003e(dfEffectiveNoData);\n        }\n        return GDALIsValueInRange\u003cGByte\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst GByte*\u003e(pBuffer)) ==\n                        static_cast\u003cGByte\u003e(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 16 \u0026\u0026 eDT == GDT_UInt16 )\n    {\n        return GDALIsValueInRange\u003cGUInt16\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst GUInt16*\u003e(pBuffer)) ==\n                        static_cast\u003cGUInt16\u003e(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 16 \u0026\u0026 eDT == GDT_Int16 )\n    {\n        return GDALIsValueInRange\u003cGInt16\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst GInt16*\u003e(pBuffer)) ==\n                        static_cast\u003cGInt16\u003e(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 32 \u0026\u0026 eDT == GDT_UInt32 )\n    {\n        return GDALIsValueInRange\u003cGUInt32\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst GUInt32*\u003e(pBuffer)) ==\n                        static_cast\u003cGUInt32\u003e(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 32 \u0026\u0026 eDT == GDT_Int32 )\n    {\n        return GDALIsValueInRange\u003cGInt32\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst GInt32*\u003e(pBuffer)) ==\n                        static_cast\u003cGInt32\u003e(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 32 \u0026\u0026 eDT == GDT_Float32 )\n    {\n        if( CPLIsNan(m_dfNoDataValue) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast\u003cconst float*\u003e(pBuffer))));\n        return GDALIsValueInRange\u003cfloat\u003e(dfEffectiveNoData) \u0026\u0026\n               *(static_cast\u003cconst float*\u003e(pBuffer)) ==\n                        static_cast\u003cfloat\u003e(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 64 \u0026\u0026 eDT == GDT_Float64 )\n    {\n        if( CPLIsNan(dfEffectiveNoData) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast\u003cconst double*\u003e(pBuffer))));\n        return *(static_cast\u003cconst double*\u003e(pBuffer)) == dfEffectiveNoData;\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                        WriteEncodedTile()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedTile( uint32 tile, GByte *pabyData,\n                                     int bPreserveDataBuffer )\n{\n    int iRow = 0;\n    int iColumn = 0;\n    int nBlocksPerRow = 1;\n    int nBlocksPerColumn = 1;\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !m_bWriteEmptyTiles \u0026\u0026 IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(tile) )\n        {\n            const int nComponents =\n                m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n            nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n            nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, m_nBlockYSize);\n\n            iColumn = (tile % m_nBlocksPerBand) % nBlocksPerRow;\n            iRow = (tile % m_nBlocksPerBand) / nBlocksPerRow;\n\n            const int nActualBlockWidth =\n                ( iColumn == nBlocksPerRow - 1 ) ?\n                nRasterXSize - iColumn * m_nBlockXSize : m_nBlockXSize;\n            const int nActualBlockHeight =\n                ( iRow == nBlocksPerColumn - 1 ) ?\n                nRasterYSize - iRow * m_nBlockYSize : m_nBlockYSize;\n\n            if( HasOnlyNoData(pabyData,\n                              nActualBlockWidth, nActualBlockHeight,\n                              m_nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n    // Do we need to spread edge values right or down for a partial\n    // JPEG encoded tile?  We do this to avoid edge artifacts.\n    bool bNeedTileFill = false;\n    if( m_nCompression == COMPRESSION_JPEG )\n    {\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n        nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, m_nBlockYSize);\n\n        iColumn = (tile % m_nBlocksPerBand) % nBlocksPerRow;\n        iRow = (tile % m_nBlocksPerBand) / nBlocksPerRow;\n\n        // Is this a partial right edge tile?\n        if( iRow == nBlocksPerRow - 1\n            \u0026\u0026 nRasterXSize % m_nBlockXSize != 0 )\n            bNeedTileFill = true;\n\n        // Is this a partial bottom edge tile?\n        if( iColumn == nBlocksPerColumn - 1\n            \u0026\u0026 nRasterYSize % m_nBlockYSize != 0 )\n            bNeedTileFill = true;\n    }\n\n    // If we need to fill out the tile, or if we want to prevent\n    // TIFFWriteEncodedTile from altering the buffer as part of\n    // byte swapping the data on write then we will need a temporary\n    // working buffer.  If not, we can just do a direct write.\n    const GPtrDiff_t cc = static_cast\u003cGPtrDiff_t\u003e(TIFFTileSize( m_hTIFF ));\n\n    if( bPreserveDataBuffer\n        \u0026\u0026 (TIFFIsByteSwapped(m_hTIFF) || bNeedTileFill || m_panMaskOffsetLsb) )\n    {\n        if( m_pabyTempWriteBuffer == nullptr )\n        {\n            m_pabyTempWriteBuffer = CPLMalloc(cc);\n        }\n        memcpy(m_pabyTempWriteBuffer, pabyData, cc);\n\n        pabyData = static_cast\u003cGByte *\u003e( m_pabyTempWriteBuffer );\n    }\n\n    // Perform tile fill if needed.\n    // TODO: we should also handle the case of nBitsPerSample == 12\n    // but this is more involved.\n    if( bNeedTileFill \u0026\u0026 m_nBitsPerSample == 8 )\n    {\n        const int nComponents =\n            m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n        CPLDebug( \"GTiff\", \"Filling out jpeg edge tile on write.\" );\n\n        const int nRightPixelsToFill =\n            iColumn == nBlocksPerRow - 1 ?\n            m_nBlockXSize * (iColumn + 1) - nRasterXSize :\n            0;\n        const int nBottomPixelsToFill =\n            iRow == nBlocksPerColumn - 1 ?\n            m_nBlockYSize * (iRow + 1) - nRasterYSize :\n            0;\n\n        // Fill out to the right.\n        const int iSrcX = m_nBlockXSize - nRightPixelsToFill - 1;\n\n        for( int iX = iSrcX + 1; iX \u003c m_nBlockXSize; ++iX )\n        {\n            for( int iY = 0; iY \u003c m_nBlockYSize; ++iY )\n            {\n                memcpy( pabyData + (static_cast\u003cGPtrDiff_t\u003e(m_nBlockXSize) * iY + iX) * nComponents,\n                        pabyData + (static_cast\u003cGPtrDiff_t\u003e(m_nBlockXSize) * iY + iSrcX) * nComponents,\n                        nComponents );\n            }\n        }\n\n        // Now fill out the bottom.\n        const int iSrcY = m_nBlockYSize - nBottomPixelsToFill - 1;\n        for( int iY = iSrcY + 1; iY \u003c m_nBlockYSize; ++iY )\n        {\n            memcpy( pabyData + static_cast\u003cGPtrDiff_t\u003e(m_nBlockXSize) * nComponents * iY,\n                    pabyData + static_cast\u003cGPtrDiff_t\u003e(m_nBlockXSize) * nComponents * iSrcY,\n                    static_cast\u003cGPtrDiff_t\u003e(m_nBlockXSize) * nComponents );\n        }\n    }\n\n    if( m_panMaskOffsetLsb )\n    {\n        const int iBand =\n            m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast\u003cint\u003e(tile) / m_nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( m_bStreamingOut )\n    {\n        if( tile != static_cast\u003cuint32\u003e(m_nLastWrittenBlockId + 1) )\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     tile, m_nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast\u003cGPtrDiff_t\u003e( VSIFWriteL(pabyData, 1, cc, m_fpToWrite) ) != cc )\n        {\n            ReportError( CE_Failure, CPLE_FileIO, \"Could not write \" CPL_FRMT_GUIB \" bytes\",\n                      static_cast\u003cGUIntBig\u003e(cc) );\n            return false;\n        }\n        m_nLastWrittenBlockId = tile;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(tile, pabyData, cc, m_nBlockYSize) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if TIFFLIB_VERSION \u003c= 20150912\n    const CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    const bool bRet =\n        TIFFWriteEncodedTile(m_hTIFF, tile, pabyData, cc) == cc;\n#if TIFFLIB_VERSION \u003c= 20150912\n    if( eBefore == CE_None \u0026\u0026 CPLGetLastErrorType() == CE_Failure )\n        return false;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        WriteEncodedStrip()                           */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                      int bPreserveDataBuffer )\n{\n    GPtrDiff_t cc = static_cast\u003cGPtrDiff_t\u003e(TIFFStripSize( m_hTIFF ));\n    const auto ccFull = cc;\n\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n    const int nStripWithinBand = strip % m_nBlocksPerBand;\n    int nStripHeight = m_nRowsPerStrip;\n\n    if( nStripWithinBand * nStripHeight \u003e GetRasterYSize() - nStripHeight )\n    {\n        nStripHeight = GetRasterYSize() - nStripWithinBand * m_nRowsPerStrip;\n        cc = (cc / m_nRowsPerStrip) * nStripHeight;\n        CPLDebug( \"GTiff\", \"Adjusted bytes to write from \" CPL_FRMT_GUIB \" to \" CPL_FRMT_GUIB \".\",\n                  static_cast\u003cGUIntBig\u003e(TIFFStripSize(m_hTIFF)),\n                  static_cast\u003cGUIntBig\u003e(cc) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !m_bWriteEmptyTiles \u0026\u0026 IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(strip) )\n        {\n            const int nComponents =\n                m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n            if( HasOnlyNoData(pabyData,\n                              m_nBlockXSize, nStripHeight,\n                              m_nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      TIFFWriteEncodedStrip can alter the passed buffer if            */\n/*      byte-swapping is necessary so we use a temporary buffer         */\n/*      before calling it.                                              */\n/* -------------------------------------------------------------------- */\n    if( bPreserveDataBuffer \u0026\u0026 (TIFFIsByteSwapped(m_hTIFF) || m_panMaskOffsetLsb) )\n    {\n        if( m_pabyTempWriteBuffer == nullptr )\n        {\n            m_pabyTempWriteBuffer = CPLMalloc(ccFull);\n        }\n        memcpy(m_pabyTempWriteBuffer, pabyData, cc);\n        pabyData = static_cast\u003cGByte *\u003e( m_pabyTempWriteBuffer );\n    }\n\n    if( m_panMaskOffsetLsb )\n    {\n        int iBand =\n            m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast\u003cint\u003e(strip) / m_nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( m_bStreamingOut )\n    {\n        if( strip != static_cast\u003cuint32\u003e(m_nLastWrittenBlockId + 1) )\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     strip, m_nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast\u003cGPtrDiff_t\u003e(VSIFWriteL(pabyData, 1, cc, m_fpToWrite)) != cc )\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"Could not write \" CPL_FRMT_GUIB \" bytes\",\n                     static_cast\u003cGUIntBig\u003e(cc));\n            return false;\n        }\n        m_nLastWrittenBlockId = strip;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(strip, pabyData, cc, nStripHeight) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if TIFFLIB_VERSION \u003c= 20150912\n    CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    bool bRet = TIFFWriteEncodedStrip( m_hTIFF, strip, pabyData, cc) == cc;\n#if TIFFLIB_VERSION \u003c= 20150912\n    if( eBefore == CE_None \u0026\u0026 CPLGetLastErrorType() == CE_Failure )\n        bRet = FALSE;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        InitCompressionThreads()                      */\n/************************************************************************/\n\nvoid GTiffDataset::InitCompressionThreads( char** papszOptions )\n{\n    // Raster == tile, then no need for threads\n    if( m_nBlockXSize == nRasterXSize \u0026\u0026 m_nBlockYSize == nRasterYSize )\n        return;\n\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"NUM_THREADS\" );\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption(\"GDAL_NUM_THREADS\", nullptr);\n    if( pszValue )\n    {\n        const int nThreads =\n            EQUAL(pszValue, \"ALL_CPUS\") ? CPLGetNumCPUs() : atoi(pszValue);\n        if( nThreads \u003e 1 )\n        {\n            if( m_nCompression == COMPRESSION_NONE )\n            {\n                CPLDebug( \"GTiff\",\n                          \"NUM_THREADS ignored with uncompressed\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Using %d threads for compression\", nThreads);\n\n                auto poThreadPool = GDALGetGlobalThreadPool(nThreads);\n                if( poThreadPool )\n                    m_poCompressQueue = poThreadPool-\u003eCreateJobQueue();\n\n                if( m_poCompressQueue != nullptr )\n                {\n                    // Add a margin of an extra job w.r.t thread number\n                    // so as to optimize compression time (enables the main\n                    // thread to do boring I/O while all CPUs are working).\n                    m_asCompressionJobs.resize(nThreads + 1);\n                    memset(\u0026m_asCompressionJobs[0], 0,\n                           m_asCompressionJobs.size() *\n                           sizeof(GTiffCompressionJob));\n                    for( int i = 0;\n                         i \u003c static_cast\u003cint\u003e(m_asCompressionJobs.size());\n                         ++i )\n                    {\n                        m_asCompressionJobs[i].pszTmpFilename =\n                            CPLStrdup(CPLSPrintf(\"/vsimem/gtiff/thread/job/%p\",\n                                                 \u0026m_asCompressionJobs[i]));\n                        m_asCompressionJobs[i].nStripOrTile = -1;\n                    }\n                    m_hCompressThreadPoolMutex = CPLCreateMutex();\n                    CPLReleaseMutex(m_hCompressThreadPoolMutex);\n\n                    // This is kind of a hack, but basically using\n                    // TIFFWriteRawStrip/Tile and then TIFFReadEncodedStrip/Tile\n                    // does not work on a newly created file, because\n                    // TIFF_MYBUFFER is not set in tif_flags\n                    // (if using TIFFWriteEncodedStrip/Tile first,\n                    // TIFFWriteBufferSetup() is automatically called).\n                    // This should likely rather fixed in libtiff itself.\n                    CPL_IGNORE_RET_VAL(\n                        TIFFWriteBufferSetup(m_hTIFF, nullptr, -1));\n                }\n            }\n        }\n        else if( nThreads \u003c 0 ||\n                 (!EQUAL(pszValue, \"0\") \u0026\u0026\n                  !EQUAL(pszValue, \"1\") \u0026\u0026\n                  !EQUAL(pszValue, \"ALL_CPUS\")) )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                     \"Invalid value for NUM_THREADS: %s\", pszValue);\n        }\n    }\n}\n\n/************************************************************************/\n/*                       GetGTIFFKeysFlavor()                           */\n/************************************************************************/\n\nstatic GTIFFKeysFlavorEnum GetGTIFFKeysFlavor( char** papszOptions )\n{\n    const char* pszGeoTIFFKeysFlavor =\n        CSLFetchNameValueDef( papszOptions, \"GEOTIFF_KEYS_FLAVOR\", \"STANDARD\" );\n    if( EQUAL(pszGeoTIFFKeysFlavor, \"ESRI_PE\") )\n        return GEOTIFF_KEYS_ESRI_PE;\n    return GEOTIFF_KEYS_STANDARD;\n}\n\n/************************************************************************/\n/*                       GetGeoTIFFVersion()                            */\n/************************************************************************/\n\nstatic GeoTIFFVersionEnum GetGeoTIFFVersion( char** papszOptions )\n{\n    const char* pszVersion =\n        CSLFetchNameValueDef( papszOptions, \"GEOTIFF_VERSION\", \"AUTO\" );\n    if( EQUAL(pszVersion, \"1.0\") )\n        return GEOTIFF_VERSION_1_0;\n    if( EQUAL(pszVersion, \"1.1\") )\n        return GEOTIFF_VERSION_1_1;\n    return GEOTIFF_VERSION_AUTO;\n}\n\n/************************************************************************/\n/*                      InitCreationOrOpenOptions()                     */\n/************************************************************************/\n\nvoid GTiffDataset::InitCreationOrOpenOptions( char** papszOptions )\n{\n    InitCompressionThreads(papszOptions);\n\n    m_eGeoTIFFKeysFlavor = GetGTIFFKeysFlavor(papszOptions);\n    m_eGeoTIFFVersion = GetGeoTIFFVersion(papszOptions);\n}\n\n/************************************************************************/\n/*                      ThreadCompressionFunc()                         */\n/************************************************************************/\n\nvoid GTiffDataset::ThreadCompressionFunc( void* pData )\n{\n    GTiffCompressionJob* psJob = static_cast\u003cGTiffCompressionJob *\u003e(pData);\n    GTiffDataset* poDS = psJob-\u003epoDS;\n\n    VSILFILE* fpTmp = VSIFOpenL(psJob-\u003epszTmpFilename, \"wb+\");\n    TIFF* hTIFFTmp = VSI_TIFFOpen(psJob-\u003epszTmpFilename,\n        psJob-\u003ebTIFFIsBigEndian ? \"wb+\" : \"wl+\", fpTmp);\n    CPLAssert( hTIFFTmp != nullptr );\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGEWIDTH, poDS-\u003em_nBlockXSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGELENGTH, psJob-\u003enHeight);\n    TIFFSetField(hTIFFTmp, TIFFTAG_BITSPERSAMPLE, poDS-\u003em_nBitsPerSample);\n    TIFFSetField(hTIFFTmp, TIFFTAG_COMPRESSION, poDS-\u003em_nCompression);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS-\u003em_nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS-\u003em_nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS-\u003em_nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS-\u003em_nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS-\u003em_nPlanarConfig);\n    if( psJob-\u003enPredictor != PREDICTOR_NONE )\n        TIFFSetField(hTIFFTmp, TIFFTAG_PREDICTOR, psJob-\u003enPredictor);\n#if HAVE_LERC\n    if( poDS-\u003em_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField(hTIFFTmp, TIFFTAG_LERC_PARAMETERS, 2,\n                    poDS-\u003em_anLercAddCompressionAndVersion);\n    }\n#endif\n\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS-\u003em_nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS-\u003em_nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS-\u003em_nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS-\u003em_nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS-\u003em_nPlanarConfig);\n\n    poDS-\u003eRestoreVolatileParameters(hTIFFTmp);\n\n    bool bOK =\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, psJob-\u003epabyBuffer,\n                              psJob-\u003enBufferSize) == psJob-\u003enBufferSize;\n\n    toff_t nOffset = 0;\n    if( bOK )\n    {\n        toff_t* panOffsets = nullptr;\n        toff_t* panByteCounts = nullptr;\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPOFFSETS, \u0026panOffsets);\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPBYTECOUNTS, \u0026panByteCounts);\n\n        nOffset = panOffsets[0];\n        psJob-\u003enCompressedBufferSize = static_cast\u003cGPtrDiff_t\u003e(panByteCounts[0]);\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Error when compressing strip/tile %d\",\n                  psJob-\u003enStripOrTile);\n    }\n\n    XTIFFClose(hTIFFTmp);\n    if( VSIFCloseL(fpTmp) != 0 )\n    {\n        if( bOK )\n        {\n            bOK = false;\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Error when compressing strip/tile %d\",\n                      psJob-\u003enStripOrTile);\n        }\n    }\n\n    if( bOK )\n    {\n        vsi_l_offset nFileSize = 0;\n        GByte* pabyCompressedBuffer = VSIGetMemFileBuffer(psJob-\u003epszTmpFilename,\n                                                          \u0026nFileSize,\n                                                          FALSE);\n        CPLAssert( static_cast\u003cvsi_l_offset\u003e(nOffset + psJob-\u003enCompressedBufferSize) \u003c= nFileSize );\n        psJob-\u003epabyCompressedBuffer = pabyCompressedBuffer + nOffset;\n    }\n    else\n    {\n        psJob-\u003epabyCompressedBuffer = nullptr;\n        psJob-\u003enCompressedBufferSize = 0;\n    }\n\n    auto mutex = poDS-\u003em_poBaseDS ?\n        poDS-\u003em_poBaseDS-\u003em_hCompressThreadPoolMutex : poDS-\u003em_hCompressThreadPoolMutex;\n    if( mutex )\n    {\n        CPLAcquireMutex(mutex, 1000.0);\n        psJob-\u003ebReady = true;\n        CPLReleaseMutex(mutex);\n    }\n}\n\n/************************************************************************/\n/*                        WriteRawStripOrTile()                         */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        GPtrDiff_t nCompressedBufferSize )\n{\n#ifdef DEBUG_VERBOSE\n    CPLDebug(\"GTIFF\", \"Writing raw strip/tile %d, size \" CPL_FRMT_GUIB,\n             nStripOrTile, static_cast\u003cGUIntBig\u003e(nCompressedBufferSize));\n#endif\n    toff_t *panOffsets = nullptr;\n    toff_t* panByteCounts = nullptr;\n    bool bWriteAtEnd = true;\n    bool bWriteLeader = m_bLeaderSizeAsUInt4;\n    bool bWriteTrailer = m_bTrailerRepeatedLast4BytesRepeated;\n    if( TIFFGetField(\n            m_hTIFF,\n            TIFFIsTiled( m_hTIFF ) ?\n            TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS, \u0026panOffsets ) \u0026\u0026\n            panOffsets != nullptr \u0026\u0026\n            panOffsets[nStripOrTile] != 0 )\n    {\n        // Forces TIFFAppendStrip() to consider if the location of the tile/strip\n        // can be reused or if the strile should be written at end of file.\n        TIFFSetWriteOffset(m_hTIFF, 0);\n\n        if( m_bBlockOrderRowMajor )\n        {\n            if( TIFFGetField(\n                m_hTIFF,\n                TIFFIsTiled( m_hTIFF ) ?\n                TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS, \u0026panByteCounts ) \u0026\u0026\n                panByteCounts != nullptr )\n            {\n                if( static_cast\u003cGUIntBig\u003e(nCompressedBufferSize) \u003e\n                        panByteCounts[nStripOrTile] )\n                {\n                    GTiffDataset* poRootDS = m_poBaseDS ? m_poBaseDS : this;\n                    if( !poRootDS-\u003em_bKnownIncompatibleEdition \u0026\u0026\n                        !poRootDS-\u003em_bWriteKnownIncompatibleEdition )\n                    {\n                        ReportError(CE_Warning, CPLE_AppDefined,\n                            \"A strile cannot be rewritten in place, which \"\n                            \"invalidates the BLOCK_ORDER optimization.\");\n                        poRootDS-\u003em_bKnownIncompatibleEdition = true;\n                        poRootDS-\u003em_bWriteKnownIncompatibleEdition = true;\n                    }\n                }\n                // For mask interleaving, if the size is not exactly the same,\n                // completely give up (we could potentially move the mask in\n                // case the imagery is smaller)\n                else if( m_poMaskDS \u0026\u0026 m_bMaskInterleavedWithImagery \u0026\u0026\n                         static_cast\u003cGUIntBig\u003e(nCompressedBufferSize) !=\n                            panByteCounts[nStripOrTile] )\n                {\n                    GTiffDataset* poRootDS = m_poBaseDS ? m_poBaseDS : this;\n                    if( !poRootDS-\u003em_bKnownIncompatibleEdition \u0026\u0026\n                        !poRootDS-\u003em_bWriteKnownIncompatibleEdition )\n                    {\n                        ReportError(CE_Warning, CPLE_AppDefined,\n                            \"A strile cannot be rewritten in place, which \"\n                            \"invalidates the MASK_INTERLEAVED_WITH_IMAGERY \"\n                            \"optimization.\");\n                        poRootDS-\u003em_bKnownIncompatibleEdition = true;\n                        poRootDS-\u003em_bWriteKnownIncompatibleEdition = true;\n                    }\n                    bWriteLeader = false;\n                    bWriteTrailer = false;\n                    if( m_bLeaderSizeAsUInt4 )\n                    {\n                        // If there was a valid leader, invalidat it\n                        VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n                        uint32 nOldSize;\n                        VSIFReadL(\u0026nOldSize, 1, 4, VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF)));\n                        CPL_LSBPTR32(\u0026nOldSize);\n                        if( nOldSize == panByteCounts[nStripOrTile] )\n                        {\n                            uint32 nInvalidatedSize = 0;\n                            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n                            VSI_TIFFWrite(m_hTIFF, \u0026nInvalidatedSize, sizeof(nInvalidatedSize));\n                        }\n                    }\n                }\n                else\n                {\n                    bWriteAtEnd = false;\n                }\n            }\n        }\n    }\n    if( bWriteLeader \u0026\u0026\n        static_cast\u003cGUIntBig\u003e(nCompressedBufferSize) \u003c= 0xFFFFFFFFU )\n    {\n        // cppcheck-suppress knownConditionTrueFalse\n        if( bWriteAtEnd )\n        {\n            VSI_TIFFSeek( m_hTIFF, 0, SEEK_END );\n        }\n        else\n        {\n            // If we rewrite an existing strile in place with an existing leader,\n            // check that the leader is valid, before rewriting it.\n            // And if it is not valid, then do not write the trailer, as we\n            // could corrupt other data.\n            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n            uint32 nOldSize;\n            VSIFReadL(\u0026nOldSize, 1, 4, VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF)));\n            CPL_LSBPTR32(\u0026nOldSize);\n            bWriteLeader = panByteCounts \u0026\u0026 nOldSize == panByteCounts[nStripOrTile];\n            bWriteTrailer = bWriteLeader;\n            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n        }\n        // cppcheck-suppress knownConditionTrueFalse\n        if( bWriteLeader )\n        {\n            uint32 nSize = static_cast\u003cuint32\u003e(nCompressedBufferSize);\n            CPL_LSBPTR32(\u0026nSize);\n            if( !VSI_TIFFWrite(m_hTIFF, \u0026nSize, sizeof(nSize)) )\n                m_bWriteError = true;\n        }\n    }\n    tmsize_t written;\n    if( TIFFIsTiled( m_hTIFF ) )\n        written = TIFFWriteRawTile( m_hTIFF, nStripOrTile, pabyCompressedBuffer,\n                          nCompressedBufferSize );\n    else\n        written = TIFFWriteRawStrip( m_hTIFF, nStripOrTile, pabyCompressedBuffer,\n                           nCompressedBufferSize );\n    if( written != nCompressedBufferSize )\n        m_bWriteError = true;\n    if( bWriteTrailer \u0026\u0026\n        static_cast\u003cGUIntBig\u003e(nCompressedBufferSize) \u003c= 0xFFFFFFFFU )\n    {\n        GByte abyLastBytes[4] = {};\n        if( nCompressedBufferSize \u003e= 4 )\n            memcpy(abyLastBytes, pabyCompressedBuffer + nCompressedBufferSize - 4, 4);\n        else\n            memcpy(abyLastBytes, pabyCompressedBuffer, nCompressedBufferSize);\n        if( !VSI_TIFFWrite(m_hTIFF, abyLastBytes, 4) )\n            m_bWriteError = true;\n    }\n}\n\n/************************************************************************/\n/*                        WaitCompletionForJobIdx()                     */\n/************************************************************************/\n\nvoid GTiffDataset::WaitCompletionForJobIdx(int i)\n{\n    auto poQueue = m_poBaseDS ?\n        m_poBaseDS-\u003em_poCompressQueue.get() : m_poCompressQueue.get();\n    auto\u0026 oQueue = m_poBaseDS ? m_poBaseDS-\u003em_asQueueJobIdx : m_asQueueJobIdx;\n    auto\u0026 asJobs = m_poBaseDS ? m_poBaseDS-\u003em_asCompressionJobs : m_asCompressionJobs;\n    auto mutex = m_poBaseDS ? m_poBaseDS-\u003em_hCompressThreadPoolMutex : m_hCompressThreadPoolMutex;\n\n    CPLAssert( i \u003e= 0 \u0026\u0026 static_cast\u003csize_t\u003e(i) \u003c asJobs.size() );\n    CPLAssert( asJobs[i].nStripOrTile \u003e= 0 );\n    CPLAssert( !oQueue.empty() );\n\n    bool bHasWarned = false;\n    while( true )\n    {\n        CPLAcquireMutex(mutex, 1000.0);\n        const bool bReady = asJobs[i].bReady;\n        CPLReleaseMutex(mutex);\n        if( !bReady )\n        {\n            if( !bHasWarned )\n            {\n                CPLDebug(\"GTIFF\",\n                        \"Waiting for worker job to finish handling block %d\",\n                        asJobs[i].nStripOrTile);\n                bHasWarned = true;\n            }\n            poQueue-\u003eGetPool()-\u003eWaitEvent();\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    if( asJobs[i].nCompressedBufferSize )\n    {\n        asJobs[i].poDS-\u003eWriteRawStripOrTile(asJobs[i].nStripOrTile,\n                        asJobs[i].pabyCompressedBuffer,\n                        asJobs[i].nCompressedBufferSize);\n    }\n    asJobs[i].pabyCompressedBuffer = nullptr;\n    asJobs[i].nBufferSize = 0;\n    asJobs[i].bReady = false;\n    asJobs[i].nStripOrTile = -1;\n    oQueue.pop();\n}\n\n/************************************************************************/\n/*                        WaitCompletionForBlock()                      */\n/************************************************************************/\n\nvoid GTiffDataset::WaitCompletionForBlock(int nBlockId)\n{\n    auto poQueue = m_poBaseDS ?\n        m_poBaseDS-\u003em_poCompressQueue.get() : m_poCompressQueue.get();\n    auto\u0026 oQueue = m_poBaseDS ? m_poBaseDS-\u003em_asQueueJobIdx : m_asQueueJobIdx;\n    auto\u0026 asJobs = m_poBaseDS ? m_poBaseDS-\u003em_asCompressionJobs : m_asCompressionJobs;\n\n    if( poQueue != nullptr )\n    {\n        for( int i = 0; i \u003c static_cast\u003cint\u003e(asJobs.size()); ++i )\n        {\n            if( asJobs[i].poDS == this \u0026\u0026 asJobs[i].nStripOrTile == nBlockId )\n            {\n                while( !oQueue.empty() \u0026\u0026\n                       !(asJobs[oQueue.front()].poDS == this \u0026\u0026\n                         asJobs[oQueue.front()].nStripOrTile == nBlockId) )\n                {\n                    WaitCompletionForJobIdx(oQueue.front());\n                }\n                CPLAssert( !oQueue.empty() \u0026\u0026\n                          asJobs[oQueue.front()].poDS == this \u0026\u0026\n                          asJobs[oQueue.front()].nStripOrTile == nBlockId );\n                WaitCompletionForJobIdx(oQueue.front());\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                      SubmitCompressionJob()                          */\n/************************************************************************/\n\nbool GTiffDataset::SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         GPtrDiff_t cc, int nHeight )\n{\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    auto poQueue = m_poBaseDS ?\n        m_poBaseDS-\u003em_poCompressQueue.get() : m_poCompressQueue.get();\n\n    if( poQueue == nullptr ||\n          !(m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n            m_nCompression == COMPRESSION_LZW ||\n            m_nCompression == COMPRESSION_PACKBITS ||\n            m_nCompression == COMPRESSION_LZMA ||\n            m_nCompression == COMPRESSION_ZSTD ||\n            m_nCompression == COMPRESSION_LERC ||\n            m_nCompression == COMPRESSION_WEBP ||\n            m_nCompression == COMPRESSION_JPEG) )\n    {\n        if( m_bBlockOrderRowMajor || m_bLeaderSizeAsUInt4 ||\n            m_bTrailerRepeatedLast4BytesRepeated )\n        {\n            GTiffCompressionJob sJob;\n            memset(\u0026sJob, 0, sizeof(sJob));\n            sJob.poDS = this;\n            sJob.pszTmpFilename = CPLStrdup(CPLSPrintf(\"/vsimem/gtiff/%p\", this));\n            sJob.bTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(m_hTIFF) );\n            sJob.pabyBuffer =\n                static_cast\u003cGByte*\u003e( CPLRealloc(sJob.pabyBuffer, cc) );\n            memcpy(sJob.pabyBuffer, pabyData, cc);\n            sJob.nBufferSize = cc;\n            sJob.nHeight = nHeight;\n            sJob.nStripOrTile = nStripOrTile;\n            sJob.nPredictor = PREDICTOR_NONE;\n            if( m_nCompression == COMPRESSION_LZW ||\n                m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                m_nCompression == COMPRESSION_ZSTD )\n            {\n                TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, \u0026sJob.nPredictor );\n            }\n\n            ThreadCompressionFunc(\u0026sJob);\n\n            if( sJob.nCompressedBufferSize )\n            {\n                sJob.poDS-\u003e\n                    WriteRawStripOrTile(sJob.nStripOrTile,\n                                sJob.pabyCompressedBuffer,\n                                sJob.nCompressedBufferSize);\n            }\n\n            CPLFree(sJob.pabyBuffer);\n            VSIUnlink(sJob.pszTmpFilename);\n            CPLFree(sJob.pszTmpFilename);\n            return sJob.nCompressedBufferSize \u003e 0 \u0026\u0026 !m_bWriteError;\n        }\n\n        return false;\n    }\n\n    auto\u0026 oQueue = m_poBaseDS ? m_poBaseDS-\u003em_asQueueJobIdx : m_asQueueJobIdx;\n    auto\u0026 asJobs = m_poBaseDS ? m_poBaseDS-\u003em_asCompressionJobs : m_asCompressionJobs;\n\n    int nNextCompressionJobAvail = -1;\n\n    if( oQueue.size() == asJobs.size() )\n    {\n        CPLAssert( !oQueue.empty() );\n        nNextCompressionJobAvail = oQueue.front();\n        WaitCompletionForJobIdx(nNextCompressionJobAvail);\n    }\n    else\n    {\n        const int nJobs = static_cast\u003cint\u003e(asJobs.size());\n        for( int i = 0; i \u003c nJobs; ++i )\n        {\n            if( asJobs[i].nBufferSize == 0 )\n            {\n                nNextCompressionJobAvail = i;\n                break;\n            }\n        }\n    }\n    CPLAssert(nNextCompressionJobAvail \u003e= 0);\n\n    GTiffCompressionJob* psJob = \u0026asJobs[nNextCompressionJobAvail];\n    psJob-\u003epoDS = this;\n    psJob-\u003ebTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(m_hTIFF) );\n    psJob-\u003epabyBuffer =\n        static_cast\u003cGByte*\u003e( CPLRealloc(psJob-\u003epabyBuffer, cc) );\n    memcpy(psJob-\u003epabyBuffer, pabyData, cc);\n    psJob-\u003enBufferSize = cc;\n    psJob-\u003enHeight = nHeight;\n    psJob-\u003enStripOrTile = nStripOrTile;\n    psJob-\u003enPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n    {\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, \u0026psJob-\u003enPredictor );\n    }\n\n    poQueue-\u003eSubmitJob(ThreadCompressionFunc, psJob);\n    oQueue.push(nNextCompressionJobAvail);\n\n    return true;\n}\n\n/************************************************************************/\n/*                          DiscardLsb()                                */\n/************************************************************************/\n\ntemplate\u003cclass T\u003e static void DiscardLsbT(GByte* pabyBuffer, \n                                         size_t nBytes,\n                                         int iBand,\n                                         int nBands,\n                                         uint16 nPlanarConfig,\n                                         const GTiffDataset::MaskOffset* panMaskOffsetLsb)\n{\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        const int nMask = panMaskOffsetLsb[iBand].nMask;\n        const int nOffset = panMaskOffsetLsb[iBand].nOffset;\n        for( size_t i = 0; i \u003c nBytes/sizeof(T); ++i )\n        {\n            reinterpret_cast\u003cT*\u003e(pabyBuffer)[i] =\n                static_cast\u003cT\u003e(\n                    (reinterpret_cast\u003cT *\u003e(pabyBuffer)[i] \u0026 nMask) |\n                    nOffset);\n        }\n    }\n    else\n    {\n        for( size_t i = 0; i \u003c nBytes/sizeof(T); i += nBands )\n        {\n            for( int j = 0; j \u003c nBands; ++j )\n            {\n                reinterpret_cast\u003cT*\u003e(pabyBuffer)[i + j] =\n                    static_cast\u003cT\u003e(\n                        (reinterpret_cast\u003cT*\u003e(pabyBuffer)[i + j] \u0026\n                            panMaskOffsetLsb[j].nMask) |\n                        panMaskOffsetLsb[j].nOffset);\n            }\n        }\n    }\n}\n\nvoid GTiffDataset::DiscardLsb( GByte* pabyBuffer, GPtrDiff_t nBytes, int iBand ) const\n{\n    if( m_nBitsPerSample == 8 )\n    {\n        if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = m_panMaskOffsetLsb[iBand].nMask;\n            const int nOffset = m_panMaskOffsetLsb[iBand].nOffset;\n            for( decltype(nBytes) i = 0; i \u003c nBytes; ++i )\n            {\n                // Keep 255 in case it is alpha.\n                if( pabyBuffer[i] != 255 )\n                    pabyBuffer[i] =\n                        static_cast\u003cGByte\u003e((pabyBuffer[i] \u0026 nMask) | nOffset);\n            }\n        }\n        else\n        {\n            for( decltype(nBytes) i = 0; i \u003c nBytes; i += nBands )\n            {\n                for( int j = 0; j \u003c nBands; ++j )\n                {\n                    // Keep 255 in case it is alpha.\n                    if( pabyBuffer[i + j] != 255 )\n                        pabyBuffer[i + j] =\n                            static_cast\u003cGByte\u003e((pabyBuffer[i + j] \u0026\n                                                m_panMaskOffsetLsb[j].nMask) | m_panMaskOffsetLsb[j].nOffset);\n                }\n            }\n        }\n    }\n    else if( m_nBitsPerSample == 16 )\n    {\n        DiscardLsbT\u003cGUInt16\u003e(pabyBuffer, nBytes, iBand, nBands, m_nPlanarConfig,\n                            m_panMaskOffsetLsb);\n    }\n    else if( m_nBitsPerSample == 32 )\n    {\n        DiscardLsbT\u003cGUInt32\u003e(pabyBuffer, nBytes, iBand, nBands, m_nPlanarConfig,\n                            m_panMaskOffsetLsb);\n    }\n}\n\n/************************************************************************/\n/*                  WriteEncodedTileOrStrip()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                              int bPreserveDataBuffer )\n{\n    CPLErr eErr = CE_None;\n\n    if( TIFFIsTiled( m_hTIFF ) )\n    {\n        if( !(WriteEncodedTile(\n               tile_or_strip,\n               static_cast\u003cGByte *\u003e(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( !(WriteEncodedStrip(\n               tile_or_strip,\n               static_cast\u003cGByte *\u003e(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           FlushBlockBuf()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::FlushBlockBuf()\n\n{\n    if( m_nLoadedBlock \u003c 0 || !m_bLoadedBlockDirty )\n        return CE_None;\n\n    m_bLoadedBlockDirty = false;\n\n    const CPLErr eErr =\n        WriteEncodedTileOrStrip(m_nLoadedBlock, m_pabyBlockBuf, true);\n    if( eErr != CE_None )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                    \"WriteEncodedTile/Strip() failed.\" );\n        m_bWriteError = true;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            LoadBlockBuf()                            */\n/*                                                                      */\n/*      Load working block buffer with request block (tile/strip).      */\n/************************************************************************/\n\nCPLErr GTiffDataset::LoadBlockBuf( int nBlockId, bool bReadFromDisk )\n\n{\n    if( m_nLoadedBlock == nBlockId \u0026\u0026 m_pabyBlockBuf != nullptr )\n        return CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      If we have a dirty loaded block, flush it out first.            */\n/* -------------------------------------------------------------------- */\n    if( m_nLoadedBlock != -1 \u0026\u0026 m_bLoadedBlockDirty )\n    {\n        const CPLErr eErr = FlushBlockBuf();\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get block size.                                                 */\n/* -------------------------------------------------------------------- */\n    const GPtrDiff_t nBlockBufSize =\n        static_cast\u003cGPtrDiff_t\u003e(\n            TIFFIsTiled(m_hTIFF) ? TIFFTileSize(m_hTIFF) : TIFFStripSize(m_hTIFF));\n    if( !nBlockBufSize )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Bogus block size; unable to allocate a buffer.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( m_pabyBlockBuf == nullptr )\n    {\n        m_pabyBlockBuf =\n            static_cast\u003cGByte *\u003e( VSI_CALLOC_VERBOSE( 1, nBlockBufSize ) );\n        if( m_pabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n    if( m_nLoadedBlock == nBlockId )\n        return CE_None;\n\n/* -------------------------------------------------------------------- */\n/*  When called from ::IWriteBlock in separate cases (or in single band */\n/*  geotiffs), the ::IWriteBlock will override the content of the buffer*/\n/*  with pImage, so we don't need to read data from disk                */\n/* -------------------------------------------------------------------- */\n    if( !bReadFromDisk || m_bStreamingOut )\n    {\n        m_nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n    // libtiff 3.X doesn't like mixing read\u0026write of JPEG compressed blocks\n    // The below hack is necessary due to another hack that consist in\n    // writing zero block to force creation of JPEG tables.\n    if( nBlockId == 0 \u0026\u0026 m_bDontReloadFirstBlock )\n    {\n        m_bDontReloadFirstBlock = false;\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n        m_nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    auto nBlockReqSize = nBlockBufSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n    const int nBlockYOff = (nBlockId % m_nBlocksPerBand) / nBlocksPerRow;\n\n    if( nBlockYOff * m_nBlockYSize \u003e nRasterYSize - m_nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / m_nBlockYSize)\n            * (m_nBlockYSize - static_cast\u003cint\u003e(\n                (static_cast\u003cGIntBig\u003e(nBlockYOff + 1) * m_nBlockYSize) %\n                    nRasterYSize));\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have this block already loaded, and we know it      */\n/*      doesn't yet exist on disk, just zero the memory buffer and      */\n/*      pretend we loaded it.                                           */\n/* -------------------------------------------------------------------- */\n    bool bErrOccurred = false;\n    if( !IsBlockAvailable( nBlockId, nullptr, nullptr, \u0026bErrOccurred ) )\n    {\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n        m_nLoadedBlock = nBlockId;\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block, if it isn't our current block.                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    \n    if( !ReadStrile(nBlockId, m_pabyBlockBuf, nBlockReqSize) )\n    {\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n        eErr = CE_Failure;\n    }\n\n    if( eErr == CE_None )\n    {\n        m_nLoadedBlock = nBlockId;\n    }\n    else\n    {\n        m_nLoadedBlock = -1;\n    }\n    m_bLoadedBlockDirty = false;\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                   GTiffFillStreamableOffsetAndCount()                */\n/************************************************************************/\n\nstatic void GTiffFillStreamableOffsetAndCount( TIFF* hTIFF, int nSize )\n{\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, \u0026nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, \u0026nYSize );\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(hTIFF) );\n    const int nBlockCount =\n        bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n\n    toff_t *panOffset = nullptr;\n    TIFFGetField( hTIFF, bIsTiled ? TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                  \u0026panOffset );\n    toff_t *panSize = nullptr;\n    TIFFGetField( hTIFF,\n                  bIsTiled ? TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS,\n                  \u0026panSize );\n    toff_t nOffset = nSize;\n    // Trick to avoid clang static analyzer raising false positive about\n    // divide by zero later.\n    int nBlocksPerBand = 1;\n    uint32 nRowsPerStrip = 0;\n    if( !bIsTiled )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, \u0026nRowsPerStrip);\n        if( nRowsPerStrip \u003e static_cast\u003cuint32\u003e(nYSize) )\n            nRowsPerStrip = nYSize;\n        nBlocksPerBand = DIV_ROUND_UP(nYSize, nRowsPerStrip);\n    }\n    for( int i = 0; i \u003c nBlockCount; ++i )\n    {\n        GPtrDiff_t cc = bIsTiled ? static_cast\u003cGPtrDiff_t\u003e(TIFFTileSize(hTIFF)) :\n                            static_cast\u003cGPtrDiff_t\u003e(TIFFStripSize(hTIFF));\n        if( !bIsTiled )\n        {\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n            int nStripWithinBand = i % nBlocksPerBand;\n            if( nStripWithinBand * nRowsPerStrip \u003e nYSize - nRowsPerStrip )\n            {\n                cc = (cc / nRowsPerStrip)\n                    * (nYSize - nStripWithinBand * nRowsPerStrip);\n            }\n        }\n        panOffset[i] = nOffset;\n        panSize[i] = cc;\n        nOffset += cc;\n    }\n}\n\n/************************************************************************/\n/*                             Crystalize()                             */\n/*                                                                      */\n/*      Make sure that the directory information is written out for     */\n/*      a new file, require before writing any imagery data.            */\n/************************************************************************/\n\nvoid GTiffDataset::Crystalize()\n\n{\n    if( m_bCrystalized )\n        return;\n\n    // TODO: libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n    WriteMetadata( this, m_hTIFF, true, m_eProfile, m_pszFilename,\n                   m_papszCreationOptions );\n    WriteGeoTIFFInfo();\n    if( m_bNoDataSet )\n        WriteNoDataValue( m_hTIFF, m_dfNoDataValue );\n\n    m_bMetadataChanged = false;\n    m_bGeoTIFFInfoChanged = false;\n    m_bNoDataChanged = false;\n    m_bNeedsRewrite = false;\n\n    m_bCrystalized = true;\n\n    TIFFWriteCheck( m_hTIFF, TIFFIsTiled(m_hTIFF), \"GTiffDataset::Crystalize\");\n\n    TIFFWriteDirectory( m_hTIFF );\n    if( m_bStreamingOut )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( m_hTIFF, 0 );\n        TIFFWriteDirectory( m_hTIFF );\n\n        if( VSIFSeekL( m_fpL, 0, SEEK_END ) != 0 )\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"Could not seek\");\n        }\n        const int nSize = static_cast\u003cint\u003e( VSIFTellL(m_fpL) );\n\n        TIFFSetDirectory( m_hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( m_hTIFF, nSize );\n        TIFFWriteDirectory( m_hTIFF );\n\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( m_pszTmpFilename, \u0026nDataLength, FALSE);\n        if( static_cast\u003cint\u003e(\n                VSIFWriteL( pabyBuffer, 1,\n                            static_cast\u003cint\u003e(nDataLength), m_fpToWrite ) ) !=\n            static_cast\u003cint\u003e(nDataLength) )\n        {\n            ReportError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      static_cast\u003cint\u003e(nDataLength) );\n        }\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        TIFFSetDirectory( m_hTIFF, 0 );\n        CPLPopErrorHandler();\n    }\n    else\n    {\n        TIFFSetDirectory( m_hTIFF,\n                      static_cast\u003ctdir_t\u003e(TIFFNumberOfDirectories(m_hTIFF) - 1) );\n    }\n\n    RestoreVolatileParameters( m_hTIFF );\n\n    m_nDirOffset = TIFFCurrentDirOffset( m_hTIFF );\n}\n\n/************************************************************************/\n/*                          IsBlockAvailable()                          */\n/*                                                                      */\n/*      Return true if the indicated strip/tile is available.  We       */\n/*      establish this by testing if the stripbytecount is zero.  If    */\n/*      zero then the block has never been committed to disk.           */\n/************************************************************************/\n\nbool GTiffDataset::IsBlockAvailable( int nBlockId,\n                                     vsi_l_offset* pnOffset,\n                                     vsi_l_offset* pnSize,\n                                     bool *pbErrOccurred )\n\n{\n    if( pbErrOccurred )\n        *pbErrOccurred = false;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    std::pair\u003cvsi_l_offset, vsi_l_offset\u003e oPair;\n    if( m_oCacheStrileToOffsetByteCount.tryGet(nBlockId, oPair) )\n    {\n        if( pnOffset )\n            *pnOffset = oPair.first;\n        if( pnSize )\n            *pnSize = oPair.second;\n        return oPair.first != 0;\n    }\n#endif\n    \n    WaitCompletionForBlock(nBlockId);\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    // Optimization to avoid fetching the whole Strip/TileCounts and\n    // Strip/TileOffsets arrays.\n    if( eAccess == GA_ReadOnly \u0026\u0026 !m_bStreamingIn )\n    {\n        int nErrOccurred = 0;\n        auto bytecount = TIFFGetStrileByteCountWithErr(m_hTIFF, nBlockId, \u0026nErrOccurred);\n        if( nErrOccurred \u0026\u0026 pbErrOccurred )\n            *pbErrOccurred = true;\n        if( pnOffset )\n        {\n            *pnOffset = TIFFGetStrileOffsetWithErr(m_hTIFF, nBlockId, \u0026nErrOccurred);\n            if( nErrOccurred \u0026\u0026 pbErrOccurred )\n                *pbErrOccurred = true;\n        }\n        if( pnSize )\n            *pnSize = bytecount;\n        return bytecount != 0;\n    }\n#endif\n\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(m_hTIFF) );\n\n    if( ( bIsTiled\n          \u0026\u0026 TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, \u0026panByteCounts )\n          \u0026\u0026 (pnOffset == nullptr ||\n              TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, \u0026panOffsets )) )\n        || ( !bIsTiled\n          \u0026\u0026 TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, \u0026panByteCounts )\n          \u0026\u0026 (pnOffset == nullptr ||\n              TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, \u0026panOffsets )) ) )\n    {\n        if( panByteCounts == nullptr || (pnOffset != nullptr \u0026\u0026 panOffsets == nullptr) )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        const int nBlockCount =\n            bIsTiled ? TIFFNumberOfTiles(m_hTIFF) : TIFFNumberOfStrips(m_hTIFF);\n        if( nBlockId \u003e= nBlockCount )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( pnOffset )\n            *pnOffset = panOffsets[nBlockId];\n        if( pnSize )\n            *pnSize = panByteCounts[nBlockId];\n        return panByteCounts[nBlockId] != 0;\n    }\n    else\n    {\n        if( pbErrOccurred )\n            *pbErrOccurred = true;\n    }\n\n    return false;\n}\n\n/************************************************************************/\n/*                             FlushCache()                             */\n/*                                                                      */\n/*      We override this so we can also flush out local tiff strip      */\n/*      cache if need be.                                               */\n/************************************************************************/\n\nvoid GTiffDataset::FlushCache()\n\n{\n    FlushCacheInternal( true );\n}\n\nvoid GTiffDataset::FlushCacheInternal( bool bFlushDirectory )\n{\n    if( m_bIsFinalized )\n        return;\n\n    GDALPamDataset::FlushCache();\n\n    if( m_bLoadedBlockDirty \u0026\u0026 m_nLoadedBlock != -1 )\n        FlushBlockBuf();\n\n    CPLFree( m_pabyBlockBuf );\n    m_pabyBlockBuf = nullptr;\n    m_nLoadedBlock = -1;\n    m_bLoadedBlockDirty = false;\n\n    // Finish compression\n    auto poQueue = m_poBaseDS ? m_poBaseDS-\u003em_poCompressQueue.get() : m_poCompressQueue.get();\n    if( poQueue )\n    {\n        poQueue-\u003eWaitCompletion();\n\n        // Flush remaining data\n        auto\u0026 oQueue = m_poBaseDS ? m_poBaseDS-\u003em_asQueueJobIdx : m_asQueueJobIdx;\n        while( !oQueue.empty() )\n        {\n            WaitCompletionForJobIdx(oQueue.front());\n        }\n    }\n\n    if( bFlushDirectory \u0026\u0026 GetAccess() == GA_Update )\n    {\n        FlushDirectory();\n    }\n}\n\n/************************************************************************/\n/*                           FlushDirectory()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FlushDirectory()\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        if( m_bMetadataChanged )\n        {\n            m_bNeedsRewrite =\n                    WriteMetadata( this, m_hTIFF, true, m_eProfile, m_pszFilename,\n                                   m_papszCreationOptions );\n            m_bMetadataChanged = false;\n\n            if( m_bForceUnsetRPC )\n            {\n                double *padfRPCTag = nullptr;\n                uint16 nCount;\n                if( TIFFGetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT, \u0026nCount, \u0026padfRPCTag ) )\n                {\n                    std::vector\u003cdouble\u003e zeroes(92);\n                    TIFFSetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, zeroes.data() );\n                    TIFFUnsetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT );\n                    m_bNeedsRewrite = true;\n                }\n\n                GDALWriteRPCTXTFile( m_pszFilename, nullptr );\n                GDALWriteRPBFile( m_pszFilename, nullptr );\n            }\n        }\n\n        if( m_bGeoTIFFInfoChanged )\n        {\n            WriteGeoTIFFInfo();\n            m_bGeoTIFFInfoChanged = false;\n        }\n\n        if( m_bNoDataChanged )\n        {\n            if( m_bNoDataSet )\n            {\n                WriteNoDataValue( m_hTIFF, m_dfNoDataValue );\n            }\n            else\n            {\n                UnsetNoDataValue( m_hTIFF );\n            }\n            m_bNeedsRewrite = true;\n            m_bNoDataChanged = false;\n        }\n\n        if( m_bNeedsRewrite )\n        {\n            if( !m_bCrystalized)\n            {\n                Crystalize();\n            }\n            else\n            {\n                const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( m_hTIFF );\n\n                m_nDirOffset = pfnSizeProc( TIFFClientdata( m_hTIFF ) );\n                if( (m_nDirOffset % 2) == 1 )\n                    ++m_nDirOffset;\n\n                TIFFRewriteDirectory( m_hTIFF );\n\n                TIFFSetSubDirectory( m_hTIFF, m_nDirOffset );\n\n                if( m_bLayoutIFDSBeforeData \u0026\u0026\n                    m_bBlockOrderRowMajor \u0026\u0026\n                    m_bLeaderSizeAsUInt4 \u0026\u0026\n                    m_bTrailerRepeatedLast4BytesRepeated \u0026\u0026\n                    !m_bKnownIncompatibleEdition \u0026\u0026\n                    !m_bWriteKnownIncompatibleEdition )\n                {\n                    ReportError(CE_Warning, CPLE_AppDefined,\n                                \"The IFD has been rewritten at the end of \"\n                                \"the file, which breaks COG layout.\");\n                    m_bKnownIncompatibleEdition = true;\n                    m_bWriteKnownIncompatibleEdition = true;\n                }\n            }\n            m_bNeedsRewrite = false;\n        }\n    }\n\n    // There are some circumstances in which we can reach this point\n    // without having made this our directory (SetDirectory()) in which\n    // case we should not risk a flush.\n    if( GetAccess() == GA_Update \u0026\u0026 TIFFCurrentDirOffset(m_hTIFF) == m_nDirOffset )\n    {\n        const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( m_hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( m_hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n\n        TIFFFlush( m_hTIFF );\n\n        if( m_nDirOffset != TIFFCurrentDirOffset( m_hTIFF ) )\n        {\n            m_nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\",\n                      \"directory moved during flush in FlushDirectory()\" );\n        }\n    }\n\n    SetDirectory();\n}\n\n/************************************************************************/\n/*                           CleanOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( !m_poBaseDS );\n\n    ScanDirectories();\n\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector\u003ctoff_t\u003e anOvDirOffsets;\n\n    for( int i = 0; i \u003c m_nOverviewCount; ++i )\n    {\n        anOvDirOffsets.push_back( m_papoOverviewDS[i]-\u003em_nDirOffset );\n        delete m_papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector\u003cuint16\u003e anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( m_hTIFF, 0 );\n\n    while( true )\n    {\n        for( int i = 0; i \u003c m_nOverviewCount; ++i )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( m_hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -\u003e %d\",\n                          static_cast\u003cint\u003e(anOvDirOffsets[i]), iThisOffset );\n                anOvDirIndexes.push_back( static_cast\u003cuint16\u003e(iThisOffset) );\n            }\n        }\n\n        if( TIFFLastDirectory( m_hTIFF ) )\n            break;\n\n        TIFFReadDirectory( m_hTIFF );\n        ++iThisOffset;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( m_hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( m_papoOverviewDS );\n\n    m_nOverviewCount = 0;\n    m_papoOverviewDS = nullptr;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                   RegisterNewOverviewDataset()                       */\n/************************************************************************/\n\nCPLErr GTiffDataset::RegisterNewOverviewDataset(toff_t nOverviewOffset,\n                                                int l_nJpegQuality,\n                                                int l_nWebPLevel)\n{\n    if( m_nOverviewCount == 127 )\n        return CE_Failure;\n\n    GTiffDataset* poODS = new GTiffDataset();\n    poODS-\u003eShareLockWithParentDataset(this);\n    poODS-\u003em_pszFilename = CPLStrdup(m_pszFilename);\n    poODS-\u003em_nJpegQuality = static_cast\u003csigned char\u003e(l_nJpegQuality);\n    poODS-\u003em_nWebPLevel = static_cast\u003csigned char\u003e(l_nWebPLevel);\n    poODS-\u003em_nZLevel = m_nZLevel;\n    poODS-\u003em_nLZMAPreset = m_nLZMAPreset;\n    poODS-\u003em_nZSTDLevel = m_nZSTDLevel;\n    poODS-\u003em_bWebPLossless = m_bWebPLossless;\n    poODS-\u003em_nJpegTablesMode = m_nJpegTablesMode;\n#if HAVE_LERC\n    poODS-\u003em_dfMaxZError = m_dfMaxZError;\n    memcpy(poODS-\u003em_anLercAddCompressionAndVersion, m_anLercAddCompressionAndVersion,\n           sizeof(m_anLercAddCompressionAndVersion));\n#endif\n\n    if( poODS-\u003eOpenOffset( VSI_TIFFOpenChild(m_hTIFF), nOverviewOffset,\n                            GA_Update ) != CE_None )\n    {\n        delete poODS;\n        return CE_Failure;\n    }\n\n    // Do that now that m_nCompression is set\n    poODS-\u003eRestoreVolatileParameters( poODS-\u003em_hTIFF );\n\n    ++m_nOverviewCount;\n    m_papoOverviewDS = static_cast\u003cGTiffDataset **\u003e(\n        CPLRealloc( m_papoOverviewDS,\n                    m_nOverviewCount * (sizeof(void*))) );\n    m_papoOverviewDS[m_nOverviewCount-1] = poODS;\n    poODS-\u003em_poBaseDS = this;\n    poODS-\u003em_bIsOverview = true;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                     CreateTIFFColorTable()                           */\n/************************************************************************/\n\nstatic void CreateTIFFColorTable(GDALColorTable* poColorTable,\n                                 int nBits,\n                                 std::vector\u003cunsigned short\u003e\u0026 anTRed,\n                                 std::vector\u003cunsigned short\u003e\u0026 anTGreen,\n                                 std::vector\u003cunsigned short\u003e\u0026 anTBlue,\n                                 unsigned short*\u0026 panRed,\n                                 unsigned short*\u0026 panGreen,\n                                 unsigned short*\u0026 panBlue)\n{\n    int nColors;\n\n    if( nBits == 8 )\n        nColors = 256;\n    else if( nBits \u003c 8 )\n        nColors = 1 \u003c\u003c nBits;\n    else\n        nColors = 65536;\n\n    anTRed.resize(nColors,0);\n    anTGreen.resize(nColors,0);\n    anTBlue.resize(nColors,0);\n\n    for( int iColor = 0; iColor \u003c nColors; ++iColor )\n    {\n        if( iColor \u003c poColorTable-\u003eGetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n\n            poColorTable-\u003eGetColorEntryAsRGB( iColor, \u0026sRGB );\n\n            anTRed[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c1);\n            anTGreen[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c2);\n            anTBlue[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c3);\n        }\n        else\n        {\n            anTRed[iColor] = 0;\n            anTGreen[iColor] = 0;\n            anTBlue[iColor] = 0;\n        }\n    }\n\n    panRed = \u0026(anTRed[0]);\n    panGreen = \u0026(anTGreen[0]);\n    panBlue = \u0026(anTBlue[0]);\n}\n\n/************************************************************************/\n/*                  CreateOverviewsFromSrcOverviews()                   */\n/************************************************************************/\n\n// If poOvrDS is not null, it is used and poSrcDS is ignored.\n\nCPLErr GTiffDataset::CreateOverviewsFromSrcOverviews(GDALDataset* poSrcDS,\n                                                     GDALDataset* poOvrDS)\n{\n    CPLAssert(poSrcDS-\u003eGetRasterCount() != 0);\n    CPLAssert(m_nOverviewCount == 0);\n\n    ScanDirectories();\n\n    FlushDirectory();\n\n    int nOvBitsPerSample = m_nBitsPerSample;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector\u003cunsigned short\u003e anTRed;\n    std::vector\u003cunsigned short\u003e anTGreen;\n    std::vector\u003cunsigned short\u003e anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( m_nPhotometric == PHOTOMETRIC_PALETTE \u0026\u0026 m_poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(m_poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( \"NONE\", this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, \u0026nExtraSamples,\n                      \u0026panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast\u003cuint16*\u003e(\n                CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, \u0026nPredictor );\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(GDALRasterBand::ToHandle(GetRasterBand(1)),\n                              \u0026nOvrBlockXSize, \u0026nOvrBlockYSize);\n\n    int nSrcOverviews = poOvrDS ?\n        poOvrDS-\u003eGetRasterBand(1)-\u003eGetOverviewCount() + 1:\n        poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverviewCount();\n    CPLErr eErr = CE_None;\n\n    for( int i = 0; i \u003c nSrcOverviews \u0026\u0026 eErr == CE_None; ++i )\n    {\n        GDALRasterBand* poOvrBand = poOvrDS ?\n            ((i == 0) ? poOvrDS-\u003eGetRasterBand(1) :\n                        poOvrDS-\u003eGetRasterBand(1)-\u003eGetOverview(i-1)):\n            poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(i);\n\n        int nOXSize = poOvrBand-\u003eGetXSize();\n        int nOYSize = poOvrBand-\u003eGetYSize();\n\n        int nOvrJpegQuality = m_nJpegQuality;\n        if( m_nCompression == COMPRESSION_JPEG \u0026\u0026\n            CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrJpegQuality =\n                atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n        }\n        int nOvrWebpLevel = m_nWebPLevel;\n        if( m_nCompression == COMPRESSION_WEBP \u0026\u0026\n            CPLGetConfigOption( \"WEBP_LEVEL_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrWebpLevel =\n                atoi(CPLGetConfigOption(\"WEBP_LEVEL_OVERVIEW\",\"75\"));\n        }\n\n        CPLString osNoData; // don't move this in inner scope\n        const char* pszNoData = nullptr;\n        if( m_bNoDataSet )\n        {\n            osNoData = GTiffFormatGDALNoDataTagValue(m_dfNoDataValue);\n            pszNoData = osNoData.c_str();\n        }\n\n        toff_t nOverviewOffset =\n                GTIFFWriteDirectory(m_hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize,\n                                    nOvBitsPerSample, m_nPlanarConfig,\n                                    m_nSamplesPerPixel,\n                                    nOvrBlockXSize,\n                                    nOvrBlockYSize,\n                                    TRUE,\n                                    m_nCompression, m_nPhotometric, m_nSampleFormat,\n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata,\n                                    nOvrJpegQuality \u003e= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                                    CPLSPrintf(\"%d\", m_nJpegTablesMode),\n                                    pszNoData,\n#ifdef HAVE_LERC\n                                    m_anLercAddCompressionAndVersion,\n#else\n                                    nullptr,\n#endif\n                                    m_bWriteCOGLayout,\n                                    nOvrWebpLevel \u003e= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrWebpLevel) : nullptr\n                                   );\n\n        if( nOverviewOffset == 0 )\n            eErr = CE_Failure;\n        else\n            eErr = RegisterNewOverviewDataset(nOverviewOffset, nOvrJpegQuality, nOvrWebpLevel);\n    }\n\n    // For directory reloading, so that the chaining to the next directory is\n    // reloaded, as well as compression parameters.\n    ReloadDirectory();\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           ReloadDirectory()                          */\n/************************************************************************/\n\nvoid GTiffDataset::ReloadDirectory()\n{\n    TIFFSetSubDirectory( m_hTIFF, 0 );\n    CPL_IGNORE_RET_VAL( SetDirectory() );\n}\n\n/************************************************************************/\n/*                       CreateInternalMaskOverviews()                  */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateInternalMaskOverviews(int nOvrBlockXSize,\n                                                 int nOvrBlockYSize)\n{\n    ScanDirectories();\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    const char* pszInternalMask =\n        CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", nullptr);\n    if( m_poMaskDS != nullptr \u0026\u0026\n        m_poMaskDS-\u003eGetRasterCount() == 1 \u0026\u0026\n        (pszInternalMask == nullptr || CPLTestBool(pszInternalMask)) )\n    {\n        int nMaskOvrCompression;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"\u003cValue\u003eDEFLATE\u003c/Value\u003e\") != nullptr )\n            nMaskOvrCompression = COMPRESSION_ADOBE_DEFLATE;\n        else\n            nMaskOvrCompression = COMPRESSION_PACKBITS;\n\n        for( int i = 0; i \u003c m_nOverviewCount; ++i )\n        {\n            if( m_papoOverviewDS[i]-\u003em_poMaskDS == nullptr )\n            {\n                const toff_t nOverviewOffset =\n                    GTIFFWriteDirectory(\n                        m_hTIFF, FILETYPE_REDUCEDIMAGE | FILETYPE_MASK,\n                        m_papoOverviewDS[i]-\u003enRasterXSize,\n                        m_papoOverviewDS[i]-\u003enRasterYSize,\n                        1, PLANARCONFIG_CONTIG,\n                        1, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                        nMaskOvrCompression, PHOTOMETRIC_MASK,\n                        SAMPLEFORMAT_UINT, PREDICTOR_NONE,\n                        nullptr, nullptr, nullptr, 0, nullptr,\n                        \"\",\n                        nullptr, nullptr, nullptr, nullptr,\n                        m_bWriteCOGLayout,\n                        nullptr );\n\n                if( nOverviewOffset == 0 )\n                {\n                    eErr = CE_Failure;\n                    continue;\n                }\n\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS-\u003eShareLockWithParentDataset(this);\n                poODS-\u003em_pszFilename = CPLStrdup(m_pszFilename);\n                if( poODS-\u003eOpenOffset( VSI_TIFFOpenChild(m_hTIFF),\n                                       nOverviewOffset,\n                                       GA_Update ) != CE_None )\n                {\n                    delete poODS;\n                    eErr = CE_Failure;\n                }\n                else\n                {\n                    poODS-\u003em_bPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption(\n                                \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\" ) );\n                    poODS-\u003em_poBaseDS = this;\n                    poODS-\u003em_poImageryDS = m_papoOverviewDS[i];\n                    m_papoOverviewDS[i]-\u003em_poMaskDS = poODS;\n                    ++m_poMaskDS-\u003em_nOverviewCount;\n                    m_poMaskDS-\u003em_papoOverviewDS = static_cast\u003cGTiffDataset **\u003e(\n                        CPLRealloc(\n                            m_poMaskDS-\u003em_papoOverviewDS,\n                            m_poMaskDS-\u003em_nOverviewCount * (sizeof(void*))) );\n                    m_poMaskDS-\u003em_papoOverviewDS[m_poMaskDS-\u003em_nOverviewCount-1] =\n                        poODS;\n                }\n            }\n        }\n    }\n\n    ReloadDirectory();\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                          IBuildOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::IBuildOverviews(\n    const char * pszResampling,\n    int nOverviews, int * panOverviewList,\n    int nBandsIn, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    ScanDirectories();\n\n    // Make implicit JPEG overviews invisible, but do not destroy\n    // them in case they are already used (not sure that the client\n    // has the right to do that.  Behavior maybe undefined in GDAL API.\n    m_nJPEGOverviewCount = 0;\n\n/* -------------------------------------------------------------------- */\n/*      If RRD or external OVR overviews requested, then invoke         */\n/*      generic handling.                                               */\n/* -------------------------------------------------------------------- */\n    bool bUseGenericHandling = false;\n\n    if( CPLTestBool(CPLGetConfigOption( \"USE_RRD\", \"NO\" ))\n        || CPLTestBool(CPLGetConfigOption( \"TIFF_USE_OVR\", \"NO\" )) )\n    {\n        bUseGenericHandling = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        bUseGenericHandling = true;\n    }\n\n    if( bUseGenericHandling )\n    {\n        if( m_nOverviewCount != 0 )\n        {\n            ReportError(\n                CE_Failure, CPLE_NotSupported,\n                \"Cannot add external overviews when there are already \"\n                \"internal overviews\" );\n            return CE_Failure;\n        }\n\n        CPLErr eErr = GDALDataset::IBuildOverviews(\n            pszResampling, nOverviews, panOverviewList,\n            nBandsIn, panBandList, pfnProgress, pProgressData );\n        if( eErr == CE_None \u0026\u0026 m_poMaskDS )\n        {\n            ReportError(CE_Warning, CPLE_NotSupported,\n                     \"Building external overviews whereas there is an internal \"\n                     \"mask is not fully supported. \"\n                     \"The overviews of the non-mask bands will be created, \"\n                     \"but not the overviews of the mask band.\");\n        }\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBandsIn != GetRasterCount() )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only \"\n                  \"supported when operating on all bands.  \"\n                  \"Operation failed.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( m_nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews(\n                pszResampling, nOverviews, panOverviewList,\n                nBandsIn, panBandList, pfnProgress, pProgressData );\n\n        return CleanOverviews();\n    }\n\n    CPLErr eErr = CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, nullptr, pProgressData ) )\n    {\n        ReportError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = m_nBitsPerSample;\n\n    if( STARTS_WITH_CI(pszResampling, \"AVERAGE_BIT2\") )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector\u003cunsigned short\u003e anTRed;\n    std::vector\u003cunsigned short\u003e anTGreen;\n    std::vector\u003cunsigned short\u003e anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( m_nPhotometric == PHOTOMETRIC_PALETTE \u0026\u0026 m_poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(m_poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, \u0026nExtraSamples,\n                      \u0026panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast\u003cuint16*\u003e( CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16) );\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, \u0026nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(GDALRasterBand::ToHandle(GetRasterBand(1)),\n                              \u0026nOvrBlockXSize, \u0026nOvrBlockYSize);\n    std::vector\u003cbool\u003e abRequireNewOverview(nOverviews, true);\n    for( int i = 0; i \u003c nOverviews \u0026\u0026 eErr == CE_None; ++i )\n    {\n        for( int j = 0; j \u003c m_nOverviewCount \u0026\u0026 eErr == CE_None; ++j )\n        {\n            GTiffDataset *poODS = m_papoOverviewDS[j];\n\n            const int nOvFactor =\n                GDALComputeOvFactor(poODS-\u003eGetRasterXSize(),\n                                    GetRasterXSize(),\n                                    poODS-\u003eGetRasterYSize(),\n                                    GetRasterYSize());\n\n            // If we already have a 1x1 overview and this new one would result\n            // in it too, then don't create it.\n            if( poODS-\u003eGetRasterXSize() == 1 \u0026\u0026\n                poODS-\u003eGetRasterYSize() == 1 \u0026\u0026\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 \u0026\u0026\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n\n            if( nOvFactor == panOverviewList[i]\n                || nOvFactor == GDALOvLevelAdjust2( panOverviewList[i],\n                                                    GetRasterXSize(),\n                                                    GetRasterYSize() ) )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n        }\n\n        if( abRequireNewOverview[i] )\n        {\n            if( m_bLayoutIFDSBeforeData \u0026\u0026 !m_bKnownIncompatibleEdition \u0026\u0026\n                !m_bWriteKnownIncompatibleEdition )\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Adding new overviews invalidates the \"\n                         \"LAYOUT=IFDS_BEFORE_DATA property\");\n                m_bKnownIncompatibleEdition = true;\n                m_bWriteKnownIncompatibleEdition = true;\n            }\n\n            const int nOXSize =\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n            const int nOYSize =\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            int nOvrJpegQuality = m_nJpegQuality;\n            if( m_nCompression == COMPRESSION_JPEG \u0026\u0026\n                CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrJpegQuality =\n                    atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n            }\n            int nOvrWebpLevel = m_nWebPLevel;\n            if( m_nCompression == COMPRESSION_WEBP \u0026\u0026\n                CPLGetConfigOption( \"WEBP_LEVEL_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrWebpLevel =\n                    atoi(CPLGetConfigOption(\"WEBP_LEVEL_OVERVIEW\",\"75\"));\n            }\n\n            CPLString osNoData; // don't move this in inner scope\n            const char* pszNoData = nullptr;\n            if( m_bNoDataSet )\n            {\n                osNoData = GTiffFormatGDALNoDataTagValue(m_dfNoDataValue);\n                pszNoData = osNoData.c_str();\n            }\n\n            const toff_t nOverviewOffset =\n                GTIFFWriteDirectory(\n                    m_hTIFF, FILETYPE_REDUCEDIMAGE,\n                    nOXSize, nOYSize,\n                    nOvBitsPerSample, m_nPlanarConfig,\n                    m_nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                    m_nCompression, m_nPhotometric, m_nSampleFormat,\n                    nPredictor,\n                    panRed, panGreen, panBlue,\n                    nExtraSamples, panExtraSampleValues,\n                    osMetadata,\n                    nOvrJpegQuality \u003e= 0 ?\n                                CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                    CPLSPrintf(\"%d\", m_nJpegTablesMode),\n                    pszNoData,\n#ifdef HAVE_LERC\n                    m_anLercAddCompressionAndVersion,\n#else\n                    nullptr,\n#endif\n                    false,\n                    nOvrWebpLevel \u003e= 0 ?\n                                CPLSPrintf(\"%d\", nOvrWebpLevel) : nullptr\n            );\n\n            if( nOverviewOffset == 0 )\n                eErr = CE_Failure;\n            else\n                eErr = RegisterNewOverviewDataset(nOverviewOffset,\n                                                  nOvrJpegQuality,\n                                                  nOvrWebpLevel);\n        }\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n    ReloadDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr != CE_None )\n        return eErr;\n\n    eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if( m_poMaskDS != nullptr \u0026\u0026\n        m_poMaskDS-\u003eGetRasterCount() == 1 )\n    {\n        int nMaskOverviews = 0;\n\n        GDALRasterBand **papoOverviewBands = static_cast\u003cGDALRasterBand **\u003e(\n            CPLCalloc(sizeof(void*),m_nOverviewCount) );\n        for( int i = 0; i \u003c m_nOverviewCount; ++i )\n        {\n            if( m_papoOverviewDS[i]-\u003em_poMaskDS != nullptr )\n            {\n                papoOverviewBands[nMaskOverviews++] =\n                        m_papoOverviewDS[i]-\u003em_poMaskDS-\u003eGetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews(\n            m_poMaskDS-\u003eGetRasterBand(1),\n            nMaskOverviews,\n            reinterpret_cast\u003cGDALRasterBandH *\u003e( papoOverviewBands ),\n            pszResampling, GDALDummyProgress, nullptr );\n        CPLFree(papoOverviewBands);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if( m_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )-\u003e\n                              GetRasterDataType()) == FALSE \u0026\u0026\n        GetRasterBand( panBandList[0] )-\u003eGetColorTable() == nullptr \u0026\u0026\n        (STARTS_WITH_CI(pszResampling, \"NEAR\") ||\n         EQUAL(pszResampling, \"AVERAGE\") ||\n         EQUAL(pszResampling, \"GAUSS\") ||\n         EQUAL(pszResampling, \"CUBIC\") ||\n         EQUAL(pszResampling, \"CUBICSPLINE\") ||\n         EQUAL(pszResampling, \"LANCZOS\") ||\n         EQUAL(pszResampling, \"BILINEAR\")) )\n    {\n        // In the case of pixel interleaved compressed overviews, we want to\n        // generate the overviews for all the bands block by block, and not\n        // band after band, in order to write the block once and not loose\n        // space in the TIFF file.  We also use that logic for uncompressed\n        // overviews, since GDALRegenerateOverviewsMultiBand() will be able to\n        // trigger cascading overview regeneration even in the presence\n        // of an alpha band.\n\n        int nNewOverviews = 0;\n\n        GDALRasterBand ***papapoOverviewBands =\n            static_cast\u003cGDALRasterBand ***\u003e(CPLCalloc(sizeof(void*),nBandsIn));\n        GDALRasterBand **papoBandList =\n            static_cast\u003cGDALRasterBand **\u003e(CPLCalloc(sizeof(void*),nBandsIn));\n        for( int iBand = 0; iBand \u003c nBandsIn; ++iBand )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] =\n                static_cast\u003cGDALRasterBand **\u003e( CPLCalloc(\n                    sizeof(void*), poBand-\u003eGetOverviewCount()) );\n\n            int iCurOverview = 0;\n            std::vector\u003cbool\u003e abAlreadyUsedOverviewBand(\n                poBand-\u003eGetOverviewCount(), false);\n\n            for( int i = 0; i \u003c nOverviews; ++i )\n            {\n                for( int j = 0; j \u003c poBand-\u003eGetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand-\u003eGetOverview( j );\n\n                    nOvFactor = GDALComputeOvFactor(poOverview-\u003eGetXSize(),\n                                                     poBand-\u003eGetXSize(),\n                                                     poOverview-\u003eGetYSize(),\n                                                     poBand-\u003eGetYSize());\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand-\u003eGetNoDataValue(\u0026bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview-\u003eSetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand-\u003eGetXSize(),\n                                            poBand-\u003eGetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(iCurOverview \u003c poBand-\u003eGetOverviewCount());\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        ++iCurOverview ;\n                        break;\n                    }\n                }\n            }\n\n            if( nNewOverviews == 0 )\n            {\n                nNewOverviews = iCurOverview;\n            }\n            else if( nNewOverviews != iCurOverview )\n            {\n                CPLAssert(false);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand( nBandsIn, papoBandList,\n                                          nNewOverviews, papapoOverviewBands,\n                                          pszResampling, pfnProgress,\n                                          pProgressData );\n\n        for( int iBand = 0; iBand \u003c nBandsIn; ++iBand )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands = static_cast\u003cGDALRasterBand **\u003e(\n            CPLCalloc(sizeof(void*), nOverviews) );\n\n        for( int iBand = 0; iBand \u003c nBandsIn \u0026\u0026 eErr == CE_None; ++iBand )\n        {\n            GDALRasterBand *poBand = GetRasterBand( panBandList[iBand] );\n            if( poBand == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n\n            std::vector\u003cbool\u003e abAlreadyUsedOverviewBand(\n                poBand-\u003eGetOverviewCount(), false);\n\n            int nNewOverviews = 0;\n            for( int i = 0; i \u003c nOverviews; ++i )\n            {\n                for( int j = 0; j \u003c poBand-\u003eGetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    GDALRasterBand * poOverview = poBand-\u003eGetOverview( j );\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand-\u003eGetNoDataValue(\u0026bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview-\u003eSetNoDataValue(noDataValue);\n\n                    const int nOvFactor =\n                        GDALComputeOvFactor(poOverview-\u003eGetXSize(),\n                                            poBand-\u003eGetXSize(),\n                                            poOverview-\u003eGetYSize(),\n                                            poBand-\u003eGetYSize());\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand-\u003eGetXSize(),\n                                            poBand-\u003eGetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(nNewOverviews \u003c poBand-\u003eGetOverviewCount());\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    iBand / static_cast\u003cdouble\u003e( nBandsIn ),\n                    (iBand + 1) / static_cast\u003cdouble\u003e( nBandsIn ),\n                    pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews(\n                poBand,\n                nNewOverviews,\n                reinterpret_cast\u003cGDALRasterBandH *\u003e( papoOverviewBands ),\n                pszResampling,\n                GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n    pfnProgress( 1.0, nullptr, pProgressData );\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                      GTiffWriteDummyGeokeyDirectory()                */\n/************************************************************************/\n\nstatic void GTiffWriteDummyGeokeyDirectory( TIFF* hTIFF )\n{\n    // If we have existing geokeys, try to wipe them\n    // by writing a dummy geokey directory. (#2546)\n    uint16 *panVI = nullptr;\n    uint16 nKeyCount = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        \u0026nKeyCount, \u0026panVI ) )\n    {\n        GUInt16 anGKVersionInfo[4] = { 1, 1, 0, 0 };\n        double adfDummyDoubleParams[1] = { 0.0 };\n        TIFFSetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        4, anGKVersionInfo );\n        TIFFSetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS,\n                        1, adfDummyDoubleParams );\n        TIFFSetField( hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\" );\n    }\n}\n\n/************************************************************************/\n/*               GTiffDatasetLibGeotiffErrorCallback()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetLibGeotiffErrorCallback(GTIF*,\n                                                int level,\n                                                const char* pszMsg, ...)\n{\n    va_list ap;\n    va_start(ap, pszMsg);\n    CPLErrorV( (level == LIBGEOTIFF_WARNING ) ? CE_Warning : CE_Failure,\n               CPLE_AppDefined, pszMsg, ap );\n    va_end(ap);\n}\n\n/************************************************************************/\n/*                           GTiffDatasetGTIFNew()                      */\n/************************************************************************/\n\nstatic GTIF* GTiffDatasetGTIFNew( TIFF* hTIFF )\n{\n    GTIF* gtif = GTIFNewEx(hTIFF, GTiffDatasetLibGeotiffErrorCallback, nullptr);\n    if( gtif )\n    {\n        GTIFAttachPROJContext(gtif, OSRGetProjTLSContext());\n    }\n    return gtif;\n}\n\n/************************************************************************/\n/*                          WriteGeoTIFFInfo()                          */\n/************************************************************************/\n\nvoid GTiffDataset::WriteGeoTIFFInfo()\n\n{\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    const char* pszAreaOrPoint =\n        GTiffDataset::GetMetadataItem( GDALMD_AREA_OR_POINT );\n    if( pszAreaOrPoint \u0026\u0026 EQUAL(pszAreaOrPoint, GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n    if( m_bForceUnsetGTOrGCPs )\n    {\n        m_bNeedsRewrite = true;\n        m_bForceUnsetGTOrGCPs = false;\n\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTRANSMATRIX );\n    }\n\n    if( m_bForceUnsetProjection )\n    {\n        m_bNeedsRewrite = true;\n        m_bForceUnsetProjection = false;\n\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOKEYDIRECTORY );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEODOUBLEPARAMS );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOASCIIPARAMS );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write geotransform if valid.                                    */\n/* -------------------------------------------------------------------- */\n    if( m_bGeoTransformValid )\n    {\n        m_bNeedsRewrite = true;\n\n/* -------------------------------------------------------------------- */\n/*      Clear old tags to ensure we don't end up with conflicting       */\n/*      information. (#2625)                                            */\n/* -------------------------------------------------------------------- */\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTRANSMATRIX );\n\n/* -------------------------------------------------------------------- */\n/*      Write the transform.  If we have a normal north-up image we     */\n/*      use the tiepoint plus pixelscale otherwise we use a matrix.     */\n/* -------------------------------------------------------------------- */\n        if( m_adfGeoTransform[2] == 0.0 \u0026\u0026 m_adfGeoTransform[4] == 0.0\n                \u0026\u0026 m_adfGeoTransform[5] \u003c 0.0 )\n        {\n            double dfOffset = 0.0;\n            if( m_eProfile != GTiffProfile::BASELINE )\n            {\n                // In the case the SRS has a vertical component and we have\n                // a single band, encode its scale/offset in the GeoTIFF tags\n                int bHasScale = FALSE;\n                double dfScale = GetRasterBand(1)-\u003eGetScale(\u0026bHasScale);\n                int bHasOffset = FALSE;\n                dfOffset = GetRasterBand(1)-\u003eGetOffset(\u0026bHasOffset);\n                const bool bApplyScaleOffset =\n                    m_oSRS.IsVertical() \u0026\u0026\n                    GetRasterCount() == 1;\n                if( bApplyScaleOffset \u0026\u0026 !bHasScale )\n                    dfScale = 1.0;\n                if( !bApplyScaleOffset || !bHasOffset )\n                    dfOffset = 0.0;\n                const double adfPixelScale[3] = {\n                    m_adfGeoTransform[1], fabs(m_adfGeoTransform[5]),\n                    bApplyScaleOffset ? dfScale  : 0.0 };\n                TIFFSetField( m_hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            }\n\n            double adfTiePoints[6] = {\n                0.0, 0.0, 0.0, m_adfGeoTransform[0], m_adfGeoTransform[3], dfOffset };\n\n            if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n            {\n                adfTiePoints[3] +=\n                    m_adfGeoTransform[1] * 0.5 + m_adfGeoTransform[2] * 0.5;\n                adfTiePoints[4] +=\n                    m_adfGeoTransform[4] * 0.5 + m_adfGeoTransform[5] * 0.5;\n            }\n\n            if( m_eProfile != GTiffProfile::BASELINE )\n                TIFFSetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n        }\n        else\n        {\n            double adfMatrix[16] = {};\n\n            adfMatrix[0] = m_adfGeoTransform[1];\n            adfMatrix[1] = m_adfGeoTransform[2];\n            adfMatrix[3] = m_adfGeoTransform[0];\n            adfMatrix[4] = m_adfGeoTransform[4];\n            adfMatrix[5] = m_adfGeoTransform[5];\n            adfMatrix[7] = m_adfGeoTransform[3];\n            adfMatrix[15] = 1.0;\n\n            if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n            {\n                adfMatrix[3] +=\n                    m_adfGeoTransform[1] * 0.5 + m_adfGeoTransform[2] * 0.5;\n                adfMatrix[7] +=\n                    m_adfGeoTransform[4] * 0.5 + m_adfGeoTransform[5] * 0.5;\n            }\n\n            if( m_eProfile != GTiffProfile::BASELINE )\n                TIFFSetField( m_hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n        }\n\n        // Do we need a world file?\n        if( CPLFetchBool( m_papszCreationOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( m_pszFilename, \"tfw\", m_adfGeoTransform );\n        else if( CPLFetchBool( m_papszCreationOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( m_pszFilename, \"wld\", m_adfGeoTransform );\n    }\n    else if( GetGCPCount() \u003e 0 )\n    {\n        m_bNeedsRewrite = true;\n\n        double *padfTiePoints = static_cast\u003cdouble *\u003e(\n            CPLMalloc( 6 * sizeof(double) * GetGCPCount() ) );\n\n        for( int iGCP = 0; iGCP \u003c GetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = m_pasGCPList[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = m_pasGCPList[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = m_pasGCPList[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = m_pasGCPList[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = m_pasGCPList[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        if( m_eProfile != GTiffProfile::BASELINE )\n            TIFFSetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                          6 * GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out projection definition.                                */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection = !m_oSRS.IsEmpty();\n    if( (bHasProjection || bPixelIsPoint)\n        \u0026\u0026 m_eProfile != GTiffProfile::BASELINE )\n    {\n        m_bNeedsRewrite = true;\n\n        // If we have existing geokeys, try to wipe them\n        // by writing a dummy geokey directory. (#2546)\n        GTiffWriteDummyGeokeyDirectory(m_hTIFF);\n\n        GTIF *psGTIF = GTiffDatasetGTIFNew( m_hTIFF );\n\n        // Set according to coordinate system.\n        if( bHasProjection )\n        {\n            char* pszProjection = nullptr;\n            {\n                CPLErrorStateBackuper oErrorStateBackuper;\n                CPLErrorHandlerPusher oErrorHandler(CPLQuietErrorHandler);\n                m_oSRS.exportToWkt(\u0026pszProjection);\n            }\n            if( pszProjection \u0026\u0026 pszProjection[0] \u0026\u0026\n                strstr(pszProjection, \"custom_proj4\") == nullptr )\n            {\n                GTIFSetFromOGISDefnEx( psGTIF, pszProjection,\n                                       m_eGeoTIFFKeysFlavor,\n                                       m_eGeoTIFFVersion );\n            }\n            else\n            {\n                GDALPamDataset::SetSpatialRef(\u0026m_oSRS);\n            }\n            CPLFree(pszProjection);\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         AppendMetadataItem()                         */\n/************************************************************************/\n\nstatic void AppendMetadataItem( CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                                const char *pszKey, const char *pszValue,\n                                int nBand, const char *pszRole,\n                                const char *pszDomain )\n\n{\n/* -------------------------------------------------------------------- */\n/*      Create the Item element, and subcomponents.                     */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psItem = CPLCreateXMLNode( nullptr, CXT_Element, \"Item\" );\n    CPLCreateXMLNode( CPLCreateXMLNode( psItem, CXT_Attribute, \"name\"),\n                      CXT_Text, pszKey );\n\n    if( nBand \u003e 0 )\n    {\n        char szBandId[32] = {};\n        snprintf( szBandId, sizeof(szBandId), \"%d\", nBand - 1 );\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"sample\"),\n                          CXT_Text, szBandId );\n    }\n\n    if( pszRole != nullptr )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"role\"),\n                          CXT_Text, pszRole );\n\n    if( pszDomain != nullptr \u0026\u0026 strlen(pszDomain) \u003e 0 )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"domain\"),\n                          CXT_Text, pszDomain );\n\n    char *pszEscapedItemValue = CPLEscapeString(pszValue,-1,CPLES_XML);\n    CPLCreateXMLNode( psItem, CXT_Text, pszEscapedItemValue );\n    CPLFree( pszEscapedItemValue );\n\n/* -------------------------------------------------------------------- */\n/*      Create root, if missing.                                        */\n/* -------------------------------------------------------------------- */\n    if( *ppsRoot == nullptr )\n        *ppsRoot = CPLCreateXMLNode( nullptr, CXT_Element, \"GDALMetadata\" );\n\n/* -------------------------------------------------------------------- */\n/*      Append item to tail.  We keep track of the tail to avoid        */\n/*      O(nsquared) time as the list gets longer.                       */\n/* -------------------------------------------------------------------- */\n    if( *ppsTail == nullptr )\n        CPLAddXMLChild( *ppsRoot, psItem );\n    else\n        CPLAddXMLSibling( *ppsTail, psItem );\n\n    *ppsTail = psItem;\n}\n\n/************************************************************************/\n/*                         WriteMDMetadata()                            */\n/************************************************************************/\n\nstatic void WriteMDMetadata( GDALMultiDomainMetadata *poMDMD, TIFF *hTIFF,\n                             CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                             int nBand, GTiffProfile eProfile )\n\n{\n\n/* ==================================================================== */\n/*      Process each domain.                                            */\n/* ==================================================================== */\n    char **papszDomainList = poMDMD-\u003eGetDomainList();\n    for( int iDomain = 0;\n         papszDomainList \u0026\u0026 papszDomainList[iDomain];\n         ++iDomain )\n    {\n        char **papszMD = poMDMD-\u003eGetMetadata( papszDomainList[iDomain] );\n        bool bIsXML = false;\n\n        if( EQUAL(papszDomainList[iDomain], \"IMAGE_STRUCTURE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], \"COLOR_PROFILE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], MD_DOMAIN_RPC) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:ESRI\")\n            \u0026\u0026 CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:XMP\") )\n            continue;  // Handled in SetMetadata.\n\n        if( STARTS_WITH_CI(papszDomainList[iDomain], \"xml:\") )\n            bIsXML = true;\n\n/* -------------------------------------------------------------------- */\n/*      Process each item in this domain.                               */\n/* -------------------------------------------------------------------- */\n        for( int iItem = 0; papszMD \u0026\u0026 papszMD[iItem]; ++iItem )\n        {\n            const char *pszItemValue = nullptr;\n            char *pszItemName = nullptr;\n\n            if( bIsXML )\n            {\n                pszItemName = CPLStrdup(\"doc\");\n                pszItemValue = papszMD[iItem];\n            }\n            else\n            {\n                pszItemValue = CPLParseNameValue( papszMD[iItem], \u0026pszItemName);\n                if( pszItemName == nullptr )\n                {\n                    CPLDebug( \"GTiff\",\n                              \"Invalid metadata item : %s\", papszMD[iItem] );\n                    continue;\n                }\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Convert into XML item or handle as a special TIFF tag.          */\n/* -------------------------------------------------------------------- */\n            if( strlen(papszDomainList[iDomain]) == 0\n                \u0026\u0026 nBand == 0 \u0026\u0026\n                (STARTS_WITH_CI(pszItemName, \"TIFFTAG_\") ||\n                 (EQUAL(pszItemName, \"GEO_METADATA\") \u0026\u0026\n                  eProfile == GTiffProfile::GDALGEOTIFF) ||\n                 (EQUAL(pszItemName, \"TIFF_RSID\") \u0026\u0026\n                  eProfile == GTiffProfile::GDALGEOTIFF)) )\n            {\n                if( EQUAL(pszItemName, \"TIFFTAG_RESOLUTIONUNIT\") )\n                {\n                    // ResolutionUnit can't be 0, which is the default if\n                    // atoi() fails.  Set to 1=Unknown.\n                    int v = atoi(pszItemValue);\n                    if( !v ) v = RESUNIT_NONE;\n                    TIFFSetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, v);\n                }\n                else\n                {\n                    bool bFoundTag = false;\n                    size_t iTag = 0;  // Used after for.\n                    for( ;\n                         iTag \u003c sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                         ++iTag )\n                    {\n                        if( EQUAL(pszItemName, asTIFFTags[iTag].pszTagName) )\n                        {\n                            bFoundTag = true;\n                            break;\n                        }\n                    }\n\n                    if( bFoundTag \u0026\u0026\n                        asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      pszItemValue );\n                    else if( bFoundTag \u0026\u0026\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      CPLAtof(pszItemValue) );\n                    else if( bFoundTag \u0026\u0026\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      atoi(pszItemValue) );\n                    else if( bFoundTag \u0026\u0026\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n                    {\n                        uint32 nLen = static_cast\u003cuint32\u003e(strlen(pszItemValue));\n                        if( nLen )\n                        {\n                            TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                          nLen,\n                                          pszItemValue );\n                        }\n                    }\n                    else\n                        CPLError(\n                            CE_Warning, CPLE_NotSupported,\n                            \"%s metadata item is unhandled and \"\n                            \"will not be written\",\n                            pszItemName);\n                }\n            }\n            else if( nBand == 0 \u0026\u0026 EQUAL(pszItemName,GDALMD_AREA_OR_POINT) )\n            {\n                /* Do nothing, handled elsewhere. */;\n            }\n            else\n            {\n                AppendMetadataItem( ppsRoot, ppsTail,\n                                    pszItemName, pszItemValue,\n                                    nBand, nullptr, papszDomainList[iDomain] );\n            }\n\n            CPLFree( pszItemName );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Remove TIFFTAG_xxxxxx that are already set but no longer in     */\n/*      the metadata list (#5619)                                       */\n/* -------------------------------------------------------------------- */\n        if( strlen(papszDomainList[iDomain]) == 0 \u0026\u0026 nBand == 0 )\n        {\n            for( size_t iTag = 0;\n                 iTag \u003c sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                 ++iTag )\n            {\n                uint32 nCount = 0;\n                char* pszText = nullptr;\n                int16 nVal = 0;\n                float fVal = 0.0f;\n                const char* pszVal =\n                    CSLFetchNameValue(papszMD, asTIFFTags[iTag].pszTagName);\n                if( pszVal == nullptr \u0026\u0026\n                    ((asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING \u0026\u0026\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                    \u0026pszText )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT \u0026\u0026\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, \u0026nVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT \u0026\u0026\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, \u0026fVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING \u0026\u0026\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, \u0026nCount, \u0026pszText ))) )\n                {\n                    TIFFUnsetField( hTIFF, asTIFFTags[iTag].nTagVal );\n                }\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                           WriteRPC()                                 */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRPC( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                             int bSrcIsGeoTIFF,\n                             GTiffProfile eProfile,\n                             const char *pszTIFFFilename,\n                             char **l_papszCreationOptions,\n                             bool bWriteOnlyInPAMIfNeeded )\n{\n/* -------------------------------------------------------------------- */\n/*      Handle RPC data written to TIFF RPCCoefficient tag, RPB file,   */\n/*      RPCTEXT file or PAM.                                            */\n/* -------------------------------------------------------------------- */\n    char **papszRPCMD = poSrcDS-\u003eGetMetadata(MD_DOMAIN_RPC);\n    if( papszRPCMD != nullptr )\n    {\n        bool bRPCSerializedOtherWay = false;\n\n        if( eProfile == GTiffProfile::GDALGEOTIFF )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GTiffDatasetWriteRPCTag( l_hTIFF, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        // Write RPB file if explicitly asked, or if a non GDAL specific\n        // profile is selected and RPCTXT is not asked.\n        bool bRPBExplicitlyAsked =\n            CPLFetchBool( l_papszCreationOptions, \"RPB\", false );\n        bool bRPBExplicitlyDenied =\n            !CPLFetchBool( l_papszCreationOptions, \"RPB\", true );\n        if( (eProfile != GTiffProfile::GDALGEOTIFF \u0026\u0026\n             !CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) \u0026\u0026\n             !bRPBExplicitlyDenied )\n            || bRPBExplicitlyAsked )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPBFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPCTXTFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( !bRPCSerializedOtherWay \u0026\u0026 bWriteOnlyInPAMIfNeeded \u0026\u0026\n            bSrcIsGeoTIFF )\n            cpl::down_cast\u003cGTiffDataset*\u003e(poSrcDS)-\u003e\n                GDALPamDataset::SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n    }\n}\n\n/************************************************************************/\n/*                  IsStandardColorInterpretation()                     */\n/************************************************************************/\n\nstatic bool IsStandardColorInterpretation(GDALDataset* poSrcDS,\n                                          uint16 nPhotometric,\n                                          char** papszCreationOptions)\n{\n    bool bStardardColorInterp = true;\n    if( nPhotometric == PHOTOMETRIC_MINISBLACK )\n    {\n        for( int i = 0; i \u003c poSrcDS-\u003eGetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS-\u003eGetRasterBand(i + 1)-\u003eGetColorInterpretation();\n            if( !(eInterp == GCI_GrayIndex || eInterp == GCI_Undefined ||\n                    (i \u003e 0 \u0026\u0026 eInterp == GCI_AlphaBand)) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        bStardardColorInterp =\n            poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorInterpretation() ==\n                GCI_PaletteIndex;\n    }\n    else if( nPhotometric == PHOTOMETRIC_RGB )\n    {\n        int iStart = 0;\n        if( EQUAL(CSLFetchNameValueDef(papszCreationOptions,\n                                       \"PHOTOMETRIC\", \"\"), \"RGB\") )\n        {\n            iStart = 3;\n            if( poSrcDS-\u003eGetRasterCount() == 4 \u0026\u0026\n                CSLFetchNameValue(papszCreationOptions, \"ALPHA\") != nullptr )\n            {\n                iStart = 4;\n            }\n        }\n        for( int i = iStart; i \u003c poSrcDS-\u003eGetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS-\u003eGetRasterBand(i+1)-\u003eGetColorInterpretation();\n            if( !((i == 0 \u0026\u0026 eInterp == GCI_RedBand) ||\n                    (i == 1 \u0026\u0026 eInterp == GCI_GreenBand) ||\n                    (i == 2 \u0026\u0026 eInterp == GCI_BlueBand) ||\n                    (i \u003e= 3 \u0026\u0026 (eInterp == GCI_Undefined ||\n                                eInterp == GCI_AlphaBand))) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_YCBCR \u0026\u0026\n             poSrcDS-\u003eGetRasterCount() == 3 )\n    {\n        // do nothing\n    }\n    else\n    {\n        bStardardColorInterp = false;\n    }\n    return bStardardColorInterp;\n}\n\n/************************************************************************/\n/*                           WriteMetadata()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteMetadata( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                                  bool bSrcIsGeoTIFF,\n                                  GTiffProfile eProfile,\n                                  const char *pszTIFFFilename,\n                                  char **l_papszCreationOptions,\n                                  bool bExcludeRPBandIMGFileWriting)\n\n{\n/* -------------------------------------------------------------------- */\n/*      Convert all the remaining metadata into a simple XML            */\n/*      format.                                                         */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = nullptr;\n    CPLXMLNode *psTail = nullptr;\n\n    if( bSrcIsGeoTIFF )\n    {\n        GTiffDataset* poSrcDSGTiff = cpl::down_cast\u003cGTiffDataset *\u003e(poSrcDS);\n        assert(poSrcDSGTiff);\n        WriteMDMetadata(\n            \u0026poSrcDSGTiff-\u003em_oGTiffMDMD,\n            l_hTIFF, \u0026psRoot, \u0026psTail, 0, eProfile );\n    }\n    else\n    {\n        char **papszMD = poSrcDS-\u003eGetMetadata();\n\n        if( CSLCount(papszMD) \u003e 0 )\n        {\n            GDALMultiDomainMetadata l_oMDMD;\n            l_oMDMD.SetMetadata( papszMD );\n\n            WriteMDMetadata( \u0026l_oMDMD, l_hTIFF, \u0026psRoot, \u0026psTail,\n                             0, eProfile );\n        }\n    }\n\n    if( !bExcludeRPBandIMGFileWriting )\n    {\n        WriteRPC(poSrcDS, l_hTIFF, bSrcIsGeoTIFF,\n                 eProfile, pszTIFFFilename,\n                 l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      Handle metadata data written to an IMD file.                    */\n/* -------------------------------------------------------------------- */\n        char **papszIMDMD = poSrcDS-\u003eGetMetadata(MD_DOMAIN_IMD);\n        if( papszIMDMD != nullptr )\n        {\n            GDALWriteIMDFile( pszTIFFFilename, papszIMDMD );\n        }\n    }\n\n    uint16 nPhotometric = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, \u0026(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(poSrcDS, nPhotometric,\n                                      l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      We also need to address band specific metadata, and special     */\n/*      \"role\" metadata.                                                */\n/* -------------------------------------------------------------------- */\n    for( int nBand = 1; nBand \u003c= poSrcDS-\u003eGetRasterCount(); ++nBand )\n    {\n        GDALRasterBand *poBand = poSrcDS-\u003eGetRasterBand( nBand );\n\n        if( bSrcIsGeoTIFF )\n        {\n            GTiffRasterBand* poSrcBandGTiff = cpl::down_cast\u003cGTiffRasterBand *\u003e(poBand);\n            assert(poSrcBandGTiff);\n            WriteMDMetadata(\n                \u0026poSrcBandGTiff-\u003em_oGTiffMDMD,\n                l_hTIFF, \u0026psRoot, \u0026psTail, nBand, eProfile );\n        }\n        else\n        {\n            char **papszMD = poBand-\u003eGetMetadata();\n\n            if( CSLCount(papszMD) \u003e 0 )\n            {\n                GDALMultiDomainMetadata l_oMDMD;\n                l_oMDMD.SetMetadata( papszMD );\n\n                WriteMDMetadata( \u0026l_oMDMD, l_hTIFF, \u0026psRoot, \u0026psTail, nBand,\n                                 eProfile );\n            }\n        }\n\n        const double dfOffset = poBand-\u003eGetOffset();\n        const double dfScale = poBand-\u003eGetScale();\n        bool bGeoTIFFScaleOffsetInZ = false;\n        double adfGeoTransform[6];\n        // Check if we have already encoded scale/offset in the GeoTIFF tags\n        if( poSrcDS-\u003eGetGeoTransform(adfGeoTransform) == CE_None \u0026\u0026\n            adfGeoTransform[2] == 0.0 \u0026\u0026 adfGeoTransform[4] == 0.0\n            \u0026\u0026 adfGeoTransform[5] \u003c 0.0 \u0026\u0026\n            poSrcDS-\u003eGetSpatialRef() \u0026\u0026\n            poSrcDS-\u003eGetSpatialRef()-\u003eIsVertical() \u0026\u0026\n            poSrcDS-\u003eGetRasterCount() == 1 )\n        {\n            bGeoTIFFScaleOffsetInZ = true;\n        }\n\n        if( (dfOffset != 0.0 || dfScale != 1.0) \u0026\u0026 !bGeoTIFFScaleOffsetInZ )\n        {\n            char szValue[128] = {};\n\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfOffset );\n            AppendMetadataItem( \u0026psRoot, \u0026psTail, \"OFFSET\", szValue, nBand,\n                                \"offset\", \"\" );\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfScale );\n            AppendMetadataItem( \u0026psRoot, \u0026psTail, \"SCALE\", szValue, nBand,\n                                \"scale\", \"\" );\n        }\n\n        const char* pszUnitType = poBand-\u003eGetUnitType();\n        if( pszUnitType != nullptr \u0026\u0026 pszUnitType[0] != '\\0' )\n        {\n            bool bWriteUnit = true;\n            auto poSRS = poSrcDS-\u003eGetSpatialRef();\n            if( poSRS \u0026\u0026 poSRS-\u003eIsCompound() )\n            {\n                const char* pszVertUnit = nullptr;\n                poSRS-\u003eGetTargetLinearUnits(\"COMPD_CS|VERT_CS\", \u0026pszVertUnit);\n                if( pszVertUnit \u0026\u0026 EQUAL(pszVertUnit, pszUnitType) )\n                {\n                    bWriteUnit = false;\n                }\n            }\n            if( bWriteUnit )\n            {\n                AppendMetadataItem( \u0026psRoot, \u0026psTail, \"UNITTYPE\",\n                                    pszUnitType, nBand,\n                                    \"unittype\", \"\" );\n            }\n        }\n\n        if( strlen(poBand-\u003eGetDescription()) \u003e 0 )\n        {\n            AppendMetadataItem( \u0026psRoot, \u0026psTail, \"DESCRIPTION\",\n                                poBand-\u003eGetDescription(), nBand,\n                                \"description\", \"\" );\n        }\n\n        if( !bStardardColorInterp \u0026\u0026\n            !(nBand \u003c= 3 \u0026\u0026  EQUAL(CSLFetchNameValueDef(\n                l_papszCreationOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") ) )\n        {\n            AppendMetadataItem( \u0026psRoot, \u0026psTail, \"COLORINTERP\",\n                                GDALGetColorInterpretationName(\n                                    poBand-\u003eGetColorInterpretation()),\n                                nBand,\n                                \"colorinterp\", \"\" );\n        }\n    }\n\n    const char* pszTilingSchemeName =\n        CSLFetchNameValue(l_papszCreationOptions, \"@TILING_SCHEME_NAME\");\n    if( pszTilingSchemeName )\n    {\n        AppendMetadataItem( \u0026psRoot, \u0026psTail,\n                            \"NAME\", pszTilingSchemeName,\n                            0, nullptr, \"TILING_SCHEME\" );\n\n        const char* pszZoomLevel = CSLFetchNameValue(\n            l_papszCreationOptions, \"@TILING_SCHEME_ZOOM_LEVEL\");\n        if( pszZoomLevel )\n        {\n            AppendMetadataItem( \u0026psRoot, \u0026psTail,\n                                \"ZOOM_LEVEL\", pszZoomLevel,\n                                0, nullptr, \"TILING_SCHEME\" );\n        }\n\n        const char* pszAlignedLevels = CSLFetchNameValue(\n            l_papszCreationOptions, \"@TILING_SCHEME_ALIGNED_LEVELS\");\n        if( pszAlignedLevels )\n        {\n            AppendMetadataItem( \u0026psRoot, \u0026psTail,\n                                \"ALIGNED_LEVELS\", pszAlignedLevels,\n                                0, nullptr, \"TILING_SCHEME\" );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the generic XML metadata if there is any.             */\n/* -------------------------------------------------------------------- */\n    if( psRoot != nullptr )\n    {\n        bool bRet = true;\n\n        if( eProfile == GTiffProfile::GDALGEOTIFF )\n        {\n            char *pszXML_MD = CPLSerializeXMLTree( psRoot );\n            if( strlen(pszXML_MD) \u003e 32000 )\n            {\n                if( bSrcIsGeoTIFF )\n                {\n                    if( cpl::down_cast\u003cGTiffDataset *\u003e(\n                           poSrcDS)-\u003eGetPamFlags() \u0026 GPF_DISABLED )\n                    {\n                        ReportError(\n                            pszTIFFFilename, CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF.\" );\n                    }\n                    else\n                    {\n                        cpl::down_cast\u003cGTiffDataset *\u003e(poSrcDS)-\u003e\n                            PushMetadataToPam();\n                        ReportError(\n                            pszTIFFFilename, CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF. Transferred to PAM instead.\" );\n                    }\n                }\n                else\n                {\n                    bRet = false;\n                }\n            }\n            else\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD );\n            }\n            CPLFree( pszXML_MD );\n        }\n        else\n        {\n            if( bSrcIsGeoTIFF )\n                cpl::down_cast\u003cGTiffDataset *\u003e(poSrcDS)-\u003ePushMetadataToPam();\n            else\n                bRet = false;\n        }\n\n        CPLDestroyXMLNode( psRoot );\n\n        return bRet;\n    }\n\n    // If we have no more metadata but it existed before,\n    // remove the GDAL_METADATA tag.\n    if( eProfile == GTiffProfile::GDALGEOTIFF )\n    {\n        char* pszText = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_GDAL_METADATA, \u0026pszText ) )\n        {\n            TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_METADATA );\n        }\n    }\n\n    return true;\n}\n\n/************************************************************************/\n/*                         PushMetadataToPam()                          */\n/*                                                                      */\n/*      When producing a strict profile TIFF or if our aggregate        */\n/*      metadata is too big for a single tiff tag we may end up         */\n/*      needing to write it via the PAM mechanisms.  This method        */\n/*      copies all the appropriate metadata into the PAM level          */\n/*      metadata object but with special care to avoid copying          */\n/*      metadata handled in other ways in TIFF format.                  */\n/************************************************************************/\n\nvoid GTiffDataset::PushMetadataToPam()\n\n{\n    if( GetPamFlags() \u0026 GPF_DISABLED )\n        return;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(this, m_nPhotometric, m_papszCreationOptions);\n\n    for( int nBand = 0; nBand \u003c= GetRasterCount(); ++nBand )\n    {\n        GDALMultiDomainMetadata *poSrcMDMD = nullptr;\n        GTiffRasterBand *poBand = nullptr;\n\n        if( nBand == 0 )\n        {\n            poSrcMDMD = \u0026(this-\u003em_oGTiffMDMD);\n        }\n        else\n        {\n            poBand = cpl::down_cast\u003cGTiffRasterBand *\u003e(GetRasterBand(nBand));\n            poSrcMDMD = \u0026(poBand-\u003em_oGTiffMDMD);\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Loop over the available domains.                                */\n/* -------------------------------------------------------------------- */\n        char **papszDomainList = poSrcMDMD-\u003eGetDomainList();\n        for( int iDomain = 0;\n             papszDomainList \u0026\u0026 papszDomainList[iDomain];\n             ++iDomain )\n        {\n            char **papszMD = poSrcMDMD-\u003eGetMetadata( papszDomainList[iDomain] );\n\n            if( EQUAL(papszDomainList[iDomain],MD_DOMAIN_RPC)\n                || EQUAL(papszDomainList[iDomain],MD_DOMAIN_IMD)\n                || EQUAL(papszDomainList[iDomain],\"_temporary_\")\n                || EQUAL(papszDomainList[iDomain],\"IMAGE_STRUCTURE\")\n                || EQUAL(papszDomainList[iDomain],\"COLOR_PROFILE\") )\n                continue;\n\n            papszMD = CSLDuplicate(papszMD);\n\n            for( int i = CSLCount(papszMD)-1; i \u003e= 0; --i )\n            {\n                if( STARTS_WITH_CI(papszMD[i], \"TIFFTAG_\")\n                    || EQUALN(papszMD[i],GDALMD_AREA_OR_POINT,\n                              strlen(GDALMD_AREA_OR_POINT)) )\n                    papszMD = CSLRemoveStrings( papszMD, i, 1, nullptr );\n            }\n\n            if( nBand == 0 )\n                GDALPamDataset::SetMetadata( papszMD, papszDomainList[iDomain]);\n            else\n                poBand-\u003e\n                    GDALPamRasterBand::SetMetadata( papszMD,\n                                                    papszDomainList[iDomain]);\n\n            CSLDestroy( papszMD );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Handle some \"special domain\" stuff.                             */\n/* -------------------------------------------------------------------- */\n        if( poBand != nullptr )\n        {\n            poBand-\u003eGDALPamRasterBand::SetOffset( poBand-\u003eGetOffset() );\n            poBand-\u003eGDALPamRasterBand::SetScale( poBand-\u003eGetScale() );\n            poBand-\u003eGDALPamRasterBand::SetUnitType( poBand-\u003eGetUnitType() );\n            poBand-\u003e\n                GDALPamRasterBand::SetDescription( poBand-\u003eGetDescription() );\n            if( !bStardardColorInterp )\n            {\n                poBand-\u003eGDALPamRasterBand::SetColorInterpretation(\n                                        poBand-\u003eGetColorInterpretation() );\n            }\n        }\n    }\n    MarkPamDirty();\n}\n\n/************************************************************************/\n/*                     GTiffDatasetWriteRPCTag()                        */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nvoid GTiffDatasetWriteRPCTag( TIFF *hTIFF, char **papszRPCMD )\n\n{\n    GDALRPCInfo sRPC;\n\n    if( !GDALExtractRPCInfo( papszRPCMD, \u0026sRPC ) )\n        return;\n\n    double adfRPCTag[92] = {};\n    adfRPCTag[0] = -1.0;  // Error Bias\n    adfRPCTag[1] = -1.0;  // Error Random\n\n    adfRPCTag[2] = sRPC.dfLINE_OFF;\n    adfRPCTag[3] = sRPC.dfSAMP_OFF;\n    adfRPCTag[4] = sRPC.dfLAT_OFF;\n    adfRPCTag[5] = sRPC.dfLONG_OFF;\n    adfRPCTag[6] = sRPC.dfHEIGHT_OFF;\n    adfRPCTag[7] = sRPC.dfLINE_SCALE;\n    adfRPCTag[8] = sRPC.dfSAMP_SCALE;\n    adfRPCTag[9] = sRPC.dfLAT_SCALE;\n    adfRPCTag[10] = sRPC.dfLONG_SCALE;\n    adfRPCTag[11] = sRPC.dfHEIGHT_SCALE;\n\n    memcpy( adfRPCTag + 12, sRPC.adfLINE_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 32, sRPC.adfLINE_DEN_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 52, sRPC.adfSAMP_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 72, sRPC.adfSAMP_DEN_COEFF, sizeof(double) * 20 );\n\n    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, adfRPCTag );\n}\n\n/************************************************************************/\n/*                             ReadRPCTag()                             */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nchar** GTiffDatasetReadRPCTag(TIFF* hTIFF)\n\n{\n    double *padfRPCTag = nullptr;\n    uint16 nCount;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, \u0026nCount, \u0026padfRPCTag )\n        || nCount != 92 )\n        return nullptr;\n\n    CPLStringList asMD;\n    asMD.SetNameValue(RPC_LINE_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[2]));\n    asMD.SetNameValue(RPC_SAMP_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[3]));\n    asMD.SetNameValue(RPC_LAT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[4]));\n    asMD.SetNameValue(RPC_LONG_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[5]));\n    asMD.SetNameValue(RPC_HEIGHT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[6]));\n    asMD.SetNameValue(RPC_LINE_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[7]));\n    asMD.SetNameValue(RPC_SAMP_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[8]));\n    asMD.SetNameValue(RPC_LAT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[9]));\n    asMD.SetNameValue(RPC_LONG_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[10]));\n    asMD.SetNameValue(RPC_HEIGHT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[11]));\n\n    CPLString osField;\n    CPLString osMultiField;\n\n    for( int i = 0; i \u003c 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[12+i] );\n        if( i \u003e 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue(RPC_LINE_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i \u003c 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[32+i] );\n        if( i \u003e 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_LINE_DEN_COEFF, osMultiField );\n\n    for( int i = 0; i \u003c 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[52+i] );\n        if( i \u003e 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i \u003c 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[72+i] );\n        if( i \u003e 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_DEN_COEFF, osMultiField );\n\n    return asMD.StealList();\n}\n\n/************************************************************************/\n/*                  GTiffFormatGDALNoDataTagValue()                     */\n/************************************************************************/\n\nCPLString GTiffFormatGDALNoDataTagValue( double dfNoData )\n{\n    CPLString osVal;\n    if( CPLIsNan(dfNoData) )\n        osVal = \"nan\";\n    else\n        osVal.Printf(\"%.18g\", dfNoData);\n    return osVal;\n}\n\n/************************************************************************/\n/*                         WriteNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::WriteNoDataValue( TIFF *l_hTIFF, double dfNoData )\n\n{\n    CPLString osVal( GTiffFormatGDALNoDataTagValue(dfNoData) );\n    TIFFSetField( l_hTIFF, TIFFTAG_GDAL_NODATA, osVal.c_str() );\n}\n\n/************************************************************************/\n/*                         UnsetNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::UnsetNoDataValue( TIFF *l_hTIFF )\n\n{\n    TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_NODATA );\n}\n\n/************************************************************************/\n/*                            SetDirectory()                            */\n/************************************************************************/\n\nbool GTiffDataset::SetDirectory()\n\n{\n    Crystalize();\n\n    if( TIFFCurrentDirOffset(m_hTIFF) == m_nDirOffset )\n    {\n        return true;\n    }\n\n    const int nSetDirResult = TIFFSetSubDirectory( m_hTIFF, m_nDirOffset );\n    if( !nSetDirResult )\n        return false;\n\n    RestoreVolatileParameters( m_hTIFF );\n\n    return true;\n}\n\n/************************************************************************/\n/*                     GTiffSetDeflateSubCodec()                        */\n/************************************************************************/\n\nstatic void GTiffSetDeflateSubCodec(TIFF* hTIFF)\n{\n    (void)hTIFF;\n\n#if defined(TIFFTAG_DEFLATE_SUBCODEC) \u0026\u0026 defined(LIBDEFLATE_SUPPORT)\n    // Mostly for strict reproducibility purposes\n    if( EQUAL(CPLGetConfigOption(\"GDAL_TIFF_DEFLATE_SUBCODEC\", \"\"), \"ZLIB\") )\n    {\n        TIFFSetField(hTIFF, TIFFTAG_DEFLATE_SUBCODEC,\n                     DEFLATE_SUBCODEC_ZLIB);\n    }\n#endif\n}\n\n/************************************************************************/\n/*                     RestoreVolatileParameters()                      */\n/************************************************************************/\n\nvoid GTiffDataset::RestoreVolatileParameters(TIFF* hTIFF)\n{\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( m_nCompression == COMPRESSION_JPEG\n        \u0026\u0026 m_nPhotometric == PHOTOMETRIC_YCBCR\n        \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode = JPEGCOLORMODE_RAW;  // Initialize to 0;\n\n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, \u0026nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_LERC )\n    {\n        GTiffSetDeflateSubCodec(hTIFF);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propagate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality.\n        if(m_nJpegQuality \u003e 0 \u0026\u0026 m_nCompression == COMPRESSION_JPEG)\n        {\n#ifdef DEBUG_VERBOSE\n            CPLDebug( \"GTiff\", \"Propagate JPEG_QUALITY(%d) in SetDirectory()\",\n                      m_nJpegQuality );\n#endif\n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, m_nJpegQuality);\n        }\n        if(m_nJpegTablesMode \u003e= 0 \u0026\u0026 m_nCompression == COMPRESSION_JPEG)\n            TIFFSetField(hTIFF, TIFFTAG_JPEGTABLESMODE, m_nJpegTablesMode);\n        if(m_nZLevel \u003e 0 \u0026\u0026 (m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                           m_nCompression == COMPRESSION_LERC) )\n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, m_nZLevel);\n        if(m_nLZMAPreset \u003e 0 \u0026\u0026 m_nCompression == COMPRESSION_LZMA)\n            TIFFSetField(hTIFF, TIFFTAG_LZMAPRESET, m_nLZMAPreset);\n        if( m_nZSTDLevel \u003e 0 \u0026\u0026 (m_nCompression == COMPRESSION_ZSTD ||\n                               m_nCompression == COMPRESSION_LERC) )\n            TIFFSetField(hTIFF, TIFFTAG_ZSTD_LEVEL, m_nZSTDLevel);\n#if HAVE_LERC\n        if( m_nCompression == COMPRESSION_LERC )\n        {\n            TIFFSetField(hTIFF, TIFFTAG_LERC_MAXZERROR, m_dfMaxZError);\n        }\n#endif\n        if( m_nWebPLevel \u003e 0 \u0026\u0026 m_nCompression == COMPRESSION_WEBP)\n            TIFFSetField(hTIFF, TIFFTAG_WEBP_LEVEL, m_nWebPLevel);\n        if( m_bWebPLossless \u0026\u0026 m_nCompression == COMPRESSION_WEBP)\n            TIFFSetField(hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n    }\n}\n\n/************************************************************************/\n/*                              Identify()                              */\n/************************************************************************/\n\nint GTiffDataset::Identify( GDALOpenInfo *poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo-\u003epszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        pszFilename += strlen(\"GTIFF_RAW:\");\n        GDALOpenInfo oOpenInfo( pszFilename, poOpenInfo-\u003eeAccess );\n        return Identify(\u0026oOpenInfo);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      First we check to see if the file has the expected header       */\n/*      bytes.                                                          */\n/* -------------------------------------------------------------------- */\n    if( poOpenInfo-\u003efpL == nullptr || poOpenInfo-\u003enHeaderBytes \u003c 2 )\n        return FALSE;\n\n    if( (poOpenInfo-\u003epabyHeader[0] != 'I' || poOpenInfo-\u003epabyHeader[1] != 'I')\n        \u0026\u0026 (poOpenInfo-\u003epabyHeader[0] != 'M'\n        || poOpenInfo-\u003epabyHeader[1] != 'M'))\n        return FALSE;\n\n    if( (poOpenInfo-\u003epabyHeader[2] != 0x2A || poOpenInfo-\u003epabyHeader[3] != 0)\n        \u0026\u0026 (poOpenInfo-\u003epabyHeader[3] != 0x2A || poOpenInfo-\u003epabyHeader[2] != 0)\n        \u0026\u0026 (poOpenInfo-\u003epabyHeader[2] != 0x2B || poOpenInfo-\u003epabyHeader[3] != 0)\n        \u0026\u0026 (poOpenInfo-\u003epabyHeader[3] != 0x2B ||\n            poOpenInfo-\u003epabyHeader[2] != 0))\n        return FALSE;\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                          GTIFFExtendMemoryFile()                     */\n/************************************************************************/\n\nstatic bool GTIFFExtendMemoryFile( const CPLString\u0026 osTmpFilename,\n                                   VSILFILE* fpTemp,\n                                   VSILFILE* fpL,\n                                   int nNewLength,\n                                   GByte*\u0026 pabyBuffer,\n                                   vsi_l_offset\u0026 nDataLength )\n{\n    if( nNewLength \u003c= static_cast\u003cint\u003e(nDataLength) )\n        return true;\n    if( VSIFSeekL(fpTemp, nNewLength - 1, SEEK_SET) != 0 )\n        return false;\n    char ch = 0;\n    if( VSIFWriteL(\u0026ch, 1, 1, fpTemp) != 1 )\n        return false;\n    const int nOldDataLength = static_cast\u003cint\u003e(nDataLength);\n    pabyBuffer = static_cast\u003cGByte*\u003e(\n        VSIGetMemFileBuffer( osTmpFilename, \u0026nDataLength, FALSE) );\n    const int nToRead = nNewLength - nOldDataLength;\n    const int nRead = static_cast\u003cint\u003e(\n        VSIFReadL( pabyBuffer + nOldDataLength, 1, nToRead, fpL) );\n    if( nRead != nToRead )\n    {\n        CPLError(CE_Failure, CPLE_FileIO,\n                 \"Needed to read %d bytes. Only %d got\", nToRead, nRead);\n        return false;\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                         GTIFFMakeBufferedStream()                    */\n/************************************************************************/\n\nstatic bool GTIFFMakeBufferedStream(GDALOpenInfo* poOpenInfo)\n{\n    CPLString osTmpFilename;\n    static int nCounter = 0;\n    osTmpFilename.Printf(\"/vsimem/stream_%d.tif\", ++nCounter);\n    VSILFILE* fpTemp = VSIFOpenL(osTmpFilename, \"wb+\");\n    if( fpTemp == nullptr )\n        return false;\n    // The seek is needed for /vsistdin/ that has some rewind capabilities.\n    if( VSIFSeekL(poOpenInfo-\u003efpL, poOpenInfo-\u003enHeaderBytes, SEEK_SET) != 0 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    CPLAssert( static_cast\u003cint\u003e( VSIFTellL(poOpenInfo-\u003efpL) ) ==\n               poOpenInfo-\u003enHeaderBytes );\n    if( VSIFWriteL(poOpenInfo-\u003epabyHeader, poOpenInfo-\u003enHeaderBytes,\n                   1, fpTemp) != 1 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    vsi_l_offset nDataLength = 0;\n    GByte* pabyBuffer =\n        static_cast\u003cGByte*\u003e(\n            VSIGetMemFileBuffer( osTmpFilename, \u0026nDataLength, FALSE) );\n    const bool bLittleEndian = (pabyBuffer[0] == 'I');\n#if CPL_IS_LSB\n    const bool bSwap = !bLittleEndian;\n#else\n    const bool bSwap = bLittleEndian;\n#endif\n    const bool bBigTIFF = pabyBuffer[2] == 43 || pabyBuffer[3] == 43;\n    vsi_l_offset nMaxOffset = 0;\n    if( bBigTIFF )\n    {\n        GUInt64 nTmp = 0;\n        memcpy(\u0026nTmp, pabyBuffer + 8, 8);\n        if( bSwap ) CPL_SWAP64PTR(\u0026nTmp);\n        if( nTmp != 16 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 16 for a streamed BigTIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        memcpy(\u0026nTmp, pabyBuffer + 16, 8);\n        if( bSwap ) CPL_SWAP64PTR(\u0026nTmp);\n        if( nTmp \u003e 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : \" CPL_FRMT_GIB, nTmp);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = static_cast\u003cint\u003e(nTmp);\n        const int nSpaceForTags = nTags * 20;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo-\u003efpL,\n                                    24 + nSpaceForTags,\n                                    pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 24 + nSpaceForTags + 8;\n        for( int i = 0; i \u003c nTags; ++i )\n        {\n            GUInt16 nTmp16 = 0;\n            memcpy(\u0026nTmp16, pabyBuffer + 24 + i * 20, 2);\n            if( bSwap ) CPL_SWAP16PTR(\u0026nTmp16);\n            const int nTag = nTmp16;\n            memcpy(\u0026nTmp16, pabyBuffer + 24 + i * 20 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(\u0026nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(\u0026nTmp, pabyBuffer + 24 + i * 20 + 4, 8);\n            if( bSwap ) CPL_SWAP64PTR(\u0026nTmp);\n            if( nTmp \u003e= 16 * 1024 * 1024 )\n            {\n                CPLError(\n                    CE_Failure, CPLE_NotSupported,\n                    \"Too many elements for tag %d : \" CPL_FRMT_GUIB,\n                    nTag, nTmp );\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = static_cast\u003cGUInt32\u003e(nTmp);\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast\u003cTIFFDataType\u003e(nDataType)) * nCount;\n            if( nTagSize \u003e 8 )\n            {\n                memcpy(\u0026nTmp, pabyBuffer + 24 + i * 20 + 12, 8);\n                if( bSwap ) CPL_SWAP64PTR(\u0026nTmp);\n                if( nTmp \u003e GUINT64_MAX - nTagSize )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( static_cast\u003cvsi_l_offset\u003e(nTmp + nTagSize) \u003e nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    else\n    {\n        GUInt32 nTmp = 0;\n        memcpy(\u0026nTmp, pabyBuffer + 4, 4);\n        if( bSwap ) CPL_SWAP32PTR(\u0026nTmp);\n        if( nTmp != 8 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 8 for a streamed TIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        GUInt16 nTmp16 = 0;\n        memcpy(\u0026nTmp16, pabyBuffer + 8, 2);\n        if( bSwap ) CPL_SWAP16PTR(\u0026nTmp16);\n        if( nTmp16 \u003e 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : %d\", nTmp16);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = nTmp16;\n        const int nSpaceForTags = nTags * 12;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo-\u003efpL,\n                                   10 + nSpaceForTags,\n                                   pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 10 + nSpaceForTags + 4;\n        for( int i = 0; i \u003c nTags; ++i )\n        {\n            memcpy(\u0026nTmp16, pabyBuffer + 10 + i * 12, 2);\n            if( bSwap ) CPL_SWAP16PTR(\u0026nTmp16);\n            const int nTag = nTmp16;\n            memcpy(\u0026nTmp16, pabyBuffer + 10 + i * 12 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(\u0026nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(\u0026nTmp, pabyBuffer + 10 + i * 12 + 4, 4);\n            if( bSwap ) CPL_SWAP32PTR(\u0026nTmp);\n            if( nTmp \u003e= 16 * 1024 * 1024 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Too many elements for tag %d : %u\", nTag, nTmp);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = nTmp;\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast\u003cTIFFDataType\u003e(nDataType)) * nCount;\n            if( nTagSize \u003e 4 )\n            {\n                memcpy(\u0026nTmp, pabyBuffer + 10 + i * 12 + 8, 4);\n                if( bSwap ) CPL_SWAP32PTR(\u0026nTmp);\n                if( nTmp \u003e static_cast\u003cGUInt32\u003e(UINT_MAX - nTagSize) )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( nTmp + nTagSize \u003e nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    if( nMaxOffset \u003e 10 * 1024 * 1024 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    if( !GTIFFExtendMemoryFile(\n           osTmpFilename, fpTemp, poOpenInfo-\u003efpL,\n           static_cast\u003cint\u003e(nMaxOffset), pabyBuffer, nDataLength) )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    CPLAssert(nDataLength == VSIFTellL(poOpenInfo-\u003efpL));\n    poOpenInfo-\u003efpL = reinterpret_cast\u003cVSILFILE *\u003e(\n        VSICreateBufferedReaderHandle(\n            reinterpret_cast\u003cVSIVirtualHandle*\u003e(poOpenInfo-\u003efpL),\n            pabyBuffer,\n            static_cast\u003cvsi_l_offset\u003e(INT_MAX) \u003c\u003c 32 ) );\n    if( VSIFCloseL(fpTemp) != 0 )\n        return false;\n    VSIUnlink(osTmpFilename);\n\n    return true;\n}\n\n/************************************************************************/\n/*                       AssociateExternalMask()                        */\n/************************************************************************/\n\n// Used by GTIFFBuildOverviewsEx() for the COG driver\nbool GTiffDataset::AssociateExternalMask()\n{\n    if( m_poMaskExtOvrDS-\u003eGetRasterBand(1)-\u003eGetOverviewCount() !=\n        GetRasterBand(1)-\u003eGetOverviewCount() )\n        return false;\n    if( m_papoOverviewDS == nullptr )\n        return false;\n    if( m_poMaskDS )\n        return false;\n    if( m_poMaskExtOvrDS-\u003eGetRasterXSize() != nRasterXSize ||\n        m_poMaskExtOvrDS-\u003eGetRasterYSize() != nRasterYSize )\n        return false;\n    m_poExternalMaskDS = m_poMaskExtOvrDS.get();\n    for(int i = 0; i \u003c m_nOverviewCount; i++ )\n    {\n        if( m_papoOverviewDS[i]-\u003em_poMaskDS )\n            return false;\n        m_papoOverviewDS[i]-\u003em_poExternalMaskDS =\n            m_poMaskExtOvrDS-\u003eGetRasterBand(1)-\u003eGetOverview(i)-\u003eGetDataset();\n        if( !m_papoOverviewDS[i]-\u003em_poExternalMaskDS)\n            return false;\n        auto poOvrBand = m_papoOverviewDS[i]-\u003eGetRasterBand(1);\n        if( m_papoOverviewDS[i]-\u003em_poExternalMaskDS-\u003eGetRasterXSize() !=\n                poOvrBand-\u003eGetXSize() ||\n            m_papoOverviewDS[i]-\u003em_poExternalMaskDS-\u003eGetRasterYSize() !=\n                poOvrBand-\u003eGetYSize() )\n            return false;\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                                Open()                                */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Open( GDALOpenInfo * poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo-\u003epszFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Check if it looks like a TIFF file.                             */\n/* -------------------------------------------------------------------- */\n    if( !Identify(poOpenInfo) )\n        return nullptr;\n\n    bool bAllowRGBAInterface = true;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return OpenDir( poOpenInfo );\n\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    // Disable strip chop for now.\n    bool bStreaming = false;\n    const char* pszReadStreaming =\n        CPLGetConfigOption(\"TIFF_READ_STREAMING\", nullptr);\n    if( poOpenInfo-\u003efpL == nullptr )\n    {\n        poOpenInfo-\u003efpL =\n            VSIFOpenL( pszFilename,\n                       poOpenInfo-\u003eeAccess == GA_ReadOnly ? \"rb\" : \"r+b\" );\n        if( poOpenInfo-\u003efpL == nullptr )\n            return nullptr;\n    }\n    else if( !(pszReadStreaming \u0026\u0026 !CPLTestBool(pszReadStreaming)) \u0026\u0026\n             poOpenInfo-\u003enHeaderBytes \u003e= 24 \u0026\u0026\n             // A pipe has no seeking capability, so its position is 0 despite\n             // having read bytes.\n             (static_cast\u003cint\u003e( VSIFTellL(poOpenInfo-\u003efpL) ) ==\n              poOpenInfo-\u003enHeaderBytes ||\n              strcmp(pszFilename, \"/vsistdin/\") == 0 ||\n              // STARTS_WITH(pszFilename, \"/vsicurl_streaming/\") ||\n              (pszReadStreaming \u0026\u0026 CPLTestBool(pszReadStreaming))) )\n    {\n        bStreaming = true;\n        if( !GTIFFMakeBufferedStream(poOpenInfo) )\n            return nullptr;\n    }\n\n    // Store errors/warnings and emit them later.\n    std::vector\u003cCPLErrorHandlerAccumulatorStruct\u003e aoErrors;\n    CPLInstallErrorHandlerAccumulator(aoErrors);\n    CPLSetCurrentErrorHandlerCatchDebug( FALSE );\n    const bool bDeferStrileLoading = CPLTestBool(\n        CPLGetConfigOption(\"GTIFF_USE_DEFER_STRILE_LOADING\", \"YES\"));\n    TIFF *l_hTIFF =\n        VSI_TIFFOpen( pszFilename,\n                      poOpenInfo-\u003eeAccess == GA_ReadOnly ?\n                        ((bStreaming || !bDeferStrileLoading) ? \"r\" : \"rDO\") :\n                        (!bDeferStrileLoading ? \"r+\" : \"r+D\"),\n                      poOpenInfo-\u003efpL );\n    CPLUninstallErrorHandlerAccumulator();\n\n    // Now emit errors and change their criticality if needed\n    // We only emit failures if we didn't manage to open the file.\n    // Otherwise it makes Python bindings unhappy (#5616).\n    for( size_t iError = 0; iError \u003c aoErrors.size(); ++iError )\n    {\n        ReportError( pszFilename,\n                  (l_hTIFF == nullptr \u0026\u0026 aoErrors[iError].type == CE_Failure) ?\n                  CE_Failure : CE_Warning,\n                  aoErrors[iError].no,\n                  \"%s\",\n                  aoErrors[iError].msg.c_str() );\n    }\n    aoErrors.resize(0);\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n    uint32 nXSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, \u0026nXSize );\n    uint32 nYSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGELENGTH, \u0026nYSize );\n\n    if( nXSize \u003e INT_MAX || nYSize \u003e INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(pszFilename, CE_Failure, CPLE_NotSupported,\n                    \"Too large image size: %u x %u\",\n                    nXSize, nYSize);\n        XTIFFClose( l_hTIFF );\n        return nullptr;\n    }\n\n    uint16 l_nCompression = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, \u0026(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS-\u003eSetDescription( pszFilename );\n    poDS-\u003em_pszFilename = CPLStrdup(pszFilename);\n    poDS-\u003em_fpL = poOpenInfo-\u003efpL;\n    poOpenInfo-\u003efpL = nullptr;\n    poDS-\u003em_bStreamingIn = bStreaming;\n    poDS-\u003em_nCompression = l_nCompression;\n\n    // Check structural metadata (for COG)\n    const int nOffsetOfStructuralMetadata =\n        poOpenInfo-\u003enHeaderBytes \u0026\u0026\n        ((poOpenInfo-\u003epabyHeader[2] == 0x2B ||\n         poOpenInfo-\u003epabyHeader[3] == 0x2B )) ? 16 : 8;\n    if( poOpenInfo-\u003enHeaderBytes \u003e nOffsetOfStructuralMetadata +\n            static_cast\u003cint\u003e(strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) \u0026\u0026\n        memcmp(poOpenInfo-\u003epabyHeader + nOffsetOfStructuralMetadata,\n               \"GDAL_STRUCTURAL_METADATA_SIZE=\",\n               strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) == 0 )\n    {\n        const char* pszStructuralMD = reinterpret_cast\u003cconst char*\u003e(\n            poOpenInfo-\u003epabyHeader + nOffsetOfStructuralMetadata);\n        poDS-\u003em_bLayoutIFDSBeforeData = strstr(pszStructuralMD,\n                            \"LAYOUT=IFDS_BEFORE_DATA\") != nullptr;\n        poDS-\u003em_bBlockOrderRowMajor = strstr(pszStructuralMD,\n                            \"BLOCK_ORDER=ROW_MAJOR\") != nullptr;\n        poDS-\u003em_bLeaderSizeAsUInt4 = strstr(pszStructuralMD,\n                            \"BLOCK_LEADER=SIZE_AS_UINT4\") != nullptr;\n        poDS-\u003em_bTrailerRepeatedLast4BytesRepeated = strstr(pszStructuralMD,\n                            \"BLOCK_TRAILER=LAST_4_BYTES_REPEATED\") != nullptr;\n        poDS-\u003em_bMaskInterleavedWithImagery = strstr(pszStructuralMD,\n                            \"MASK_INTERLEAVED_WITH_IMAGERY=YES\") != nullptr;\n        poDS-\u003em_bKnownIncompatibleEdition = strstr(pszStructuralMD,\n                            \"KNOWN_INCOMPATIBLE_EDITION=YES\") != nullptr;\n        if( poDS-\u003em_bKnownIncompatibleEdition )\n        {\n            poDS-\u003eReportError(CE_Warning, CPLE_AppDefined,\n                     \"This file used to have optimizations in its layout, \"\n                     \"but those have been, at least partly, invalidated by \"\n                     \"later changes\");\n        }\n        else if( poDS-\u003em_bLayoutIFDSBeforeData \u0026\u0026\n                 poDS-\u003em_bBlockOrderRowMajor \u0026\u0026\n                 poDS-\u003em_bLeaderSizeAsUInt4 \u0026\u0026\n                 poDS-\u003em_bTrailerRepeatedLast4BytesRepeated )\n        {\n            poDS-\u003em_oGTiffMDMD.SetMetadataItem(\"LAYOUT\", \"COG\", \"IMAGE_STRUCTURE\");\n        }\n    }\n\n    // In the case of GDAL_DISABLE_READDIR_ON_OPEN = NO / EMPTY_DIR\n    if( poOpenInfo-\u003eAreSiblingFilesLoaded() \u0026\u0026\n        CSLCount( poOpenInfo-\u003eGetSiblingFiles() ) \u003c= 1 )\n    {\n        poDS-\u003eoOvManager.TransferSiblingFiles( CSLDuplicate(\n                                            poOpenInfo-\u003eGetSiblingFiles() ) );\n        poDS-\u003em_bHasGotSiblingFiles = true;\n    }\n\n    if( poDS-\u003eOpenOffset( l_hTIFF,\n                          TIFFCurrentDirOffset(l_hTIFF),\n                          poOpenInfo-\u003eeAccess,\n                          bAllowRGBAInterface, true) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    // Do we want blocks that are set to zero and that haven't yet being\n    // allocated as tile/strip to remain implicit?\n    if( CPLFetchBool( poOpenInfo-\u003epapszOpenOptions, \"SPARSE_OK\", false ) )\n        poDS-\u003em_bWriteEmptyTiles = false;\n\n    if( poOpenInfo-\u003eeAccess == GA_Update )\n    {\n        poDS-\u003eInitCreationOrOpenOptions(poOpenInfo-\u003epapszOpenOptions);\n    }\n\n    poDS-\u003em_bLoadPam = true;\n    poDS-\u003em_bColorProfileMetadataChanged = false;\n    poDS-\u003em_bMetadataChanged = false;\n    poDS-\u003em_bGeoTIFFInfoChanged = false;\n    poDS-\u003em_bNoDataChanged = false;\n    poDS-\u003em_bForceUnsetGTOrGCPs = false;\n    poDS-\u003em_bForceUnsetProjection = false;\n\n    // Used by GTIFFBuildOverviewsEx() for the COG driver\n    const char* pszMaskOverviewDS = CSLFetchNameValue(poOpenInfo-\u003epapszOpenOptions,\n                                                      \"MASK_OVERVIEW_DATASET\");\n    if( pszMaskOverviewDS )\n    {\n        poDS-\u003em_poMaskExtOvrDS.reset(GDALDataset::Open(pszMaskOverviewDS,\n                                            GDAL_OF_RASTER | GDAL_OF_INTERNAL));\n        if( !poDS-\u003em_poMaskExtOvrDS || !poDS-\u003eAssociateExternalMask() )\n        {\n            CPLDebug(\"GTiff\",\n                     \"Association with external mask overview file failed\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Initialize info for external overviews.                         */\n/* -------------------------------------------------------------------- */\n    poDS-\u003eoOvManager.Initialize( poDS, pszFilename );\n    if( poOpenInfo-\u003eAreSiblingFilesLoaded() )\n        poDS-\u003eoOvManager.TransferSiblingFiles(\n            poOpenInfo-\u003eStealSiblingFiles() );\n\n    // For backward compatibility, in case GTIFF_POINT_GEO_IGNORE is defined\n    // load georeferencing right now so as to not require it to be defined\n    // at the GetGeoTransform() time.\n    if( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", nullptr) != nullptr )\n    {\n        poDS-\u003eLoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                      GTiffDatasetSetAreaOrPointMD()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetSetAreaOrPointMD( GTIF* hGTIF,\n                                          GDALMultiDomainMetadata\u0026 m_oGTiffMDMD )\n{\n    // Is this a pixel-is-point dataset?\n    unsigned short nRasterType = 0;\n\n    if( GDALGTIFKeyGetSHORT(hGTIF, GTRasterTypeGeoKey, \u0026nRasterType,\n                    0, 1 ) == 1 )\n    {\n        if( nRasterType == static_cast\u003cshort\u003e(RasterPixelIsPoint) )\n            m_oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_POINT);\n        else\n            m_oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_AREA);\n    }\n}\n\n/************************************************************************/\n/*                         LoadMDAreaOrPoint()                          */\n/************************************************************************/\n\n// This is a light version of LookForProjection(), which saves the\n// potential costly cost of GTIFGetOGISDefn(), since we just need to\n// access to a raw GeoTIFF key, and not build the full projection object.\n\nvoid GTiffDataset::LoadMDAreaOrPoint()\n{\n    if( m_bLookedForProjection || m_bLookedForMDAreaOrPoint ||\n        m_oGTiffMDMD.GetMetadataItem( GDALMD_AREA_OR_POINT ) != nullptr )\n        return;\n\n    m_bLookedForMDAreaOrPoint = true;\n\n    GTIF* hGTIF = GTiffDatasetGTIFNew(m_hTIFF);\n\n    if( !hGTIF )\n    {\n        ReportError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n        GTiffDatasetSetAreaOrPointMD( hGTIF, m_oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         LookForProjection()                          */\n/************************************************************************/\n\nvoid GTiffDataset::LookForProjection()\n\n{\n    if( m_bLookedForProjection )\n        return;\n\n    m_bLookedForProjection = true;\n\n    IdentifyAuthorizedGeoreferencingSources();\n    if( m_nINTERNALGeorefSrcIndex \u003c 0 )\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the GeoTIFF projection, if available.                   */\n/* -------------------------------------------------------------------- */\n    m_oSRS.Clear();\n\n    GTIF *hGTIF = GTiffDatasetGTIFNew(m_hTIFF);\n\n    if( !hGTIF )\n    {\n        ReportError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n        GTIFDefn *psGTIFDefn = GTIFAllocDefn();\n\n        if( GTIFGetDefn( hGTIF, psGTIFDefn ) )\n        {\n            OGRSpatialReferenceH hSRS = GTIFGetOGISDefnAsOSR( hGTIF, psGTIFDefn );\n            if( hSRS )\n            {\n                m_oSRS = *(OGRSpatialReference::FromHandle(hSRS));\n                OSRDestroySpatialReference(hSRS);\n            }\n\n            if( m_oSRS.IsCompound() )\n            {\n                const char* pszVertUnit = nullptr;\n                m_oSRS.GetTargetLinearUnits(\"COMPD_CS|VERT_CS\", \u0026pszVertUnit);\n                if( pszVertUnit \u0026\u0026 !EQUAL(pszVertUnit, \"unknown\") )\n                {\n                    CPLFree(m_pszVertUnit);\n                    m_pszVertUnit = CPLStrdup(pszVertUnit);\n                }\n\n                int versions[3];\n                GTIFDirectoryInfo(hGTIF, versions, nullptr);\n\n                // If GeoTIFF 1.0, strip vertical by default\n                const char* pszDefaultReportCompdCS =\n                    ( versions[0] == 1 \u0026\u0026 versions[1]== 1 \u0026\u0026 versions[2] == 0 ) ? \"NO\" : \"YES\";\n\n                // Should we simplify away vertical CS stuff?\n                if( !CPLTestBool( CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\", \n                                            pszDefaultReportCompdCS) ) )\n                {\n                    CPLDebug( \"GTiff\", \"Got COMPD_CS, but stripping it.\" );\n\n                    m_oSRS.StripVertical();\n                }\n            }\n        }\n\n        // Check the tif linear unit and the CS linear unit.\n#ifdef ESRI_BUILD\n        AdjustLinearUnit(psGTIFDefn.UOMLength);\n#endif\n\n        GTIFFreeDefn(psGTIFDefn);\n\n        GTiffDatasetSetAreaOrPointMD( hGTIF, m_oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n\n    m_bGeoTIFFInfoChanged = false;\n    m_bForceUnsetGTOrGCPs = false;\n    m_bForceUnsetProjection = false;\n}\n\n/************************************************************************/\n/*                          AdjustLinearUnit()                          */\n/*                                                                      */\n/*      The following code is only used in ESRI Builds and there is     */\n/*      outstanding discussion on whether it is even appropriate        */\n/*      then.                                                           */\n/************************************************************************/\n#ifdef ESRI_BUILD\n\nvoid GTiffDataset::AdjustLinearUnit( short UOMLength )\n{\n    if( !pszProjection || strlen(pszProjection) == 0 )\n        return;\n    if( UOMLength == 9001 )\n    {\n        char* pstr = strstr(pszProjection, \"PARAMETER\");\n        if( !pstr )\n            return;\n        pstr = strstr(pstr, \"UNIT[\");\n        if( !pstr )\n            return;\n        pstr = strchr(pstr, ',') + 1;\n        if( !pstr )\n            return;\n        char* pstr1 = strchr(pstr, ']');\n        if( !pstr1 || pstr1 - pstr \u003e= 128 )\n            return;\n        char csUnitStr[128];\n        strncpy(csUnitStr, pstr, pstr1 - pstr);\n        csUnitStr[pstr1-pstr] = '\\0';\n        const double csUnit = CPLAtof(csUnitStr);\n        if( fabs(csUnit - 1.0) \u003e 0.000001 )\n        {\n            for( long i = 0; i \u003c 6; ++i )\n                adfGeoTransform[i] /= csUnit;\n        }\n    }\n}\n\n#endif  // def ESRI_BUILD\n\n/************************************************************************/\n/*                            ApplyPamInfo()                            */\n/*                                                                      */\n/*      PAM Information, if available, overrides the GeoTIFF            */\n/*      geotransform and projection definition.  Check for them         */\n/*      now.                                                            */\n/************************************************************************/\n\nvoid GTiffDataset::ApplyPamInfo()\n\n{\n    if( m_nPAMGeorefSrcIndex \u003e= 0 \u0026\u0026\n        ((m_bGeoTransformValid \u0026\u0026\n          m_nPAMGeorefSrcIndex \u003c m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex \u003c 0 || !m_bGeoTransformValid) )\n    {\n        double adfPamGeoTransform[6] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n        if( GDALPamDataset::GetGeoTransform( adfPamGeoTransform ) == CE_None )\n        {\n            if( m_nGeoTransformGeorefSrcIndex == m_nWORLDFILEGeorefSrcIndex )\n            {\n                CPLFree(m_pszGeorefFilename);\n                m_pszGeorefFilename = nullptr;\n            }\n            memcpy(m_adfGeoTransform, adfPamGeoTransform, sizeof(double) * 6);\n            m_bGeoTransformValid = true;\n        }\n    }\n\n    if( m_nPAMGeorefSrcIndex \u003e= 0 )\n    {\n        if( (m_nTABFILEGeorefSrcIndex \u003c 0 ||\n             m_nPAMGeorefSrcIndex \u003c m_nTABFILEGeorefSrcIndex) \u0026\u0026\n            (m_nINTERNALGeorefSrcIndex \u003c 0 ||\n             m_nPAMGeorefSrcIndex \u003c m_nINTERNALGeorefSrcIndex) )\n        {\n            const auto* poPamSRS = GDALPamDataset::GetSpatialRef();\n            if( poPamSRS )\n            {\n                m_oSRS = *poPamSRS;\n                m_bLookedForProjection = true;\n                // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n            }\n        }\n        else\n        {\n            if( m_nINTERNALGeorefSrcIndex \u003e= 0 )\n                LookForProjection();\n            if( m_oSRS.IsEmpty() )\n            {\n                const auto* poPamSRS = GDALPamDataset::GetSpatialRef();\n                if( poPamSRS )\n                {\n                    m_oSRS = *poPamSRS;\n                    m_bLookedForProjection = true;\n                    // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n                }\n            }\n        }\n    }\n\n    int nPamGCPCount;\n    if( m_nPAMGeorefSrcIndex \u003e= 0 \u0026\u0026\n        (nPamGCPCount = GDALPamDataset::GetGCPCount()) \u003e 0 \u0026\u0026\n        ( (m_nGCPCount \u003e 0 \u0026\u0026\n           m_nPAMGeorefSrcIndex \u003c m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex \u003c 0 || m_nGCPCount == 0 ) )\n    {\n        if( m_nGCPCount \u003e 0 )\n        {\n            GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n            CPLFree( m_pasGCPList );\n            m_pasGCPList = nullptr;\n        }\n\n        m_nGCPCount = nPamGCPCount;\n        m_pasGCPList = GDALDuplicateGCPs(m_nGCPCount, GDALPamDataset::GetGCPs());\n\n        // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n\n        const auto* poPamGCPSRS = GDALPamDataset::GetGCPSpatialRef();\n        if( poPamGCPSRS )\n            m_oSRS = *poPamGCPSRS;\n        else\n            m_oSRS.Clear();\n\n        m_bLookedForProjection = true;\n    }\n\n    if( m_nPAMGeorefSrcIndex \u003e= 0 )\n    {\n        CPLXMLNode *psValueAsXML = nullptr;\n        CPLXMLNode *psGeodataXform = nullptr;\n        char** papszXML = oMDMD.GetMetadata( \"xml:ESRI\" );\n        if (CSLCount(papszXML) == 1)\n        {\n            psValueAsXML = CPLParseXMLString( papszXML[0] );\n            if( psValueAsXML )\n                psGeodataXform = CPLGetXMLNode(psValueAsXML, \"=GeodataXform\");\n        }\n\n        const char* pszTIFFTagResUnit = GetMetadataItem(\"TIFFTAG_RESOLUTIONUNIT\");\n        const char* pszTIFFTagXRes = GetMetadataItem(\"TIFFTAG_XRESOLUTION\");\n        const char* pszTIFFTagYRes = GetMetadataItem(\"TIFFTAG_YRESOLUTION\");\n        if (psGeodataXform \u0026\u0026 pszTIFFTagResUnit \u0026\u0026pszTIFFTagXRes \u0026\u0026\n            pszTIFFTagYRes \u0026\u0026 atoi(pszTIFFTagResUnit) == 2 )\n        {\n            CPLXMLNode* psSourceGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"SourceGCPs\");\n            CPLXMLNode* psTargetGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"TargetGCPs\");\n            if( psSourceGCPs \u0026\u0026 psTargetGCPs )\n            {\n                std::vector\u003cdouble\u003e adfSourceGCPs, adfTargetGCPs;\n                for( CPLXMLNode* psIter = psSourceGCPs-\u003epsChild;\n                                    psIter != nullptr;\n                                    psIter = psIter-\u003epsNext )\n                {\n                    if( psIter-\u003eeType == CXT_Element \u0026\u0026\n                        EQUAL(psIter-\u003epszValue, \"Double\") )\n                    {\n                        adfSourceGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                for( CPLXMLNode* psIter = psTargetGCPs-\u003epsChild;\n                                    psIter != nullptr;\n                                    psIter = psIter-\u003epsNext )\n                {\n                    if( psIter-\u003eeType == CXT_Element \u0026\u0026\n                        EQUAL(psIter-\u003epszValue, \"Double\") )\n                    {\n                        adfTargetGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                if( adfSourceGCPs.size() == adfTargetGCPs.size() \u0026\u0026\n                    (adfSourceGCPs.size() % 2) == 0 )\n                {\n                    if( m_nGCPCount \u003e 0 )\n                    {\n                        GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n                        CPLFree( m_pasGCPList );\n                        m_pasGCPList = nullptr;\n                        m_nGCPCount = 0;\n                    }\n                    m_nGCPCount = static_cast\u003cint\u003e(\n                                            adfSourceGCPs.size() / 2);\n                    m_pasGCPList = static_cast\u003cGDAL_GCP *\u003e(\n                            CPLCalloc(sizeof(GDAL_GCP), m_nGCPCount) );\n                    for( int i = 0; i \u003c m_nGCPCount; ++i )\n                    {\n                        m_pasGCPList[i].pszId = CPLStrdup(\"\");\n                        m_pasGCPList[i].pszInfo = CPLStrdup(\"\");\n                        // The origin used is the bottom left corner,\n                        // and raw values are in inches!\n                        m_pasGCPList[i].dfGCPPixel = adfSourceGCPs[2*i] *\n                                                        CPLAtof(pszTIFFTagXRes);\n                        m_pasGCPList[i].dfGCPLine = nRasterYSize -\n                                adfSourceGCPs[2*i+1] * CPLAtof(pszTIFFTagYRes);\n                        m_pasGCPList[i].dfGCPX = adfTargetGCPs[2*i];\n                        m_pasGCPList[i].dfGCPY = adfTargetGCPs[2*i+1];\n                    }\n                }\n            }\n        }\n        if( psValueAsXML )\n            CPLDestroyXMLNode(psValueAsXML);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy any PAM metadata into our GeoTIFF context, and with        */\n/*      the PAM info overriding the GeoTIFF context.                    */\n/* -------------------------------------------------------------------- */\n    char **papszPamDomains = oMDMD.GetDomainList();\n\n    for( int iDomain = 0;\n         papszPamDomains \u0026\u0026 papszPamDomains[iDomain] != nullptr;\n         ++iDomain )\n    {\n        const char *pszDomain = papszPamDomains[iDomain];\n        char **papszGT_MD = CSLDuplicate(m_oGTiffMDMD.GetMetadata( pszDomain ));\n        char **papszPAM_MD = oMDMD.GetMetadata( pszDomain );\n\n        papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n        m_oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n        CSLDestroy( papszGT_MD );\n    }\n\n    for( int i = 1; i \u003c= GetRasterCount(); ++i )\n    {\n        GTiffRasterBand* poBand =\n            cpl::down_cast\u003cGTiffRasterBand *\u003e(GetRasterBand(i));\n        papszPamDomains = poBand-\u003eoMDMD.GetDomainList();\n\n        for( int iDomain = 0;\n             papszPamDomains \u0026\u0026 papszPamDomains[iDomain] != nullptr;\n             ++iDomain )\n        {\n            const char *pszDomain = papszPamDomains[iDomain];\n            char **papszGT_MD =\n                CSLDuplicate(poBand-\u003em_oGTiffMDMD.GetMetadata( pszDomain ));\n            char **papszPAM_MD = poBand-\u003eoMDMD.GetMetadata( pszDomain );\n\n            papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n            poBand-\u003em_oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n            CSLDestroy( papszGT_MD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                              OpenDir()                               */\n/*                                                                      */\n/*      Open a specific directory as encoded into a filename.           */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    bool bAllowRGBAInterface = true;\n    const char* pszFilename = poOpenInfo-\u003epszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") ||\n        pszFilename[strlen(\"GTIFF_DIR:\")] == '\\0' )\n    {\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    bool bAbsolute = false;\n\n    if( STARTS_WITH_CI(pszFilename, \"off:\") )\n    {\n        bAbsolute = true;\n        pszFilename += 4;\n    }\n\n    toff_t nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' \u0026\u0026 pszFilename[-1] != ':' )\n        ++pszFilename;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        ReportError(pszFilename, CE_Failure, CPLE_OpenFailed,\n            \"Unable to extract offset or filename, should take the form:\\n\"\n            \"GTIFF_DIR:\u003cdir\u003e:filename or GTIFF_DIR:off:\u003cdir_offset\u003e:filename\" );\n        return nullptr;\n    }\n\n    if( poOpenInfo-\u003eeAccess == GA_Update )\n    {\n        ReportError(\n            pszFilename, CE_Warning, CPLE_AppDefined,\n            \"Opening a specific TIFF directory is not supported in \"\n            \"update mode. Switching to read-only\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n    const char* pszFlag = poOpenInfo-\u003eeAccess == GA_Update ? \"r+D\" : \"rDO\";\n    VSILFILE* l_fpL = VSIFOpenL(pszFilename, pszFlag);\n    if( l_fpL == nullptr )\n        return nullptr;\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, pszFlag, l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        const toff_t nOffsetRequested = nOffset;\n        while( nOffset \u003e 1 )\n        {\n            if( TIFFReadDirectory( l_hTIFF ) == 0 )\n            {\n                XTIFFClose( l_hTIFF );\n                ReportError(\n                    pszFilename, CE_Failure, CPLE_OpenFailed,\n                    \"Requested directory %lu not found.\",\n                    static_cast\u003clong unsigned int\u003e(nOffsetRequested));\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS-\u003eSetDescription( poOpenInfo-\u003epszFilename );\n    poDS-\u003em_pszFilename = CPLStrdup(pszFilename);\n    poDS-\u003em_fpL = l_fpL;\n    poDS-\u003em_hTIFF = l_hTIFF;\n    poDS-\u003em_bSingleIFDOpened = true;\n\n    if( !EQUAL(pszFilename,poOpenInfo-\u003epszFilename)\n        \u0026\u0026 !STARTS_WITH_CI(poOpenInfo-\u003epszFilename, \"GTIFF_RAW:\") )\n    {\n        poDS-\u003eSetPhysicalFilename( pszFilename );\n        poDS-\u003eSetSubdatasetName( poOpenInfo-\u003epszFilename );\n    }\n\n    if( poOpenInfo-\u003eAreSiblingFilesLoaded() )\n        poDS-\u003eoOvManager.TransferSiblingFiles(\n            poOpenInfo-\u003eStealSiblingFiles() );\n\n    if( poDS-\u003eOpenOffset( l_hTIFF,\n                          nOffset, poOpenInfo-\u003eeAccess,\n                          bAllowRGBAInterface, true ) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                   ConvertTransferFunctionToString()                  */\n/*                                                                      */\n/*      Convert a transfer function table into a string.                */\n/*      Used by LoadICCProfile().                                       */\n/************************************************************************/\nstatic CPLString ConvertTransferFunctionToString( const uint16 *pTable,\n                                                  uint32 nTableEntries )\n{\n    CPLString sValue;\n\n    for( uint32 i = 0; i \u003c nTableEntries; ++i )\n    {\n        if( i == 0 )\n            sValue = sValue.Printf(\"%d\", static_cast\u003cuint32\u003e(pTable[i]));\n        else\n            sValue = sValue.Printf( \"%s, %d\",\n                                    sValue.c_str(),\n                                    static_cast\u003cuint32\u003e(pTable[i]));\n    }\n\n    return sValue;\n}\n\n/************************************************************************/\n/*                             LoadICCProfile()                         */\n/*                                                                      */\n/*      Load ICC Profile or colorimetric data into metadata             */\n/************************************************************************/\n\nvoid GTiffDataset::LoadICCProfile()\n{\n    if( m_bICCMetadataLoaded )\n        return;\n    m_bICCMetadataLoaded = true;\n\n    uint32 nEmbedLen = 0;\n    uint8* pEmbedBuffer = nullptr;\n\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_ICCPROFILE, \u0026nEmbedLen, \u0026pEmbedBuffer) )\n    {\n        char *pszBase64Profile =\n            CPLBase64Encode(nEmbedLen, reinterpret_cast\u003cconst GByte*\u003e(pEmbedBuffer));\n\n        m_oGTiffMDMD.SetMetadataItem( \"SOURCE_ICC_PROFILE\", pszBase64Profile,\n                                    \"COLOR_PROFILE\" );\n\n        CPLFree(pszBase64Profile);\n\n        return;\n    }\n\n    // Check for colorimetric tiff.\n    float* pCHR = nullptr;\n    float* pWP = nullptr;\n    uint16 *pTFR = nullptr;\n    uint16 *pTFG = nullptr;\n    uint16 *pTFB = nullptr;\n    uint16 *pTransferRange = nullptr;\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, \u0026pCHR) )\n    {\n        if( TIFFGetField(m_hTIFF, TIFFTAG_WHITEPOINT, \u0026pWP) )\n        {\n            if( !TIFFGetFieldDefaulted( m_hTIFF, TIFFTAG_TRANSFERFUNCTION, \u0026pTFR,\n                                        \u0026pTFG, \u0026pTFB) ||\n                pTFR == nullptr || pTFG == nullptr || pTFB == nullptr )\n            {\n                return;\n            }\n\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFGetFieldDefaulted( m_hTIFF, TIFFTAG_TRANSFERRANGE,\n                                   \u0026pTransferRange);\n\n            // Set all the colorimetric metadata.\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_RED\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast\u003cdouble\u003e(pCHR[0]),\n                                    static_cast\u003cdouble\u003e(pCHR[1]) ),\n                \"COLOR_PROFILE\" );\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_GREEN\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast\u003cdouble\u003e(pCHR[2]),\n                                    static_cast\u003cdouble\u003e(pCHR[3]) ),\n                \"COLOR_PROFILE\" );\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_BLUE\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast\u003cdouble\u003e(pCHR[4]),\n                                    static_cast\u003cdouble\u003e(pCHR[5]) ),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_WHITEPOINT\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast\u003cdouble\u003e(pWP[0]),\n                                    static_cast\u003cdouble\u003e(pWP[1]) ),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer function metadata.\n\n            // Get length of table.\n            const uint32 nTransferFunctionLength = 1 \u003c\u003c m_nBitsPerSample;\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                ConvertTransferFunctionToString( pTFR, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                ConvertTransferFunctionToString( pTFG, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                ConvertTransferFunctionToString( pTFB, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer range.\n            if( pTransferRange )\n            {\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_BLACK\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast\u003cint\u003e(pTransferRange[0]),\n                                        static_cast\u003cint\u003e(pTransferRange[2]),\n                                        static_cast\u003cint\u003e(pTransferRange[4])),\n                    \"COLOR_PROFILE\" );\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_WHITE\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast\u003cint\u003e(pTransferRange[1]),\n                                        static_cast\u003cint\u003e(pTransferRange[3]),\n                                        static_cast\u003cint\u003e(pTransferRange[5])),\n                    \"COLOR_PROFILE\" );\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                             SaveICCProfile()                         */\n/*                                                                      */\n/*      Save ICC Profile or colorimetric data into file                 */\n/* pDS:                                                                 */\n/*      Dataset that contains the metadata with the ICC or colorimetric */\n/*      data. If this argument is specified, all other arguments are    */\n/*      ignored. Set them to NULL or 0.                                 */\n/* hTIFF:                                                               */\n/*      Pointer to TIFF handle. Only needed if pDS is NULL or           */\n/*      pDS-\u003em_hTIFF is NULL.                                             */\n/* papszParmList:                                                       */\n/*      Options containing the ICC profile or colorimetric metadata.    */\n/*      Ignored if pDS is not NULL.                                     */\n/* nBitsPerSample:                                                      */\n/*      Bits per sample. Ignored if pDS is not NULL.                    */\n/************************************************************************/\n\nvoid GTiffDataset::SaveICCProfile( GTiffDataset *pDS, TIFF *l_hTIFF,\n                                   char **papszParmList,\n                                   uint32 l_nBitsPerSample )\n{\n    if( (pDS != nullptr) \u0026\u0026 (pDS-\u003eeAccess != GA_Update) )\n        return;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( pDS == nullptr )\n            return;\n\n        l_hTIFF = pDS-\u003em_hTIFF;\n        if( l_hTIFF == nullptr )\n            return;\n    }\n\n    if( (papszParmList == nullptr) \u0026\u0026 (pDS == nullptr) )\n        return;\n\n    const char *pszValue = nullptr;\n    if( pDS != nullptr )\n        pszValue = pDS-\u003eGetMetadataItem(\"SOURCE_ICC_PROFILE\", \"COLOR_PROFILE\");\n    else\n        pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_ICC_PROFILE\");\n    if( pszValue != nullptr )\n    {\n        char *pEmbedBuffer = CPLStrdup(pszValue);\n        int32 nEmbedLen =\n            CPLBase64DecodeInPlace(reinterpret_cast\u003cGByte *\u003e(pEmbedBuffer));\n\n        TIFFSetField(l_hTIFF, TIFFTAG_ICCPROFILE, nEmbedLen, pEmbedBuffer);\n\n        CPLFree(pEmbedBuffer);\n    }\n    else\n    {\n        // Output colorimetric data.\n        float pCHR[6] = {};  // Primaries.\n        uint16 pTXR[6] = {};  // Transfer range.\n        const char* pszCHRNames[] = {\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\"\n        };\n        const char* pszTXRNames[] = {\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\"\n        };\n\n        // Output chromacities.\n        bool bOutputCHR = true;\n        for( int i = 0; i \u003c 3 \u0026\u0026 bOutputCHR; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue =\n                    pDS-\u003eGetMetadataItem(pszCHRNames[i], \"COLOR_PROFILE\");\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszCHRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputCHR = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputCHR = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j \u003c 3; ++j )\n            {\n                float v = static_cast\u003cfloat\u003e(CPLAtof(papszTokens[j]));\n\n                if( j == 2 )\n                {\n                    // Last term of xyY color must be 1.0.\n                    if( v != 1.0 )\n                    {\n                        bOutputCHR = false;\n                        break;\n                    }\n                }\n                else\n                {\n                    pCHR[i * 2 + j] = v;\n                }\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputCHR )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, pCHR);\n        }\n\n        // Output whitepoint.\n        if( pDS != nullptr )\n            pszValue =\n                pDS-\u003eGetMetadataItem(\"SOURCE_WHITEPOINT\", \"COLOR_PROFILE\");\n        else\n            pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_WHITEPOINT\");\n        if( pszValue != nullptr )\n        {\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            bool bOutputWhitepoint = true;\n            float pWP[2] = { 0.0f, 0.0f };  // Whitepoint\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputWhitepoint = false;\n            }\n            else\n            {\n                for( int j = 0; j \u003c 3; ++j )\n                {\n                    const float v = static_cast\u003cfloat\u003e(CPLAtof(papszTokens[j]));\n\n                    if( j == 2 )\n                    {\n                        // Last term of xyY color must be 1.0.\n                        if( v != 1.0 )\n                        {\n                            bOutputWhitepoint = false;\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        pWP[j] = v;\n                    }\n                }\n            }\n            CSLDestroy( papszTokens );\n\n            if( bOutputWhitepoint )\n            {\n                TIFFSetField(l_hTIFF, TIFFTAG_WHITEPOINT, pWP);\n            }\n        }\n\n        // Set transfer function metadata.\n        char const *pszTFRed = nullptr;\n        if( pDS != nullptr )\n            pszTFRed =\n                pDS-\u003eGetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFRed =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_RED\" );\n\n        char const *pszTFGreen = nullptr;\n        if( pDS != nullptr )\n            pszTFGreen =\n                pDS-\u003eGetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFGreen =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_GREEN\" );\n\n        char const *pszTFBlue = nullptr;\n        if( pDS != nullptr )\n            pszTFBlue =\n                pDS-\u003eGetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFBlue =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_BLUE\" );\n\n        if( (pszTFRed != nullptr) \u0026\u0026 (pszTFGreen != nullptr) \u0026\u0026 (pszTFBlue != nullptr) )\n        {\n            // Get length of table.\n            const int nTransferFunctionLength =\n                1 \u003c\u003c ((pDS!=nullptr)?pDS-\u003em_nBitsPerSample:l_nBitsPerSample);\n\n            char** papszTokensRed =\n                CSLTokenizeString2(\n                    pszTFRed, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensGreen =\n                CSLTokenizeString2(\n                    pszTFGreen, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensBlue =\n                CSLTokenizeString2(\n                    pszTFBlue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( (CSLCount( papszTokensRed ) == nTransferFunctionLength) \u0026\u0026\n                (CSLCount( papszTokensGreen ) == nTransferFunctionLength) \u0026\u0026\n                (CSLCount( papszTokensBlue ) == nTransferFunctionLength) )\n            {\n                uint16 *pTransferFuncRed =\n                    static_cast\u003cuint16*\u003e( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncGreen =\n                    static_cast\u003cuint16*\u003e( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncBlue =\n                    static_cast\u003cuint16*\u003e( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n\n                // Convert our table in string format into int16 format.\n                for( int i = 0; i \u003c nTransferFunctionLength; ++i )\n                {\n                    pTransferFuncRed[i] =\n                        static_cast\u003cuint16\u003e(atoi(papszTokensRed[i]));\n                    pTransferFuncGreen[i] =\n                        static_cast\u003cuint16\u003e(atoi(papszTokensGreen[i]));\n                    pTransferFuncBlue[i] =\n                        static_cast\u003cuint16\u003e(atoi(papszTokensBlue[i]));\n                }\n\n                TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERFUNCTION,\n                    pTransferFuncRed, pTransferFuncGreen, pTransferFuncBlue);\n\n                CPLFree(pTransferFuncRed);\n                CPLFree(pTransferFuncGreen);\n                CPLFree(pTransferFuncBlue);\n            }\n\n            CSLDestroy( papszTokensRed );\n            CSLDestroy( papszTokensGreen );\n            CSLDestroy( papszTokensBlue );\n        }\n\n        // Output transfer range.\n        bool bOutputTransferRange = true;\n        for( int i = 0; (i \u003c 2) \u0026\u0026 bOutputTransferRange; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue = pDS-\u003eGetMetadataItem( pszTXRNames[i],\n                                                 \"COLOR_PROFILE\" );\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszTXRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputTransferRange = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputTransferRange = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j \u003c 3; ++j )\n            {\n                pTXR[i + j * 2] = static_cast\u003cuint16\u003e(atoi(papszTokens[j]));\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputTransferRange )\n        {\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERRANGE, pTXR);\n        }\n    }\n}\n\n/************************************************************************/\n/*                             OpenOffset()                             */\n/*                                                                      */\n/*      Initialize the GTiffDataset based on a passed in file           */\n/*      handle, and directory offset to utilize.  This is called for    */\n/*      full res, and overview pages.                                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn,\n                                 toff_t nDirOffsetIn,\n                                 GDALAccess eAccessIn,\n                                 bool bAllowRGBAInterface,\n                                 bool bReadGeoTransform )\n\n{\n    if( !hTIFFIn )\n        return CE_Failure;\n\n    eAccess = eAccessIn;\n\n    m_hTIFF = hTIFFIn;\n\n    m_nDirOffset = nDirOffsetIn;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( m_hTIFF, TIFFTAG_IMAGEWIDTH, \u0026nXSize );\n    TIFFGetField( m_hTIFF, TIFFTAG_IMAGELENGTH, \u0026nYSize );\n    if( nXSize \u003e INT_MAX || nYSize \u003e INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        return CE_Failure;\n    }\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, \u0026m_nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = m_nSamplesPerPixel;\n\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, \u0026(m_nBitsPerSample)) )\n        m_nBitsPerSample = 1;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_PLANARCONFIG, \u0026(m_nPlanarConfig) ) )\n        m_nPlanarConfig = PLANARCONFIG_CONTIG;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_PHOTOMETRIC, \u0026(m_nPhotometric) ) )\n        m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_SAMPLEFORMAT, \u0026(m_nSampleFormat) ) )\n        m_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_COMPRESSION, \u0026(m_nCompression) ) )\n        m_nCompression = COMPRESSION_NONE;\n\n    if( m_nCompression != COMPRESSION_NONE \u0026\u0026\n        !TIFFIsCODECConfigured(m_nCompression) )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( m_nCompression == COMPRESSION_JPEG\n        \u0026\u0026 m_nPhotometric == PHOTOMETRIC_YCBCR\n        \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\",\n                                    \"IMAGE_STRUCTURE\" );\n        int nColorMode = 0;\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_JPEGCOLORMODE, \u0026nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(m_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(m_hTIFF) )\n    {\n        uint32 l_nBlockXSize = 0;\n        uint32 l_nBlockYSize = 0;\n        TIFFGetField( m_hTIFF, TIFFTAG_TILEWIDTH, \u0026(l_nBlockXSize) );\n        TIFFGetField( m_hTIFF, TIFFTAG_TILELENGTH, \u0026(l_nBlockYSize) );\n        if( l_nBlockXSize \u003e INT_MAX || l_nBlockYSize \u003e INT_MAX )\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                     \"Too large block size: %u x %u\",\n                     l_nBlockXSize, l_nBlockYSize);\n            return CE_Failure;\n        }\n        m_nBlockXSize = static_cast\u003cint\u003e(l_nBlockXSize);\n        m_nBlockYSize = static_cast\u003cint\u003e(l_nBlockYSize);\n    }\n    else\n    {\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           \u0026(m_nRowsPerStrip) ) )\n        {\n            ReportError( CE_Warning, CPLE_AppDefined,\n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            m_nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if( m_nRowsPerStrip \u003e static_cast\u003cuint32\u003e(nRasterYSize) )\n            m_nRowsPerStrip = nRasterYSize;\n\n        m_nBlockXSize = nRasterXSize;\n        m_nBlockYSize = m_nRowsPerStrip;\n    }\n\n    const int l_nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, m_nBlockYSize);\n    const int l_nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n    if( l_nBlocksPerColumn \u003e INT_MAX / l_nBlocksPerRow )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn );\n        return CE_Failure;\n    }\n\n    // Note: we could potentially go up to UINT_MAX blocks, but currently\n    // we use a int nBlockId\n    m_nBlocksPerBand = l_nBlocksPerColumn * l_nBlocksPerRow;\n    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE \u0026\u0026\n        m_nBlocksPerBand \u003e INT_MAX / nBands )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d x %d bands\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn, nBands );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsBitmap = false;\n\n    if( m_nBitsPerSample == 1 \u0026\u0026 nBands == 1 )\n    {\n        bTreatAsBitmap = true;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(m_hTIFF)\n            \u0026\u0026 m_nBlockYSize == nRasterYSize\n            \u0026\u0026 nRasterYSize \u003e 2000\n            // libtiff does not support reading JBIG files with\n            // TIFFReadScanline().\n            \u0026\u0026 m_nCompression != COMPRESSION_JBIG )\n        {\n            m_bTreatAsSplitBitmap = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsRGBA = false;\n    if(\n#ifdef DEBUG\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_FORCE_RGBA\", \"NO\")) ||\n#endif\n        (bAllowRGBAInterface \u0026\u0026\n        !bTreatAsBitmap \u0026\u0026 !(m_nBitsPerSample \u003e 8)\n        \u0026\u0026 (m_nPhotometric == PHOTOMETRIC_CIELAB ||\n            m_nPhotometric == PHOTOMETRIC_LOGL ||\n            m_nPhotometric == PHOTOMETRIC_LOGLUV ||\n            m_nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( m_nPhotometric == PHOTOMETRIC_YCBCR\n              \u0026\u0026 m_nCompression != COMPRESSION_JPEG ))) )\n    {\n        char szMessage[1024] = {};\n\n        if( TIFFRGBAImageOK( m_hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = nullptr;\n            nBands = 4;\n            switch( m_nPhotometric )\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    nBands = 3; // probably true for other photometric values\n                    break;\n            }\n            if( pszSourceColorSpace )\n                m_oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\",\n                                            pszSourceColorSpace,\n                                            \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = true;\n\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n\n    // libtiff has various issues with OJPEG compression and chunky-strip\n    // support with the \"classic\" scanline/strip/tile interfaces, and that\n    // wouldn't work either, so better bail out.\n    if( m_nCompression == COMPRESSION_OJPEG \u0026\u0026\n        !bTreatAsRGBA )\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Old-JPEG compression only supported through RGBA interface, \"\n                 \"which cannot be used probably because the file is corrupted\");\n        return CE_Failure;\n    }\n\n    // If photometric is YCbCr, scanline/strip/tile interfaces assumes that\n    // we are ready with downsampled data. And we are not.\n    if( m_nCompression != COMPRESSION_JPEG \u0026\u0026\n        m_nCompression != COMPRESSION_OJPEG \u0026\u0026\n        m_nPhotometric == PHOTOMETRIC_YCBCR \u0026\u0026\n        m_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026\n        !bTreatAsRGBA )\n    {\n        uint16 nF1, nF2;\n        TIFFGetFieldDefaulted(m_hTIFF,TIFFTAG_YCBCRSUBSAMPLING,\u0026nF1,\u0026nF2);\n        if( nF1 != 1 || nF2 != 1 )\n        {\n            ReportError( CE_Failure, CPLE_AppDefined,\n                      \"Cannot open TIFF file with YCbCr, subsampling and \"\n                      \"BitsPerSample \u003e 8 that is not JPEG compressed\" );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(m_hTIFF)\n        \u0026\u0026 m_nBitsPerSample == 8\n        \u0026\u0026 m_nBlockYSize == nRasterYSize\n        \u0026\u0026 nRasterYSize \u003e 2000\n        \u0026\u0026 !bTreatAsRGBA\n        \u0026\u0026 CPLTestBool(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")) )\n    {\n        // libtiff 4.0.0beta5 (also\n        // 20091104) and older will crash when trying to open a\n        // all-in-one-strip YCbCr JPEG compressed TIFF (see #3259).\n#if (TIFFLIB_VERSION \u003c= 20091104)\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR \u0026\u0026\n            m_nCompression == COMPRESSION_JPEG )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"Avoid using split band to open all-in-one-strip \"\n                \"YCbCr JPEG compressed TIFF because of older libtiff\" );\n        }\n        else\n#endif\n        {\n            m_bTreatAsSplit = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsOdd = false;\n    if( m_nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if( m_nBitsPerSample == 16 || m_nBitsPerSample == 24 )\n            bTreatAsOdd = true;\n    }\n    else if( !bTreatAsRGBA \u0026\u0026 !bTreatAsBitmap\n             \u0026\u0026 m_nBitsPerSample != 8\n             \u0026\u0026 m_nBitsPerSample != 16\n             \u0026\u0026 m_nBitsPerSample != 32\n             \u0026\u0026 m_nBitsPerSample != 64\n             \u0026\u0026 m_nBitsPerSample != 128 )\n    {\n        bTreatAsOdd = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We can't support 'chunks' bigger than 2GB on 32 bit builds      */\n/* -------------------------------------------------------------------- */\n#if SIZEOF_VOIDP == 4\n    uint64 nChunkSize = 0;\n    if( m_bTreatAsSplit || m_bTreatAsSplitBitmap )\n    {\n        nChunkSize = TIFFScanlineSize64( m_hTIFF );\n    }\n    else\n    {\n        if( TIFFIsTiled(m_hTIFF) )\n            nChunkSize = TIFFTileSize64( m_hTIFF );\n        else\n            nChunkSize = TIFFStripSize64( m_hTIFF );\n    }\n    if( bTreatAsRGBA )\n    {\n        nChunkSize = std::max(nChunkSize,\n                        4 * static_cast\u003cuint64\u003e(m_nBlockXSize) * m_nBlockYSize);\n    }\n    if( nChunkSize \u003e static_cast\u003cuint64\u003e(INT_MAX) )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Scanline/tile/strip size bigger than 2GB unsupported \"\n                  \"on 32-bit builds.\" );\n        return CE_Failure;\n    }\n#endif\n\n    const bool bMinIsWhite = m_nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    char *pszText = nullptr;\n    if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_NODATA, \u0026pszText ) \u0026\u0026\n        !EQUAL(pszText, \"\") )\n    {\n        m_bNoDataSet = true;\n        m_dfNoDataValue = CPLAtofM( pszText );\n        if( m_nBitsPerSample == 32 \u0026\u0026 m_nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        {\n            m_dfNoDataValue = GDALAdjustNoDataCloseToFloatMax(m_dfNoDataValue);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( bTreatAsRGBA || m_nBitsPerSample \u003e 16\n        || TIFFGetField( m_hTIFF, TIFFTAG_COLORMAP,\n                         \u0026panRed, \u0026panGreen, \u0026panBlue) == 0 )\n    {\n        // Build inverted palette if we have inverted photometric.\n        // Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n        if( m_nBitsPerSample \u003c= 16 \u0026\u0026 m_nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            m_poColorTable = new GDALColorTable();\n            const int nColorCount = 1 \u003c\u003c m_nBitsPerSample;\n\n            for( int iColor = 0; iColor \u003c nColorCount; ++iColor )\n            {\n                const short nValue =\n                    static_cast\u003cshort\u003e(((255 * (nColorCount - 1 - iColor)) /\n                                        (nColorCount - 1)));\n                const GDALColorEntry oEntry =\n                    { nValue, nValue, nValue, static_cast\u003cshort\u003e(255) };\n                m_poColorTable-\u003eSetColorEntry( iColor, \u0026oEntry );\n            }\n\n            m_nPhotometric = PHOTOMETRIC_PALETTE;\n        }\n        else\n        {\n            m_poColorTable = nullptr;\n        }\n    }\n    else\n    {\n        unsigned short nMaxColor = 0;\n\n        m_poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 \u003c\u003c m_nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor \u003e= 0; iColor-- )\n        {\n            // TODO(schwehr): Ensure the color entries are never negative?\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast\u003cshort\u003e(panRed[iColor] / divisor),\n                static_cast\u003cshort\u003e(panGreen[iColor] / divisor),\n                static_cast\u003cshort\u003e(panBlue[iColor] / divisor),\n                static_cast\u003cshort\u003e(\n                    m_bNoDataSet \u0026\u0026 static_cast\u003cint\u003e(m_dfNoDataValue) == iColor\n                    ? 0\n                    : 255)\n            };\n\n            m_poColorTable-\u003eSetColorEntry( iColor, \u0026oEntry );\n\n            nMaxColor = std::max(nMaxColor, panRed[iColor]);\n            nMaxColor = std::max(nMaxColor, panGreen[iColor]);\n            nMaxColor = std::max(nMaxColor, panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor \u003e 0 \u0026\u0026 nMaxColor \u003c 256 )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n\n            for( int iColor = nColorCount - 1; iColor \u003e= 0; iColor-- )\n            {\n                // TODO(schwehr): Ensure the color entries are never negative?\n                const GDALColorEntry oEntry = {\n                    static_cast\u003cshort\u003e(panRed[iColor]),\n                    static_cast\u003cshort\u003e(panGreen[iColor]),\n                    static_cast\u003cshort\u003e(panBlue[iColor]),\n                    m_bNoDataSet \u0026\u0026\n                    static_cast\u003cint\u003e(m_dfNoDataValue) == iColor\n                    ? static_cast\u003cshort\u003e(0)\n                    : static_cast\u003cshort\u003e(255)\n                };\n\n                m_poColorTable-\u003eSetColorEntry( iColor, \u0026oEntry );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand \u003c nBands; ++iBand )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand + 1, new GTiffRGBABand( this, iBand + 1 ) );\n        else if( m_bTreatAsSplitBitmap )\n            SetBand( iBand + 1, new GTiffSplitBitmapBand( this, iBand + 1 ) );\n        else if( m_bTreatAsSplit )\n            SetBand( iBand + 1, new GTiffSplitBand( this, iBand + 1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand + 1, new GTiffBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand + 1, new GTiffOddBitsBand( this, iBand + 1 ) );\n        else\n            SetBand( iBand + 1, new GTiffRasterBand( this, iBand + 1 ) );\n    }\n\n    if( GetRasterBand(1)-\u003eGetRasterDataType() == GDT_Unknown )\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Unsupported TIFF configuration: BitsPerSample(=%d) and \"\n                 \"SampleType(=%d)\",\n                 m_nBitsPerSample,\n                 m_nSampleFormat);\n        return CE_Failure;\n    }\n\n    m_bReadGeoTransform = bReadGeoTransform;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char szWorkMDI[200] = {};\n    uint16 nShort = 0;\n\n    for( size_t iTag = 0;\n         iTag \u003c sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n         ++iTag )\n    {\n        if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n        {\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, \u0026pszText ) )\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            pszText );\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n        {\n            float fVal = 0.0;\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, \u0026fVal ) )\n            {\n                CPLsnprintf( szWorkMDI, sizeof(szWorkMDI), \"%.8g\", fVal );\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT \u0026\u0026\n                 asTIFFTags[iTag].nTagVal != TIFFTAG_RESOLUTIONUNIT )\n        {\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, \u0026nShort ) )\n            {\n                snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n        {\n            uint32 nCount = 0;\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal,\n                              \u0026nCount, \u0026pszText ) )\n            {\n                std::string osStr;\n                osStr.assign(pszText, nCount);\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            osStr.c_str() );\n            }\n        }\n    }\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_RESOLUTIONUNIT, \u0026nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            snprintf( szWorkMDI, sizeof(szWorkMDI),\n                      \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/cm)\", nShort );\n        else\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n        m_oGTiffMDMD.SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    int nTagSize = 0;\n    void* pData = nullptr;\n    if( TIFFGetField( m_hTIFF, TIFFTAG_XMLPACKET, \u0026nTagSize, \u0026pData ) )\n    {\n        char* pszXMP =\n            static_cast\u003cchar *\u003e( VSI_MALLOC_VERBOSE(nTagSize + 1) );\n        if( pszXMP )\n        {\n            memcpy(pszXMP, pData, nTagSize);\n            pszXMP[nTagSize] = '\\0';\n\n            char *apszMDList[2] = { pszXMP, nullptr };\n            m_oGTiffMDMD.SetMetadata(apszMDList, \"xml:XMP\");\n\n            CPLFree(pszXMP);\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( m_nCompression == COMPRESSION_CCITTRLE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTFAX3 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTFAX4 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LZW )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_OJPEG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JPEG )\n    {\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR )\n            m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n        else\n            m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_NEXT )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTRLEW )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PACKBITS )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PACKBITS\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_THUNDERSCAN )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PIXARFILM )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PIXARLOG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_DEFLATE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_ADOBE_DEFLATE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_DCS )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JBIG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_SGILOG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_SGILOG24 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG24\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JP2000 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JP2000\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LZMA )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZMA\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_ZSTD )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"ZSTD\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LERC )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC\", \"IMAGE_STRUCTURE\" );\n#if HAVE_LERC\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_PARAMETERS, \u0026nLercParamCount,\n                          \u0026panLercParms ) \u0026\u0026\n            nLercParamCount == 2 )\n        {\n            memcpy( m_anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(m_anLercAddCompressionAndVersion) );\n        }\n\n        uint32 nAddVersion = LERC_ADD_COMPRESSION_NONE;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION, \u0026nAddVersion ) \u0026\u0026\n            nAddVersion != LERC_ADD_COMPRESSION_NONE )\n        {\n            if( nAddVersion == LERC_ADD_COMPRESSION_DEFLATE )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_DEFLATE\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else if( nAddVersion == LERC_ADD_COMPRESSION_ZSTD )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_ZSTD\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n        }\n        uint32 nLercVersion = LERC_VERSION_2_4;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_VERSION, \u0026nLercVersion) )\n        {\n            if( nLercVersion == LERC_VERSION_2_4 )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"LERC_VERSION\", \"2.4\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Unknown Lerc version: %d\", nLercVersion);\n            }\n        }\n#endif\n    }\n    else if( m_nCompression == COMPRESSION_WEBP )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"WEBP\", \"IMAGE_STRUCTURE\" );\n    }\n    else\n    {\n        CPLString oComp;\n        oComp.Printf( \"%d\", m_nCompression);\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", oComp.c_str());\n    }\n\n    if( m_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 nBands != 1 )\n        m_oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        m_oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if( (GetRasterBand(1)-\u003eGetRasterDataType() == GDT_Byte \u0026\u0026\n         m_nBitsPerSample != 8 ) ||\n        (GetRasterBand(1)-\u003eGetRasterDataType() == GDT_UInt16 \u0026\u0026\n         m_nBitsPerSample != 16) ||\n        ((GetRasterBand(1)-\u003eGetRasterDataType() == GDT_UInt32 ||\n          GetRasterBand(1)-\u003eGetRasterDataType() == GDT_Float32) \u0026\u0026\n         m_nBitsPerSample != 32) )\n    {\n        for( int i = 0; i \u003c nBands; ++i )\n            cpl::down_cast\u003cGTiffRasterBand*\u003e(GetRasterBand(i + 1))-\u003e\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"NBITS\",\n                    CPLString().Printf(\n                        \"%d\", static_cast\u003cint\u003e(m_nBitsPerSample) ),\n                    \"IMAGE_STRUCTURE\" );\n    }\n\n    if( bMinIsWhite )\n        m_oGTiffMDMD.SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, \u0026pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = nullptr;\n\n        if( psRoot != nullptr \u0026\u0026 psRoot-\u003eeType == CXT_Element\n            \u0026\u0026 EQUAL(psRoot-\u003epszValue,\"GDALMetadata\") )\n            psItem = psRoot-\u003epsChild;\n\n        for( ; psItem != nullptr; psItem = psItem-\u003epsNext )\n        {\n\n            if( psItem-\u003eeType != CXT_Element\n                || !EQUAL(psItem-\u003epszValue,\"Item\") )\n                continue;\n\n            const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n            const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n            int nBand =\n                atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n            if( nBand \u003c -1 || nBand \u003e 65535 )\n                continue;\n            nBand ++;\n            const char *pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            const char *pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n\n            if( pszKey == nullptr || pszValue == nullptr )\n                continue;\n            if( EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n                continue;\n\n            bool bIsXML = false;\n\n            if( STARTS_WITH_CI(pszDomain, \"xml:\") )\n                bIsXML = TRUE;\n\n            char *pszUnescapedValue =\n                CPLUnescapeString( pszValue, nullptr, CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, nullptr };\n                    m_oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                }\n                else\n                {\n                    m_oGTiffMDMD.SetMetadataItem( pszKey, pszUnescapedValue,\n                                                pszDomain );\n                }\n            }\n            else\n            {\n                GTiffRasterBand *poBand =\n                    cpl::down_cast\u003cGTiffRasterBand*\u003e(GetRasterBand(nBand));\n                if( poBand != nullptr )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                    {\n                        poBand-\u003em_bHaveOffsetScale = true;\n                        poBand-\u003em_dfScale = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"offset\") )\n                    {\n                        poBand-\u003em_bHaveOffsetScale = true;\n                        poBand-\u003em_dfOffset = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"unittype\") )\n                    {\n                        poBand-\u003em_osUnitType = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole,\"description\") )\n                    {\n                        poBand-\u003em_osDescription = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole, \"colorinterp\") )\n                    {\n                        poBand-\u003em_eBandInterp =\n                            GDALGetColorInterpretationByName(pszUnescapedValue);\n                    }\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, nullptr };\n                            poBand-\u003em_oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                        {\n                            poBand-\u003em_oGTiffMDMD.SetMetadataItem(\n                                pszKey,\n                                pszUnescapedValue,\n                                pszDomain );\n                        }\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    if( m_bStreamingIn )\n    {\n        toff_t* panOffsets = nullptr;\n        TIFFGetField( m_hTIFF,\n                      TIFFIsTiled( m_hTIFF ) ?\n                      TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                      \u0026panOffsets );\n        if( panOffsets )\n        {\n            int nBlockCount =\n                TIFFIsTiled(m_hTIFF) ?\n                TIFFNumberOfTiles(m_hTIFF) : TIFFNumberOfStrips(m_hTIFF);\n            for( int i = 1; i \u003c nBlockCount; ++i )\n            {\n                if( panOffsets[i] \u003c panOffsets[i-1] )\n                {\n                    m_oGTiffMDMD.SetMetadataItem( \"UNORDERED_BLOCKS\", \"YES\",\n                                                \"TIFF\");\n                    CPLDebug(\n                        \"GTIFF\",\n                        \"Offset of block %d is lower than previous block. \"\n                        \"Reader must be careful\",\n                        i );\n                    break;\n                }\n            }\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_JPEG \u0026\u0026 eAccess == GA_Update )\n    {\n        SetJPEGQualityAndTablesModeFromFile();\n    }\n\n    CPLAssert(m_bReadGeoTransform == bReadGeoTransform);\n    CPLAssert(!m_bMetadataChanged);\n    m_bMetadataChanged = false;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                         GetSiblingFiles()                            */\n/************************************************************************/\n\nchar** GTiffDataset::GetSiblingFiles()\n{\n    if( m_bHasGotSiblingFiles )\n    {\n        return oOvManager.GetSiblingFiles();\n    }\n\n    m_bHasGotSiblingFiles = true;\n    const int nMaxFiles =\n        atoi(CPLGetConfigOption(\"GDAL_READDIR_LIMIT_ON_OPEN\", \"1000\"));\n    char** papszSiblingFiles =\n        VSIReadDirEx(CPLGetDirname(m_pszFilename), nMaxFiles);\n    if( nMaxFiles \u003e 0 \u0026\u0026 CSLCount(papszSiblingFiles) \u003e nMaxFiles )\n    {\n        CPLDebug(\"GTiff\", \"GDAL_READDIR_LIMIT_ON_OPEN reached on %s\",\n                 CPLGetDirname(m_pszFilename));\n        CSLDestroy(papszSiblingFiles);\n        papszSiblingFiles = nullptr;\n    }\n    oOvManager.TransferSiblingFiles( papszSiblingFiles );\n\n    return papszSiblingFiles;\n}\n\n/************************************************************************/\n/*                   IdentifyAuthorizedGeoreferencingSources()          */\n/************************************************************************/\n\nvoid GTiffDataset::IdentifyAuthorizedGeoreferencingSources()\n{\n    if( m_bHasIdentifiedAuthorizedGeoreferencingSources )\n        return;\n    m_bHasIdentifiedAuthorizedGeoreferencingSources = true;\n    CPLString osGeorefSources = CSLFetchNameValueDef( papszOpenOptions,\n        \"GEOREF_SOURCES\",\n        CPLGetConfigOption(\"GDAL_GEOREF_SOURCES\",\n                           \"PAM,INTERNAL,TABFILE,WORLDFILE\") );\n    char** papszTokens = CSLTokenizeString2(osGeorefSources, \",\", 0);\n    m_nPAMGeorefSrcIndex = static_cast\u003csigned char\u003e(CSLFindString(papszTokens, \"PAM\"));\n    m_nINTERNALGeorefSrcIndex = static_cast\u003csigned char\u003e(CSLFindString(papszTokens, \"INTERNAL\"));\n    m_nTABFILEGeorefSrcIndex = static_cast\u003csigned char\u003e(CSLFindString(papszTokens, \"TABFILE\"));\n    m_nWORLDFILEGeorefSrcIndex = static_cast\u003csigned char\u003e(CSLFindString(papszTokens, \"WORLDFILE\"));\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                     LoadGeoreferencingAndPamIfNeeded()               */\n/************************************************************************/\n\nvoid GTiffDataset::LoadGeoreferencingAndPamIfNeeded()\n\n{\n    if( !m_bReadGeoTransform \u0026\u0026 !m_bLoadPam )\n        return;\n\n    IdentifyAuthorizedGeoreferencingSources();\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( m_bReadGeoTransform )\n    {\n        m_bReadGeoTransform = false;\n\n        char *pszTabWKT = nullptr;\n        double *padfTiePoints = nullptr;\n        double *padfScale = nullptr;\n        double *padfMatrix = nullptr;\n        uint16 nCount = 0;\n        bool bPixelIsPoint = false;\n        unsigned short nRasterType = 0;\n        bool bPointGeoIgnore = false;\n\n        std::set\u003csigned char\u003e aoSetPriorities;\n        if( m_nINTERNALGeorefSrcIndex \u003e= 0 )\n            aoSetPriorities.insert(m_nINTERNALGeorefSrcIndex);\n        if( m_nTABFILEGeorefSrcIndex \u003e= 0 )\n            aoSetPriorities.insert(m_nTABFILEGeorefSrcIndex);\n        if( m_nWORLDFILEGeorefSrcIndex \u003e= 0 )\n            aoSetPriorities.insert(m_nWORLDFILEGeorefSrcIndex);\n        for(const auto nIndex: aoSetPriorities )\n        {\n            if( m_nINTERNALGeorefSrcIndex == nIndex )\n            {\n                GTIF *psGTIF = GTiffDatasetGTIFNew( m_hTIFF );  // How expensive this is?\n\n                if( psGTIF )\n                {\n                    if( GDALGTIFKeyGetSHORT(psGTIF, GTRasterTypeGeoKey,\n                                            \u0026nRasterType, 0, 1 ) == 1\n                        \u0026\u0026 nRasterType ==\n                           static_cast\u003cshort\u003e(RasterPixelIsPoint) )\n                    {\n                        bPixelIsPoint = true;\n                        bPointGeoIgnore =\n                            CPLTestBool(\n                                CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                                   \"FALSE\") );\n                    }\n\n                    GTIFFree( psGTIF );\n                }\n\n                m_adfGeoTransform[0] = 0.0;\n                m_adfGeoTransform[1] = 1.0;\n                m_adfGeoTransform[2] = 0.0;\n                m_adfGeoTransform[3] = 0.0;\n                m_adfGeoTransform[4] = 0.0;\n                m_adfGeoTransform[5] = 1.0;\n\n                uint16 nCountScale = 0;\n                if( TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE,\n                                 \u0026nCountScale, \u0026padfScale )\n                    \u0026\u0026 nCountScale \u003e= 2\n                    \u0026\u0026 padfScale[0] != 0.0 \u0026\u0026 padfScale[1] != 0.0 )\n                {\n                    m_adfGeoTransform[1] = padfScale[0];\n                    if( padfScale[1] \u003c 0 )\n                    {\n                        const char* pszOptionVal =\n                            CPLGetConfigOption(\"GTIFF_HONOUR_NEGATIVE_SCALEY\",\n                                               nullptr);\n                        if( pszOptionVal == nullptr )\n                        {\n                            ReportError(CE_Warning, CPLE_AppDefined,\n                                \"File with negative value for ScaleY in \"\n                                \"GeoPixelScale tag. This is rather \"\n                                \"unusual. GDAL, contrary to the GeoTIFF \"\n                                \"specification, assumes that the file \"\n                                \"was intended to be north-up, and will \"\n                                \"treat this file as if ScaleY was \"\n                                \"positive. You may override this behavior \"\n                                \"by setting the GTIFF_HONOUR_NEGATIVE_SCALEY \"\n                                \"configuration option to YES\");\n                            m_adfGeoTransform[5] = padfScale[1];\n                        }\n                        else if( CPLTestBool(pszOptionVal) )\n                        {\n                            m_adfGeoTransform[5] = -padfScale[1];\n                        }\n                        else\n                        {\n                            m_adfGeoTransform[5] = padfScale[1];\n                        }\n                    }\n                    else\n                    {\n                        m_adfGeoTransform[5] = -padfScale[1];\n                    }\n\n                    if( TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                                     \u0026nCount, \u0026padfTiePoints )\n                        \u0026\u0026 nCount \u003e= 6 )\n                    {\n                        m_adfGeoTransform[0] =\n                            padfTiePoints[3] -\n                            padfTiePoints[0] * m_adfGeoTransform[1];\n                        m_adfGeoTransform[3] =\n                            padfTiePoints[4] -\n                            padfTiePoints[1] * m_adfGeoTransform[5];\n\n                        if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n                        {\n                            m_adfGeoTransform[0] -=\n                                (m_adfGeoTransform[1] * 0.5 +\n                                 m_adfGeoTransform[2] * 0.5);\n                            m_adfGeoTransform[3] -=\n                                (m_adfGeoTransform[4] * 0.5 +\n                                 m_adfGeoTransform[5] * 0.5);\n                        }\n\n                        m_bGeoTransformValid = true;\n                        m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                        if( nCountScale \u003e= 3 \u0026\u0026 GetRasterCount() == 1 \u0026\u0026\n                            (padfScale[2] != 0.0 ||\n                             padfTiePoints[2] != 0.0 ||\n                             padfTiePoints[5] != 0.0) )\n                        {\n                            LookForProjection();\n                            if( !m_oSRS.IsEmpty() \u0026\u0026 m_oSRS.IsVertical() )\n                            {\n                                /* modelTiePointTag = (pixel, line, z0, X, Y, Z0) */\n                                /* thus Z(some_point) = (z(some_point) - z0) * scaleZ + Z0 */\n                                /* equivalently written as */\n                                /* Z(some_point) = z(some_point) * scaleZ + offsetZ with */\n                                /* offsetZ = - z0 * scaleZ + Z0 */\n                                double dfScale = padfScale[2];\n                                double dfOffset =\n                                    -padfTiePoints[2] * dfScale + padfTiePoints[5];\n                                GTiffRasterBand* poBand =\n                                    cpl::down_cast\u003cGTiffRasterBand*\u003e(GetRasterBand(1));\n                                poBand-\u003em_bHaveOffsetScale = true;\n                                poBand-\u003em_dfScale = dfScale;\n                                poBand-\u003em_dfOffset = dfOffset;\n                            }\n                        }\n                    }\n                }\n\n                else if( TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX,\n                                      \u0026nCount, \u0026padfMatrix )\n                        \u0026\u0026 nCount == 16 )\n                {\n                    m_adfGeoTransform[0] = padfMatrix[3];\n                    m_adfGeoTransform[1] = padfMatrix[0];\n                    m_adfGeoTransform[2] = padfMatrix[1];\n                    m_adfGeoTransform[3] = padfMatrix[7];\n                    m_adfGeoTransform[4] = padfMatrix[4];\n                    m_adfGeoTransform[5] = padfMatrix[5];\n\n                    if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n                    {\n                        m_adfGeoTransform[0] -=\n                            m_adfGeoTransform[1] * 0.5 + m_adfGeoTransform[2] * 0.5;\n                        m_adfGeoTransform[3] -=\n                            m_adfGeoTransform[4] * 0.5 + m_adfGeoTransform[5] * 0.5;\n                    }\n\n                    m_bGeoTransformValid = true;\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tab, .tfw, .tifw or .wld file.     */\n/* -------------------------------------------------------------------- */\n            if( m_nTABFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                // Begin with .tab since it can also have projection info.\n                const int bTabFileOK =\n                    GDALReadTabFile2( m_pszFilename, m_adfGeoTransform,\n                                        \u0026pszTabWKT, \u0026m_nGCPCount, \u0026m_pasGCPList,\n                                        papszSiblingFiles, \u0026pszGeorefFilename );\n\n                if( bTabFileOK )\n                {\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                    // if( pszTabWKT )\n                    // {\n                    //     m_nProjectionGeorefSrcIndex = nIndex;\n                    // }\n                    if( m_nGCPCount == 0 )\n                    {\n                        m_bGeoTransformValid = true;\n                    }\n                }\n\n                if( pszGeorefFilename )\n                {\n                    CPLFree(m_pszGeorefFilename);\n                    m_pszGeorefFilename = pszGeorefFilename;\n                    pszGeorefFilename = nullptr;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n\n            if( m_nWORLDFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                m_bGeoTransformValid = CPL_TO_BOOL( GDALReadWorldFile2(\n                                m_pszFilename, nullptr, m_adfGeoTransform,\n                                papszSiblingFiles, \u0026pszGeorefFilename) );\n\n                if( !m_bGeoTransformValid )\n                {\n                    m_bGeoTransformValid =\n                        CPL_TO_BOOL( GDALReadWorldFile2(\n                            m_pszFilename, \"wld\", m_adfGeoTransform,\n                            papszSiblingFiles, \u0026pszGeorefFilename ) );\n                }\n                if( m_bGeoTransformValid )\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                if( pszGeorefFilename )\n                {\n                    CPLFree(m_pszGeorefFilename);\n                    m_pszGeorefFilename = pszGeorefFilename;\n                    pszGeorefFilename = nullptr;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.                                                 */\n/* -------------------------------------------------------------------- */\n        if( m_nINTERNALGeorefSrcIndex \u003e= 0 \u0026\u0026\n            TIFFGetField(m_hTIFF,TIFFTAG_GEOTIEPOINTS,\u0026nCount,\u0026padfTiePoints )\n            \u0026\u0026 !m_bGeoTransformValid )\n        {\n            if( m_nGCPCount \u003e 0 )\n            {\n                GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n                CPLFree( m_pasGCPList );\n            }\n            m_nGCPCount = nCount / 6;\n            m_pasGCPList =\n                static_cast\u003cGDAL_GCP *\u003e(CPLCalloc(sizeof(GDAL_GCP), m_nGCPCount));\n\n            for( int iGCP = 0; iGCP \u003c m_nGCPCount; ++iGCP )\n            {\n                char szID[32] = {};\n\n                snprintf( szID, sizeof(szID), \"%d\", iGCP + 1 );\n                m_pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                m_pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                m_pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                m_pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                m_pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                m_pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                m_pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n\n                if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n                {\n                    m_pasGCPList[iGCP].dfGCPPixel += 0.5;\n                    m_pasGCPList[iGCP].dfGCPLine += 0.5;\n                }\n            }\n            m_nGeoTransformGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use its coordinate       */\n/*      system and give it precedence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != nullptr \u0026\u0026 m_oSRS.IsEmpty() )\n        {\n            m_oSRS.SetFromUserInput(pszTabWKT);\n            m_bLookedForProjection = true;\n        }\n\n        CPLFree( pszTabWKT );\n    }\n\n    if( m_bLoadPam \u0026\u0026 m_nPAMGeorefSrcIndex \u003e= 0 )\n    {\n/* -------------------------------------------------------------------- */\n/*      Initialize any PAM information.                                 */\n/* -------------------------------------------------------------------- */\n        CPLAssert(!m_bColorProfileMetadataChanged);\n        CPLAssert(!m_bMetadataChanged);\n        CPLAssert(!m_bGeoTIFFInfoChanged);\n        CPLAssert(!m_bNoDataChanged);\n\n        // We must absolutely unset m_bLoadPam now, otherwise calling\n        // GetFileList() on a .tif with a .aux will result in an (almost)\n        // endless sequence of calls.\n        m_bLoadPam = false;\n\n        TryLoadXML( GetSiblingFiles() );\n        ApplyPamInfo();\n\n        m_bColorProfileMetadataChanged = false;\n        m_bMetadataChanged = false;\n        m_bGeoTIFFInfoChanged = false;\n        m_bNoDataChanged = false;\n\n        for( int i = 1; i \u003c= nBands; ++i )\n        {\n            GTiffRasterBand* poBand =\n                cpl::down_cast\u003cGTiffRasterBand *\u003e(GetRasterBand(i));\n\n            /* Load scale, offset and unittype from PAM if available */\n            if( !poBand-\u003em_bHaveOffsetScale )\n            {\n                int nHaveOffsetScale = FALSE;\n                poBand-\u003em_dfScale =\n                    poBand-\u003eGDALPamRasterBand::GetScale( \u0026nHaveOffsetScale );\n                poBand-\u003em_bHaveOffsetScale = CPL_TO_BOOL(nHaveOffsetScale);\n                poBand-\u003em_dfOffset = poBand-\u003eGDALPamRasterBand::GetOffset();\n            }\n            if( poBand-\u003em_osUnitType.empty() )\n            {\n                const char* pszUnitType =\n                    poBand-\u003eGDALPamRasterBand::GetUnitType();\n                if( pszUnitType )\n                    poBand-\u003em_osUnitType = pszUnitType;\n            }\n            if( poBand-\u003em_osDescription.empty() )\n                poBand-\u003em_osDescription =\n                    poBand-\u003eGDALPamRasterBand::GetDescription();\n\n            GDALColorInterp ePAMColorInterp =\n                poBand-\u003eGDALPamRasterBand::GetColorInterpretation();\n            if( ePAMColorInterp != GCI_Undefined )\n                poBand-\u003em_eBandInterp = ePAMColorInterp;\n        }\n    }\n    m_bLoadPam = false;\n}\n\n/************************************************************************/\n/*                   SetStructuralMDFromParent()                        */\n/************************************************************************/\n\nvoid GTiffDataset::SetStructuralMDFromParent(GTiffDataset* poParentDS)\n{\n    m_bBlockOrderRowMajor = poParentDS-\u003em_bBlockOrderRowMajor;\n    m_bLeaderSizeAsUInt4 = poParentDS-\u003em_bLeaderSizeAsUInt4;\n    m_bTrailerRepeatedLast4BytesRepeated = poParentDS-\u003em_bTrailerRepeatedLast4BytesRepeated;\n    m_bMaskInterleavedWithImagery = poParentDS-\u003em_bMaskInterleavedWithImagery;\n    m_bWriteEmptyTiles = poParentDS-\u003em_bWriteEmptyTiles;\n}\n\n/************************************************************************/\n/*                          ScanDirectories()                           */\n/*                                                                      */\n/*      Scan through all the directories finding overviews, masks       */\n/*      and subdatasets.                                                */\n/************************************************************************/\n\nvoid GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !m_bScanDeferred )\n        return;\n\n    m_bScanDeferred = false;\n\n    if( m_poBaseDS )\n        return;\n\n    Crystalize();\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n\n    do\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nTopDir = TIFFCurrentDirOffset(m_hTIFF);\n        uint32 nSubType = 0;\n\n        ++iDirIndex;\n\n        toff_t *tmpSubIFDOffsets = nullptr;\n        toff_t *subIFDOffsets = nullptr;\n        uint16 nSubIFDs = 0;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_SUBIFD, \u0026nSubIFDs, \u0026tmpSubIFDOffsets) \u0026\u0026 iDirIndex == 1)\n        {\n            subIFDOffsets = static_cast\u003ctoff_t *\u003e(CPLMalloc(nSubIFDs * sizeof(toff_t)));\n            for (uint16 iSubIFD = 0; iSubIFD \u003c nSubIFDs; iSubIFD++)\n            {\n                subIFDOffsets[iSubIFD] = tmpSubIFDOffsets[iSubIFD];\n            }\n        }\n\n        //early break for backwards compatibility: if the first directory read is also the last, and there are no subIFDs, no use continuing\n        if( iDirIndex==1 \u0026\u0026 nSubIFDs==0 \u0026\u0026 TIFFLastDirectory( m_hTIFF )) {\n            CPLFree(subIFDOffsets);\n            break;\n        }\n\n\n        for( uint16 iSubIFD = 0; iSubIFD\u003c=nSubIFDs; iSubIFD++ ) {\n            toff_t nThisDir = nTopDir;\n            if ( iSubIFD \u003e 0 \u0026\u0026 iDirIndex \u003e 1 ) //don't read subIFDs if we are not in the original directory\n                break;\n            if ( iSubIFD \u003e 0 ) {\n                // make static analyzer happy. subIFDOffsets cannot be null if iSubIFD\u003e0\n                assert(subIFDOffsets != nullptr); \n                nThisDir = subIFDOffsets[iSubIFD-1];\n                //CPLDebug(\"GTiff\", \"Opened subIFD %d/%d at offset %llu.\", iSubIFD, nSubIFDs, nThisDir);\n                if (!TIFFSetSubDirectory(m_hTIFF,nThisDir))\n                    break;\n            }\n\n\n            if( !TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, \u0026nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if( (nSubType \u0026 FILETYPE_REDUCEDIMAGE) != 0 \u0026\u0026\n                (nSubType \u0026 FILETYPE_MASK) == 0 \u0026\u0026\n                ((nSubIFDs==0 \u0026\u0026 iDirIndex != 1) || iSubIFD\u003e0) \u0026\u0026\n                m_nOverviewCount \u003c 30 /* to avoid DoS */ )\n            {\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS-\u003eShareLockWithParentDataset(this);\n                poODS-\u003eSetStructuralMDFromParent(this);\n                poODS-\u003em_pszFilename = CPLStrdup(m_pszFilename);\n                if( poODS-\u003eOpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poODS-\u003eGetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                            poODS-\u003eGetRasterXSize(), poODS-\u003eGetRasterYSize());\n                    ++m_nOverviewCount;\n                    m_papoOverviewDS = static_cast\u003cGTiffDataset **\u003e(\n                        CPLRealloc(m_papoOverviewDS,\n                                m_nOverviewCount * (sizeof(void*))) );\n                    m_papoOverviewDS[m_nOverviewCount-1] = poODS;\n                    poODS-\u003em_poBaseDS = this;\n                    poODS-\u003em_bIsOverview = true;\n                }\n            }\n            // Embedded mask of the main image.\n            else if( (nSubType \u0026 FILETYPE_MASK) != 0 \u0026\u0026\n                    (nSubType \u0026 FILETYPE_REDUCEDIMAGE) == 0 \u0026\u0026\n                    ((nSubIFDs==0 \u0026\u0026 iDirIndex != 1) || iSubIFD\u003e0) \u0026\u0026\n                    m_poMaskDS == nullptr )\n            {\n                m_poMaskDS = new GTiffDataset();\n                m_poMaskDS-\u003eShareLockWithParentDataset(this);\n                m_poMaskDS-\u003eSetStructuralMDFromParent(this);\n                m_poMaskDS-\u003em_pszFilename = CPLStrdup(m_pszFilename);\n\n                // The TIFF6 specification - page 37 - only allows 1\n                // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n                // 8 bit per sample and we support either 1 sample per pixel or as\n                // many samples as in the main image We don't check the value of\n                // the PhotometricInterpretation tag, which should be set to\n                // \"Transparency mask\" (4) according to the specification (page\n                // 36).  However, the TIFF6 specification allows image masks to\n                // have a higher resolution than the main image, what we don't\n                // support here.\n\n                if( m_poMaskDS-\u003eOpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                        eAccess ) != CE_None\n                    || m_poMaskDS-\u003eGetRasterCount() == 0\n                    || !(m_poMaskDS-\u003eGetRasterCount() == 1\n                        || m_poMaskDS-\u003eGetRasterCount() == GetRasterCount())\n                    || m_poMaskDS-\u003eGetRasterXSize() != GetRasterXSize()\n                    || m_poMaskDS-\u003eGetRasterYSize() != GetRasterYSize()\n                    || m_poMaskDS-\u003eGetRasterBand(1)-\u003eGetRasterDataType() != GDT_Byte)\n                {\n                    delete m_poMaskDS;\n                    m_poMaskDS = nullptr;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\");\n                    m_poMaskDS-\u003em_poBaseDS = this;\n                    m_poMaskDS-\u003em_poImageryDS = this;\n\n                    m_poMaskDS-\u003em_bPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                                \"YES\" ) );\n                }\n            }\n\n            // Embedded mask of an overview.  The TIFF6 specification allows the\n            // combination of the FILETYPE_xxxx masks.\n            else if( (nSubType \u0026 FILETYPE_REDUCEDIMAGE) != 0 \u0026\u0026\n                    (nSubType \u0026 FILETYPE_MASK) != 0 \u0026\u0026\n                    ((nSubIFDs==0 \u0026\u0026 iDirIndex != 1) || iSubIFD\u003e0))\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                poDS-\u003eShareLockWithParentDataset(this);\n                poDS-\u003eSetStructuralMDFromParent(this);\n                poDS-\u003em_pszFilename = CPLStrdup(m_pszFilename);\n                if( poDS-\u003eOpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poDS-\u003eGetRasterCount() == 0\n                    || poDS-\u003eGetRasterBand(1)-\u003eGetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i = 0;  // Used after for.\n                    for( ; i \u003c m_nOverviewCount; ++i )\n                    {\n                        auto poOvrDS = cpl::down_cast\u003cGTiffDataset*\u003e(\n                                GDALDataset::FromHandle(m_papoOverviewDS[i]));\n                        if( poOvrDS-\u003em_poMaskDS == nullptr \u0026\u0026\n                            poDS-\u003eGetRasterXSize() ==\n                            m_papoOverviewDS[i]-\u003eGetRasterXSize() \u0026\u0026\n                            poDS-\u003eGetRasterYSize() ==\n                            m_papoOverviewDS[i]-\u003eGetRasterYSize() \u0026\u0026\n                            (poDS-\u003eGetRasterCount() == 1 ||\n                            poDS-\u003eGetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug(\n                                \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                                poDS-\u003eGetRasterXSize(), poDS-\u003eGetRasterYSize());\n                            poDS-\u003em_poImageryDS = poOvrDS;\n                            poOvrDS-\u003em_poMaskDS = poDS;\n                            poDS-\u003em_bPromoteTo8Bits =\n                                CPLTestBool(\n                                    CPLGetConfigOption(\n                                        \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                        \"YES\" ) );\n                            poDS-\u003em_poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if( i == m_nOverviewCount )\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( !m_bSingleIFDOpened \u0026\u0026 (nSubType == 0 || nSubType == FILETYPE_PAGE) )\n            {\n                uint32 nXSize = 0;\n                uint32 nYSize = 0;\n\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGEWIDTH, \u0026nXSize );\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGELENGTH, \u0026nYSize );\n\n                // For Geodetic TIFF grids (GTG)\n                // (https://proj.org/specifications/geodetictiffgrids.html)\n                // extract the grid_name to put it in the description\n                std::string osFriendlyName;\n                char* pszText = nullptr;\n                if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, \u0026pszText ) \u0026\u0026\n                    strstr(pszText, \"grid_name\") != nullptr )\n                {\n                    CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n                    CPLXMLNode *psItem = nullptr;\n\n                    if( psRoot != nullptr \u0026\u0026 psRoot-\u003eeType == CXT_Element\n                        \u0026\u0026 EQUAL(psRoot-\u003epszValue,\"GDALMetadata\") )\n                        psItem = psRoot-\u003epsChild;\n\n                    for( ; psItem != nullptr; psItem = psItem-\u003epsNext )\n                    {\n\n                        if( psItem-\u003eeType != CXT_Element\n                            || !EQUAL(psItem-\u003epszValue,\"Item\") )\n                            continue;\n\n                        const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n                        const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n                        int nBand =\n                            atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n                        if( pszKey \u0026\u0026 pszValue \u0026\u0026 nBand \u003c= 0 \u0026\u0026\n                            EQUAL(pszKey, \"grid_name\") )\n                        {\n                            osFriendlyName = \": \";\n                            osFriendlyName += pszValue;\n                            break;\n                        }\n                    }\n\n                    CPLDestroyXMLNode(psRoot);\n                }\n\n                if( nXSize \u003e INT_MAX || nYSize \u003e INT_MAX )\n                {\n                    CPLDebug(\"GTiff\",\n                            \"Skipping directory with too large image: %u x %u\",\n                            nXSize, nYSize);\n                }\n                else\n                {\n                    uint16 nSPP = 0;\n                    if( !TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, \u0026nSPP ) )\n                        nSPP = 1;\n\n                    CPLString osName, osDesc;\n                    osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                                iDirIndex, iDirIndex, m_pszFilename );\n                    osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                                iDirIndex, iDirIndex,\n                                static_cast\u003cint\u003e(nXSize),\n                                static_cast\u003cint\u003e(nYSize),\n                                nSPP );\n                    osDesc += osFriendlyName;\n\n                    aosSubdatasets.AddString(osName);\n                    aosSubdatasets.AddString(osDesc);\n                }\n            }\n        }\n        CPLFree(subIFDOffsets);\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(m_hTIFF) != nTopDir )\n            TIFFSetSubDirectory( m_hTIFF, nTopDir );\n    } while( !m_bSingleIFDOpened \u0026\u0026 !TIFFLastDirectory( m_hTIFF ) \u0026\u0026 TIFFReadDirectory( m_hTIFF ) != 0 );\n\n\n    ReloadDirectory();\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( m_poMaskDS != nullptr )\n    {\n        for( int i = 0; i \u003c m_nOverviewCount; ++i )\n        {\n            if( cpl::down_cast\u003cGTiffDataset *\u003e(GDALDataset::FromHandle(\n                   m_papoOverviewDS[i]))-\u003em_poMaskDS != nullptr)\n            {\n                ++m_poMaskDS-\u003em_nOverviewCount;\n                m_poMaskDS-\u003em_papoOverviewDS = static_cast\u003cGTiffDataset **\u003e(\n                    CPLRealloc(m_poMaskDS-\u003em_papoOverviewDS,\n                               m_poMaskDS-\u003em_nOverviewCount * (sizeof(void*))) );\n                m_poMaskDS-\u003em_papoOverviewDS[m_poMaskDS-\u003em_nOverviewCount-1] =\n                    cpl::down_cast\u003cGTiffDataset*\u003e(GDALDataset::FromHandle(\n                        m_papoOverviewDS[i]))-\u003em_poMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() \u003e 2 )\n    {\n        m_oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}\n\nstatic signed char GTiffGetLZMAPreset(char** papszOptions)\n{\n    int nLZMAPreset = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"LZMA_PRESET\" );\n    if( pszValue != nullptr )\n    {\n        nLZMAPreset = atoi( pszValue );\n        if( !(nLZMAPreset \u003e= 0 \u0026\u0026 nLZMAPreset \u003c= 9) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"LZMA_PRESET=%s value not recognised, ignoring.\",\n                      pszValue );\n            nLZMAPreset = -1;\n        }\n    }\n    return static_cast\u003csigned char\u003e(nLZMAPreset);\n}\n\nstatic signed char GTiffGetZSTDPreset(char** papszOptions)\n{\n    int nZSTDLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZSTD_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZSTDLevel = atoi( pszValue );\n        if( !(nZSTDLevel \u003e= 1 \u0026\u0026 nZSTDLevel \u003c= 22) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZSTD_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZSTDLevel = -1;\n        }\n    }\n    return static_cast\u003csigned char\u003e(nZSTDLevel);\n}\n\n#if HAVE_LERC\nstatic double GTiffGetLERCMaxZError(char** papszOptions)\n{\n    return CPLAtof(CSLFetchNameValueDef( papszOptions, \"MAX_Z_ERROR\", \"0.0\") );\n}\n#endif\n\nstatic signed char GTiffGetWebPLevel(char** papszOptions)\n{\n    int nWebPLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"WEBP_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nWebPLevel = atoi( pszValue );\n        if( !(nWebPLevel \u003e= 1 \u0026\u0026 nWebPLevel \u003c= 100) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"WEBP_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nWebPLevel = -1;\n        }\n    }\n    return static_cast\u003csigned char\u003e(nWebPLevel);\n}\n\nstatic bool GTiffGetWebPLossless(char** papszOptions)\n{\n    return CPLFetchBool( papszOptions, \"WEBP_LOSSLESS\", false);\n}\n\nstatic signed char GTiffGetZLevel(char** papszOptions)\n{\n    int nZLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZLEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZLevel = atoi( pszValue );\n#ifdef TIFFTAG_DEFLATE_SUBCODEC\n        constexpr int nMaxLevel = 12;\n#ifndef LIBDEFLATE_SUPPORT\n        if( nZLevel \u003e 9 \u0026\u0026 nZLevel \u003c= nMaxLevel )\n        {\n            CPLDebug(\"GTiff\",\n                     \"ZLEVEL=%d not supported in a non-libdeflate enabled \"\n                     \"libtiff build. Capping to 9\",\n                     nZLevel);\n            nZLevel = 9;\n        }\n#endif\n#else\n        constexpr int nMaxLevel = 9;\n#endif\n        if( nZLevel \u003c 1 || nZLevel \u003e nMaxLevel )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZLEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZLevel = -1;\n        }\n    }\n    return static_cast\u003csigned char\u003e(nZLevel);\n}\n\nstatic signed char GTiffGetJpegQuality(char** papszOptions)\n{\n    int nJpegQuality = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"JPEG_QUALITY\" );\n    if( pszValue != nullptr )\n    {\n        nJpegQuality = atoi( pszValue );\n        if( nJpegQuality \u003c 1 || nJpegQuality \u003e 100 )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"JPEG_QUALITY=%s value not recognised, ignoring.\",\n                      pszValue );\n            nJpegQuality = -1;\n        }\n    }\n    return static_cast\u003csigned char\u003e(nJpegQuality);\n}\n\nstatic signed char GTiffGetJpegTablesMode(char** papszOptions)\n{\n    return static_cast\u003csigned char\u003e(\n        atoi(CSLFetchNameValueDef( papszOptions, \"JPEGTABLESMODE\",\n                                      CPLSPrintf(\"%d\",\n                                                knGTIFFJpegTablesModeDefault))));\n}\n\n/************************************************************************/\n/*                        GetDiscardLsbOption()                         */\n/************************************************************************/\n\nvoid GTiffDataset::GetDiscardLsbOption(char** papszOptions)\n{\n    const char* pszBits = CSLFetchNameValue( papszOptions, \"DISCARD_LSB\" );\n    if( pszBits == nullptr)\n        return;\n\n    if( m_nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        ReportError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on a paletted image\");\n        return;\n    }\n    if( !(m_nBitsPerSample == 8 || m_nBitsPerSample == 16 || m_nBitsPerSample == 32) )\n    {\n        ReportError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on non 8, 16 or 32 bits integer images\");\n        return;\n    }\n\n    char** papszTokens = CSLTokenizeString2( pszBits, \",\", 0 );\n    const int nTokens = CSLCount(papszTokens);\n    if( nTokens == 1 || nTokens == nBands )\n    {\n        m_panMaskOffsetLsb = static_cast\u003cMaskOffset*\u003e(CPLCalloc(nBands, sizeof(MaskOffset)));\n        for( int i = 0; i \u003c nBands; ++i )\n        {\n            int nBits = atoi(papszTokens[nTokens == 1 ? 0 : i]);\n            m_panMaskOffsetLsb[i].nMask = ~((1 \u003c\u003c nBits)-1);\n            if( nBits \u003e 1 )\n                m_panMaskOffsetLsb[i].nOffset = 1 \u003c\u003c (nBits - 1);\n        }\n    }\n    else\n    {\n        ReportError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored: wrong number of components\");\n    }\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                             GetProfile()                             */\n/************************************************************************/\n\nstatic GTiffProfile GetProfile(const char* pszProfile)\n{\n    GTiffProfile eProfile = GTiffProfile::GDALGEOTIFF;\n    if( pszProfile != nullptr )\n    {\n        if( EQUAL(pszProfile, szPROFILE_BASELINE) )\n            eProfile = GTiffProfile::BASELINE;\n        else if( EQUAL(pszProfile, szPROFILE_GeoTIFF) )\n            eProfile = GTiffProfile::GEOTIFF;\n        else if( !EQUAL(pszProfile, szPROFILE_GDALGeoTIFF) )\n        {\n            CPLError(CE_Warning, CPLE_NotSupported,\n                     \"Unsupported value for PROFILE: %s\", pszProfile);\n        }\n    }\n    return eProfile;\n}\n\n/************************************************************************/\n/*                            GTiffCreate()                             */\n/*                                                                      */\n/*      Shared functionality between GTiffDataset::Create() and         */\n/*      GTiffCreateCopy() for creating TIFF file based on a set of      */\n/*      options and a configuration.                                    */\n/************************************************************************/\n\nTIFF *GTiffDataset::CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int l_nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString\u0026 l_osTmpFilename )\n\n{\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Blow on a few errors.                                           */\n/* -------------------------------------------------------------------- */\n    if( nXSize \u003c 1 || nYSize \u003c 1 || l_nBands \u003c 1 )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n            \"Attempt to create %dx%dx%d TIFF file, but width, height and bands\"\n            \"must be positive.\",\n            nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n    if( l_nBands \u003e 65535 )\n    {\n        ReportError(pszFilename, CE_Failure, CPLE_AppDefined,\n                  \"Attempt to create %dx%dx%d TIFF file, but bands \"\n                  \"must be lesser or equal to 65535.\",\n                  nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Setup values based on options.                                  */\n/* -------------------------------------------------------------------- */\n    const GTiffProfile eProfile = GetProfile(\n        CSLFetchNameValue(papszParmList, \"PROFILE\"));\n\n    const bool bTiled = CPLFetchBool( papszParmList, \"TILED\", false );\n\n    int l_nBlockXSize = 0;\n    const char *pszValue = CSLFetchNameValue(papszParmList, \"BLOCKXSIZE\");\n    if( pszValue != nullptr )\n    {\n        l_nBlockXSize = atoi( pszValue );\n        if( l_nBlockXSize \u003c 0 )\n        {\n            ReportError( pszFilename,CE_Failure, CPLE_IllegalArg,\n                     \"Invalid value for BLOCKXSIZE\");\n            return nullptr;\n        }\n    }\n\n    int l_nBlockYSize = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"BLOCKYSIZE\");\n    if( pszValue != nullptr )\n    {\n        l_nBlockYSize = atoi( pszValue );\n        if( l_nBlockYSize \u003c 0 )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_IllegalArg,\n                     \"Invalid value for BLOCKYSIZE\");\n            return nullptr;\n        }\n    }\n\n    if( bTiled )\n    {\n        if( l_nBlockXSize == 0 )\n            l_nBlockXSize = 256;\n\n        if( l_nBlockYSize == 0 )\n            l_nBlockYSize = 256;\n    }\n\n    int nPlanar = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"INTERLEAVE\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"PIXEL\" ) )\n            nPlanar = PLANARCONFIG_CONTIG;\n        else if( EQUAL( pszValue, \"BAND\" ) )\n        {\n            nPlanar = PLANARCONFIG_SEPARATE;\n        }\n        else\n        {\n            ReportError( pszFilename,CE_Failure, CPLE_IllegalArg, \n                      \"INTERLEAVE=%s unsupported, value must be PIXEL or BAND.\",\n                      pszValue );\n            return nullptr;\n        }\n    }\n    else\n    {\n        nPlanar = PLANARCONFIG_CONTIG;\n    }\n\n    int l_nCompression = COMPRESSION_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"COMPRESS\" );\n    if( pszValue != nullptr )\n    {\n        l_nCompression = GTIFFGetCompressionMethod(pszValue, \"COMPRESS\");\n        if( l_nCompression \u003c 0 )\n            return nullptr;\n    }\n\n    int nPredictor = PREDICTOR_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"PREDICTOR\" );\n    if( pszValue != nullptr )\n        nPredictor = atoi( pszValue );\n\n    const int l_nZLevel = GTiffGetZLevel(papszParmList);\n    const int l_nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    const int l_nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    const int l_nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    const bool l_bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    const int l_nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    const int l_nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    const double l_dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Streaming related code                                          */\n/* -------------------------------------------------------------------- */\n    const CPLString osOriFilename(pszFilename);\n    bool bStreaming =\n        strcmp(pszFilename, \"/vsistdout/\") == 0 ||\n        CPLFetchBool(papszParmList, \"STREAMABLE_OUTPUT\", false);\n#ifdef S_ISFIFO\n    if( !bStreaming )\n    {\n        VSIStatBufL sStat;\n        if( VSIStatExL( pszFilename, \u0026sStat,\n                        VSI_STAT_EXISTS_FLAG | VSI_STAT_NATURE_FLAG) == 0 \u0026\u0026\n             S_ISFIFO(sStat.st_mode) )\n        {\n            bStreaming = true;\n        }\n    }\n#endif\n    if( bStreaming \u0026\u0026\n        !EQUAL( \"NONE\",\n                CSLFetchNameValueDef(papszParmList, \"COMPRESS\", \"NONE\")) )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n            \"Streaming only supported to uncompressed TIFF\" );\n        return nullptr;\n    }\n    if( bStreaming \u0026\u0026 CPLFetchBool(papszParmList, \"SPARSE_OK\", false) )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with SPARSE_OK\" );\n        return nullptr;\n    }\n    const bool bCopySrcOverviews = CPLFetchBool(papszParmList, \"COPY_SRC_OVERVIEWS\", false);\n    if( bStreaming \u0026\u0026 bCopySrcOverviews )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with COPY_SRC_OVERVIEWS\" );\n        return nullptr;\n    }\n    if( bStreaming )\n    {\n        static int nCounter = 0;\n        l_osTmpFilename = CPLSPrintf(\"/vsimem/vsistdout_%d.tif\", ++nCounter);\n        pszFilename = l_osTmpFilename.c_str();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Compute the uncompressed size.                                  */\n/* -------------------------------------------------------------------- */\n    const double dfUncompressedImageSize =\n        nXSize * static_cast\u003cdouble\u003e(nYSize) * l_nBands *\n        GDALGetDataTypeSizeBytes(eType)\n        + dfExtraSpaceForOverviews;\n\n/* -------------------------------------------------------------------- */\n/*      Should the file be created as a bigtiff file?                   */\n/* -------------------------------------------------------------------- */\n    const char *pszBIGTIFF = CSLFetchNameValue(papszParmList, \"BIGTIFF\");\n\n    if( pszBIGTIFF == nullptr )\n        pszBIGTIFF = \"IF_NEEDED\";\n\n    bool bCreateBigTIFF = false;\n    if( EQUAL(pszBIGTIFF, \"IF_NEEDED\") )\n    {\n        if( l_nCompression == COMPRESSION_NONE\n            \u0026\u0026 dfUncompressedImageSize \u003e 4200000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else if( EQUAL(pszBIGTIFF, \"IF_SAFER\") )\n    {\n        if( dfUncompressedImageSize \u003e 2000000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else\n    {\n        bCreateBigTIFF = CPLTestBool( pszBIGTIFF );\n        if( !bCreateBigTIFF \u0026\u0026 l_nCompression == COMPRESSION_NONE \u0026\u0026\n             dfUncompressedImageSize \u003e 4200000000.0 )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                \"The TIFF file will be larger than 4GB, so BigTIFF is \"\n                \"necessary.  Creation failed.\");\n            return nullptr;\n        }\n    }\n\n    if( bCreateBigTIFF )\n        CPLDebug( \"GTiff\", \"File being created as a BigTIFF.\" );\n\n/* -------------------------------------------------------------------- */\n/*      Sanity check.                                                   */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n    {\n        unsigned nTileXCount = DIV_ROUND_UP(nXSize, l_nBlockXSize);\n        unsigned nTileYCount = DIV_ROUND_UP(nYSize, l_nBlockYSize);\n        // libtiff implementation limitation\n        if( nTileXCount \u003e 0x80000000U / (bCreateBigTIFF ? 8 : 4) / nTileYCount )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                     \"File too large regarding tile size. This would result \"\n                     \"in a file with tile arrays larger than 2GB\");\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check free space (only for big, non sparse, uncompressed)       */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_NONE \u0026\u0026\n        dfUncompressedImageSize \u003e= 1e9 \u0026\u0026\n        !CPLFetchBool(papszParmList, \"SPARSE_OK\", false) \u0026\u0026\n        osOriFilename != \"/vsistdout/\" \u0026\u0026\n        osOriFilename != \"/vsistdout_redirect/\" \u0026\u0026\n        CPLTestBool(CPLGetConfigOption(\"CHECK_DISK_FREE_SPACE\", \"TRUE\")) )\n    {\n        GIntBig nFreeDiskSpace =\n            VSIGetDiskFreeSpace(CPLGetDirname(pszFilename));\n        if( nFreeDiskSpace \u003e= 0 \u0026\u0026\n            nFreeDiskSpace \u003c dfUncompressedImageSize )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_FileIO,\n                      \"Free disk space available is \" CPL_FRMT_GIB \" bytes, \"\n                      \"whereas \" CPL_FRMT_GIB \" are at least necessary. \"\n                      \"You can disable this check by defining the \"\n                      \"CHECK_DISK_FREE_SPACE configuration option to FALSE.\",\n                      nFreeDiskSpace,\n                      static_cast\u003cGIntBig\u003e(dfUncompressedImageSize) );\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check if the user wishes a particular endianness                */\n/* -------------------------------------------------------------------- */\n\n    int eEndianness = ENDIANNESS_NATIVE;\n    pszValue = CSLFetchNameValue(papszParmList, \"ENDIANNESS\");\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption( \"GDAL_TIFF_ENDIANNESS\", nullptr );\n    if( pszValue != nullptr )\n    {\n        if( EQUAL(pszValue, \"LITTLE\") )\n        {\n            eEndianness = ENDIANNESS_LITTLE;\n        }\n        else if( EQUAL(pszValue, \"BIG\") )\n        {\n            eEndianness = ENDIANNESS_BIG;\n        }\n        else if( EQUAL(pszValue, \"INVERTED\") )\n        {\n#ifdef CPL_LSB\n            eEndianness = ENDIANNESS_BIG;\n#else\n            eEndianness = ENDIANNESS_LITTLE;\n#endif\n        }\n        else if( !EQUAL(pszValue, \"NATIVE\") )\n        {\n            ReportError( pszFilename, CE_Warning, CPLE_NotSupported,\n                \"ENDIANNESS=%s not supported. Defaulting to NATIVE\", pszValue );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n\n    const bool bAppend = CPLFetchBool(papszParmList, \"APPEND_SUBDATASET\", false);\n\n    char szOpeningFlag[5] = {};\n    strcpy(szOpeningFlag, bAppend ? \"r+\" : \"w+\");\n    if( bCreateBigTIFF )\n        strcat(szOpeningFlag, \"8\");\n    if( eEndianness == ENDIANNESS_BIG )\n        strcat(szOpeningFlag, \"b\");\n    else if( eEndianness == ENDIANNESS_LITTLE )\n        strcat(szOpeningFlag, \"l\");\n\n    VSILFILE* l_fpL = VSIFOpenL( pszFilename, bAppend ? \"r+b\" : \"w+b\" );\n    if( l_fpL == nullptr )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"Attempt to create new tiff file `%s' failed: %s\",\n                  pszFilename, VSIStrerror(errno) );\n        return nullptr;\n    }\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, szOpeningFlag, l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        if( CPLGetLastErrorNo() == 0 )\n            CPLError( CE_Failure, CPLE_OpenFailed,\n                      \"Attempt to create new tiff file `%s' \"\n                      \"failed in XTIFFOpen().\",\n                      pszFilename );\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n    if( bAppend )\n    {\n        // This is a bit of a hack to cause (*tif-\u003etif_cleanup)(tif); to be called.\n        // See https://trac.osgeo.org/gdal/ticket/2055\n        TIFFSetField( l_hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_NONE );\n        TIFFFreeDirectory( l_hTIFF );\n        TIFFCreateDirectory( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      How many bits per sample?  We have a special case if NBITS      */\n/*      specified for GDT_Byte, GDT_UInt16, GDT_UInt32.                 */\n/* -------------------------------------------------------------------- */\n    int l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n    if( CSLFetchNameValue(papszParmList, \"NBITS\") != nullptr )\n    {\n        int nMinBits = 0;\n        int nMaxBits = 0;\n        l_nBitsPerSample = atoi(CSLFetchNameValue(papszParmList, \"NBITS\"));\n        if( eType == GDT_Byte )\n        {\n            nMinBits = 1;\n            nMaxBits = 8;\n        }\n        else if( eType == GDT_UInt16 )\n        {\n            nMinBits = 9;\n            nMaxBits = 16;\n        }\n        else if( eType == GDT_UInt32 )\n        {\n            nMinBits = 17;\n            nMaxBits = 32;\n        }\n        else if( eType == GDT_Float32 )\n        {\n            if( l_nBitsPerSample != 16 \u0026\u0026 l_nBitsPerSample != 32 )\n            {\n                ReportError( pszFilename, CE_Warning, CPLE_NotSupported,\n                     \"Only NBITS=16 is supported for data type Float32\");\n                l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n            }\n        }\n        else\n        {\n            ReportError( pszFilename, CE_Warning, CPLE_NotSupported,\n                     \"NBITS is not supported for data type %s\",\n                     GDALGetDataTypeName(eType));\n            l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n        }\n\n        if( nMinBits != 0 )\n        {\n            if( l_nBitsPerSample \u003c nMinBits )\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMinBits);\n                l_nBitsPerSample = nMinBits;\n            }\n            else if( l_nBitsPerSample \u003e nMaxBits )\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMaxBits);\n                l_nBitsPerSample = nMaxBits;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a custom pixel type (just used for signed byte now). */\n/* -------------------------------------------------------------------- */\n    const char *pszPixelType = CSLFetchNameValue( papszParmList, \"PIXELTYPE\" );\n    if( pszPixelType == nullptr )\n        pszPixelType = \"\";\n\n/* -------------------------------------------------------------------- */\n/*      Setup some standard flags.                                      */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, l_nBitsPerSample );\n\n    uint16 l_nSampleFormat = 0;\n    if( (eType == GDT_Byte \u0026\u0026 EQUAL(pszPixelType,\"SIGNEDBYTE\"))\n        || eType == GDT_Int16 || eType == GDT_Int32 )\n        l_nSampleFormat = SAMPLEFORMAT_INT;\n    else if( eType == GDT_CInt16 || eType == GDT_CInt32 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXINT;\n    else if( eType == GDT_Float32 || eType == GDT_Float64 )\n        l_nSampleFormat = SAMPLEFORMAT_IEEEFP;\n    else if( eType == GDT_CFloat32 || eType == GDT_CFloat64 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXIEEEFP;\n    else\n        l_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, l_nSampleFormat );\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLESPERPIXEL, l_nBands );\n    TIFFSetField( l_hTIFF, TIFFTAG_PLANARCONFIG, nPlanar );\n\n/* -------------------------------------------------------------------- */\n/*      Setup Photometric Interpretation. Take this value from the user */\n/*      passed option or guess correct value otherwise.                 */\n/* -------------------------------------------------------------------- */\n    int nSamplesAccountedFor = 1;\n    bool bForceColorTable = false;\n\n    pszValue = CSLFetchNameValue(papszParmList,\"PHOTOMETRIC\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"MINISBLACK\" ) )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISBLACK );\n        else if( EQUAL( pszValue, \"MINISWHITE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISWHITE );\n        }\n        else if( EQUAL( pszValue, \"PALETTE\" ))\n        {\n            if( eType == GDT_Byte || eType == GDT_UInt16 )\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                              PHOTOMETRIC_PALETTE );\n                nSamplesAccountedFor = 1;\n                bForceColorTable = true;\n            }\n            else\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                    \"PHOTOMETRIC=PALETTE only compatible with Byte or UInt16\" );\n            }\n        }\n        else if( EQUAL( pszValue, \"RGB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"CMYK\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED );\n            nSamplesAccountedFor = 4;\n        }\n        else if( EQUAL( pszValue, \"YCBCR\" ))\n        {\n            // Because of subsampling, setting YCBCR without JPEG compression\n            // leads to a crash currently. Would need to make\n            // GTiffRasterBand::IWriteBlock() aware of subsampling so that it\n            // doesn't overrun buffer size returned by libtiff.\n            if( l_nCompression != COMPRESSION_JPEG )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                         \"Currently, PHOTOMETRIC=YCBCR requires COMPRESS=JPEG\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            if( nPlanar == PLANARCONFIG_SEPARATE )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                         \"PHOTOMETRIC=YCBCR requires INTERLEAVE=PIXEL\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            // YCBCR strictly requires 3 bands. Not less, not more Issue an\n            // explicit error message as libtiff one is a bit cryptic:\n            // TIFFVStripSize64:Invalid td_samplesperpixel value.\n            if( l_nBands != 3 )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                    \"PHOTOMETRIC=YCBCR not supported on a %d-band raster: \"\n                    \"only compatible of a 3-band (RGB) raster\", l_nBands );\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR );\n            nSamplesAccountedFor = 3;\n\n            // Explicitly register the subsampling so that JPEGFixupTags\n            // is a no-op (helps for cloud optimized geotiffs)\n            TIFFSetField( l_hTIFF, TIFFTAG_YCBCRSUBSAMPLING, 2, 2 );\n        }\n        else if( EQUAL( pszValue, \"CIELAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ICCLAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ITULAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ITULAB );\n            nSamplesAccountedFor = 3;\n        }\n        else\n        {\n            ReportError( pszFilename,CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value not recognised, ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n\n        if( l_nBands \u003c nSamplesAccountedFor )\n        {\n            ReportError( pszFilename,CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value does not correspond to number \"\n                      \"of bands (%d), ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue, l_nBands );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n    }\n    else\n    {\n        // If image contains 3 or 4 bands and datatype is Byte then we will\n        // assume it is RGB. In all other cases assume it is MINISBLACK.\n        if( l_nBands == 3 \u0026\u0026 eType == GDT_Byte )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( l_nBands == 4 \u0026\u0026 eType == GDT_Byte )\n        {\n            uint16 v[1] = {\n                GTiffGetAlphaValue(CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   DEFAULT_ALPHA_TYPE)\n            };\n\n            TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 4;\n        }\n        else\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            nSamplesAccountedFor = 1;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there are extra samples, we need to mark them with an        */\n/*      appropriate extrasamples definition here.                       */\n/* -------------------------------------------------------------------- */\n    if( l_nBands \u003e nSamplesAccountedFor )\n    {\n        const int nExtraSamples = l_nBands - nSamplesAccountedFor;\n\n        uint16 *v = static_cast\u003cuint16 *\u003e(\n            CPLMalloc( sizeof(uint16) * nExtraSamples ) );\n\n        v[0] = GTiffGetAlphaValue( CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   EXTRASAMPLE_UNSPECIFIED );\n\n        for( int i = 1; i \u003c nExtraSamples; ++i )\n            v[i] = EXTRASAMPLE_UNSPECIFIED;\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples, v );\n\n        CPLFree(v);\n    }\n\n    // Set the ICC color profile.\n    if( eProfile != GTiffProfile::BASELINE )\n    {\n        SaveICCProfile(nullptr, l_hTIFF, papszParmList, l_nBitsPerSample);\n    }\n\n    // Set the compression method before asking the default strip size\n    // This is useful when translating to a JPEG-In-TIFF file where\n    // the default strip size is 8 or 16 depending on the photometric value.\n    TIFFSetField( l_hTIFF, TIFFTAG_COMPRESSION, l_nCompression );\n\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        const char* pszCompress =\n            CSLFetchNameValueDef( papszParmList, \"COMPRESS\", \"\" );\n        if( EQUAL(pszCompress , \"LERC_DEFLATE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                        LERC_ADD_COMPRESSION_DEFLATE );\n        }\n        else if( EQUAL(pszCompress, \"LERC_ZSTD\" ) )\n        {\n            if( TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                            LERC_ADD_COMPRESSION_ZSTD ) != 1 )\n            {\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n        }\n    }\n    // TODO later: take into account LERC version\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Setup tiling/stripping flags.                                   */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n    {\n        if( !TIFFSetField( l_hTIFF, TIFFTAG_TILEWIDTH, l_nBlockXSize ) ||\n            !TIFFSetField( l_hTIFF, TIFFTAG_TILELENGTH, l_nBlockYSize ) )\n        {\n            XTIFFClose(l_hTIFF);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n            return nullptr;\n        }\n    }\n    else\n    {\n        const uint32 l_nRowsPerStrip = std::min(nYSize,\n            l_nBlockYSize == 0\n            ? static_cast\u003cint\u003e(TIFFDefaultStripSize(l_hTIFF,0))\n            : l_nBlockYSize );\n\n        TIFFSetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP, l_nRowsPerStrip );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Set compression related tags.                                   */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_LZW ||\n         l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n         l_nCompression == COMPRESSION_ZSTD )\n        TIFFSetField( l_hTIFF, TIFFTAG_PREDICTOR, nPredictor );\n    if( l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        GTiffSetDeflateSubCodec(l_hTIFF);\n\n        if( l_nZLevel != -1 )\n            TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, l_nZLevel );\n    }\n    if( l_nCompression == COMPRESSION_JPEG \u0026\u0026 l_nJpegQuality != -1 )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, l_nJpegQuality );\n    if( l_nCompression == COMPRESSION_LZMA \u0026\u0026 l_nLZMAPreset != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, l_nLZMAPreset );\n    if( (l_nCompression == COMPRESSION_ZSTD ||\n         l_nCompression == COMPRESSION_LERC) \u0026\u0026 l_nZSTDLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, l_nZSTDLevel);\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, l_dfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP \u0026\u0026 l_nWebPLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, l_nWebPLevel);\n    if( l_nCompression == COMPRESSION_WEBP \u0026\u0026 l_bWebPLossless)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n\n    if( l_nCompression == COMPRESSION_JPEG )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, l_nJpegTablesMode );\n\n/* -------------------------------------------------------------------- */\n/*      If we forced production of a file with photometric=palette,     */\n/*      we need to push out a default color table.                      */\n/* -------------------------------------------------------------------- */\n    if( bForceColorTable )\n    {\n        const int nColors = eType == GDT_Byte ? 256 : 65536;\n\n        unsigned short *panTRed = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTGreen = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTBlue = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n\n        for( int iColor = 0; iColor \u003c nColors; ++iColor )\n        {\n            if( eType == GDT_Byte )\n            {\n                panTRed[iColor] = static_cast\u003cunsigned short\u003e(257 * iColor);\n                panTGreen[iColor] = static_cast\u003cunsigned short\u003e(257 * iColor);\n                panTBlue[iColor] = static_cast\u003cunsigned short\u003e(257 * iColor);\n            }\n            else\n            {\n                panTRed[iColor] = static_cast\u003cunsigned short\u003e(iColor);\n                panTGreen[iColor] = static_cast\u003cunsigned short\u003e(iColor);\n                panTBlue[iColor] = static_cast\u003cunsigned short\u003e(iColor);\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP,\n                      panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    if( l_nCompression == COMPRESSION_JPEG \u0026\u0026\n        !STARTS_WITH(pszFilename, szJPEGGTiffDatasetTmpPrefix) \u0026\u0026\n        CPLTestBool(\n            CSLFetchNameValueDef(papszParmList, \"WRITE_JPEGTABLE_TAG\", \"YES\")) )\n    {\n        GTiffWriteJPEGTables( l_hTIFF,\n                              CSLFetchNameValue(papszParmList, \"PHOTOMETRIC\"),\n                              CSLFetchNameValue(papszParmList, \"JPEG_QUALITY\"),\n                              CSLFetchNameValue(papszParmList,\n                                                \"JPEGTABLESMODE\") );\n    }\n\n    *pfpL = l_fpL;\n\n    return l_hTIFF;\n}\n\n/************************************************************************/\n/*                      GTiffWriteJPEGTables()                          */\n/*                                                                      */\n/*      Sets the TIFFTAG_JPEGTABLES (and TIFFTAG_REFERENCEBLACKWHITE)   */\n/*      tags immediately, instead of relying on the TIFF JPEG codec     */\n/*      to write them when it starts compressing imagery. This avoids   */\n/*      an IFD rewrite at the end of the file.                          */\n/*      Must be used after having set TIFFTAG_SAMPLESPERPIXEL,          */\n/*      TIFFTAG_BITSPERSAMPLE.                                          */\n/************************************************************************/\n\nvoid GTiffWriteJPEGTables( TIFF* hTIFF,\n                           const char* pszPhotometric,\n                           const char* pszJPEGQuality,\n                           const char* pszJPEGTablesMode )\n{\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    uint16 nBands = 0;\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL,\n                        \u0026nBands ) )\n        nBands = 1;\n\n    uint16 l_nBitsPerSample = 0;\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE,\n                        \u0026(l_nBitsPerSample)) )\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE* fpTmp = nullptr;\n    CPLString osTmp;\n    char** papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\" );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEG_QUALITY\",\n                                            pszJPEGQuality );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"PHOTOMETRIC\", pszPhotometric );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"BLOCKYSIZE\",\n                                            CPLSPrintf(\"%u\", nInMemImageHeight)\n                                          );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"NBITS\",\n                                            CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEGTABLESMODE\",\n                                            pszJPEGTablesMode );\n\n    TIFF* hTIFFTmp = GTiffDataset::CreateLL(\n                    osTmpFilenameIn, nInMemImageWidth, nInMemImageHeight,\n                    (nBands \u003c= 4) ? nBands : 1,\n                    (l_nBitsPerSample \u003c= 8) ? GDT_Byte : GDT_UInt16, 0.0,\n                    papszLocalParameters, \u0026fpTmp, osTmp );\n    CSLDestroy(papszLocalParameters);\n    if( hTIFFTmp )\n    {\n        uint16 l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField( hTIFFTmp, TIFFTAG_PHOTOMETRIC, \u0026(l_nPhotometric) );\n        TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                        \u0026nJpegTablesModeIn );\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if(l_nJpegQuality \u003e 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if( l_nPhotometric == PHOTOMETRIC_YCBCR\n            \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGCOLORMODE,\n                            JPEGCOLORMODE_RGB);\n        }\n        if( nJpegTablesModeIn \u003e= 0 )\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                            nJpegTablesModeIn);\n\n        GPtrDiff_t nBlockSize = static_cast\u003cGPtrDiff_t\u003e(nInMemImageWidth) * nInMemImageHeight *\n                                        ((nBands \u003c= 4) ? nBands : 1);\n        if( l_nBitsPerSample == 12 )\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector\u003cGByte\u003e abyZeroData( nBlockSize, 0 );\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, \u0026abyZeroData[0], nBlockSize);\n\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLES, \u0026nJPEGTableSize,\n                            \u0026pJPEGTable) )\n            TIFFSetField( hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize,\n                            pJPEGTable);\n\n        float *ref = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, \u0026ref) )\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n}\n\n/************************************************************************/\n/*                            GuessJPEGQuality()                        */\n/*                                                                      */\n/*      Guess JPEG quality from JPEGTABLES tag.                         */\n/************************************************************************/\n\nstatic const GByte* GTIFFFindNextTable( const GByte* paby, GByte byMarker,\n                                        int nLen, int* pnLenTable )\n{\n    for( int i = 0; i + 1 \u003c nLen; )\n    {\n        if( paby[i] != 0xFF )\n            return nullptr;\n        ++i;\n        if( paby[i] == 0xD8 )\n        {\n            ++i;\n            continue;\n        }\n        if( i + 2 \u003e= nLen )\n            return nullptr;\n        int nMarkerLen = paby[i+1] * 256 + paby[i+2];\n        if( i+1+nMarkerLen \u003e= nLen )\n            return nullptr;\n        if( paby[i] == byMarker )\n        {\n            if( pnLenTable ) *pnLenTable = nMarkerLen;\n            return paby + i + 1;\n        }\n        i += 1 + nMarkerLen;\n    }\n    return nullptr;\n}\n\n// We assume that if there are several quantization tables, they are\n// in the same order. Which is a reasonable assumption for updating\n// a file generated by ourselves.\nstatic bool GTIFFQuantizationTablesEqual( const GByte* paby1, int nLen1,\n                                          const GByte* paby2, int nLen2 )\n{\n    bool bFound = false;\n    while( true )\n    {\n        int nLenTable1 = 0;\n        int nLenTable2 = 0;\n        const GByte* paby1New =\n            GTIFFFindNextTable(paby1, 0xDB, nLen1, \u0026nLenTable1);\n        const GByte* paby2New =\n            GTIFFFindNextTable(paby2, 0xDB, nLen2, \u0026nLenTable2);\n        if( paby1New == nullptr \u0026\u0026 paby2New == nullptr )\n            return bFound;\n        if( paby1New == nullptr || paby2New == nullptr )\n            return false;\n        if( nLenTable1 != nLenTable2 )\n            return false;\n        if( memcmp(paby1New, paby2New, nLenTable1) != 0 )\n            return false;\n        paby1New += nLenTable1;\n        paby2New += nLenTable2;\n        nLen1 -= static_cast\u003cint\u003e(paby1New - paby1);\n        nLen2 -= static_cast\u003cint\u003e(paby2New - paby2);\n        paby1 = paby1New;\n        paby2 = paby2New;\n        bFound = true;\n    }\n}\n\nint GTiffDataset::GuessJPEGQuality( bool\u0026 bOutHasQuantizationTable,\n                                    bool\u0026 bOutHasHuffmanTable )\n{\n    CPLAssert( m_nCompression == COMPRESSION_JPEG );\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, \u0026nJPEGTableSize, \u0026pJPEGTable) )\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable( static_cast\u003cconst GByte*\u003e(pJPEGTable), 0xDB,\n                            nJPEGTableSize, nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable( static_cast\u003cconst GByte*\u003e(pJPEGTable), 0xC4,\n                            nJPEGTableSize, nullptr) != nullptr;\n    if( !bOutHasQuantizationTable )\n        return -1;\n\n    char** papszLocalParameters = nullptr;\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\");\n    if( m_nPhotometric == PHOTOMETRIC_YCBCR )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"YCBCR\");\n    else if( m_nPhotometric == PHOTOMETRIC_SEPARATED )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"BLOCKYSIZE\", \"16\");\n    if( m_nBitsPerSample == 12 )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf( \"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                            this );\n\n    int nRet = -1;\n    for( int nQuality = 0; nQuality \u003c= 100 \u0026\u0026 nRet \u003c 0; ++nQuality )\n    {\n        VSILFILE* fpTmp = nullptr;\n        if( nQuality == 0 )\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                   \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                \"JPEG_QUALITY\", CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF* hTIFFTmp =\n            CreateLL( osTmpFilenameIn, 16, 16, (nBands \u003c= 4) ? nBands : 1,\n                      GetRasterBand(1)-\u003eGetRasterDataType(), 0.0,\n                      papszLocalParameters, \u0026fpTmp, osTmp );\n        CPLPopErrorHandler();\n        if( !hTIFFTmp )\n        {\n            break;\n        }\n\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now reset jpegcolormode.\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR\n            \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16*16*4*3)/2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands \u003c= 4) ? nBands : 1) * m_nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32 nJPEGTableSizeTry = 0;\n        void* pJPEGTableTry = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES,\n                         \u0026nJPEGTableSizeTry, \u0026pJPEGTableTry) )\n        {\n            if( GTIFFQuantizationTablesEqual(\n                   static_cast\u003cGByte *\u003e(pJPEGTable), nJPEGTableSize,\n                   static_cast\u003cGByte *\u003e(pJPEGTableTry), nJPEGTableSizeTry) )\n            {\n                nRet = (nQuality == 0 ) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}\n\n/************************************************************************/\n/*               SetJPEGQualityAndTablesModeFromFile()                  */\n/************************************************************************/\n\nvoid GTiffDataset::SetJPEGQualityAndTablesModeFromFile()\n{\n    bool bHasQuantizationTable = false;\n    bool bHasHuffmanTable = false;\n    int nQuality = GuessJPEGQuality( bHasQuantizationTable,\n                                     bHasHuffmanTable );\n    if( nQuality \u003e 0 )\n    {\n        CPLDebug(\"GTiff\", \"Guessed JPEG quality to be %d\", nQuality);\n        m_nJpegQuality = static_cast\u003csigned char\u003e(nQuality);\n        TIFFSetField( m_hTIFF, TIFFTAG_JPEGQUALITY, nQuality );\n\n        // This means we will use the quantization tables from the\n        // JpegTables tag.\n        m_nJpegTablesMode = JPEGTABLESMODE_QUANT;\n    }\n    else\n    {\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_JPEGTABLES,\n                            \u0026nJPEGTableSize, \u0026pJPEGTable) )\n        {\n            toff_t *panByteCounts = nullptr;\n            const int nBlockCount =\n                m_nPlanarConfig == PLANARCONFIG_SEPARATE\n                ? m_nBlocksPerBand * nBands\n                : m_nBlocksPerBand;\n            if( TIFFIsTiled( m_hTIFF ) )\n                TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS,\n                                \u0026panByteCounts );\n            else\n                TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                                \u0026panByteCounts );\n\n            bool bFoundNonEmptyBlock = false;\n            if( panByteCounts != nullptr )\n            {\n                for( int iBlock = 0; iBlock \u003c nBlockCount; ++iBlock )\n                {\n                    if( panByteCounts[iBlock] != 0 )\n                    {\n                        bFoundNonEmptyBlock = true;\n                        break;\n                    }\n                }\n            }\n            if( bFoundNonEmptyBlock )\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality. \"\n                            \"JPEG tables are missing, so going in \"\n                            \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n                // Write quantization tables in each strile.\n                m_nJpegTablesMode = 0;\n            }\n        }\n        else\n        {\n            if( bHasQuantizationTable )\n            {\n                // FIXME in libtiff: this is likely going to cause issues\n                // since libtiff will reuse in each strile the number of\n                // the global quantization table, which is invalid.\n                CPLDebug(\n                    \"GTiff\", \"Could not guess JPEG quality although JPEG \"\n                    \"quantization tables are present, so going in \"\n                    \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality since JPEG \"\n                        \"quantization tables are not present, so going in \"\n                        \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n            }\n\n            // Write quantization tables in each strile.\n            m_nJpegTablesMode = 0;\n        }\n    }\n    if( bHasHuffmanTable )\n    {\n        // If there are Huffman tables in header use them, otherwise\n        // if we use optimized tables, libtiff will currently reuse\n        // the number of the Huffman tables of the header for the\n        // optimized version of each strile, which is illegal.\n        m_nJpegTablesMode |= JPEGTABLESMODE_HUFF;\n    }\n    if( m_nJpegTablesMode \u003e= 0 )\n        TIFFSetField( m_hTIFF, TIFFTAG_JPEGTABLESMODE,\n                        m_nJpegTablesMode);\n}\n\n/************************************************************************/\n/*                               Create()                               */\n/*                                                                      */\n/*      Create a new GeoTIFF or TIFF file.                              */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int l_nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    TIFF *l_hTIFF = CreateLL(\n        pszFilename,\n        nXSize, nYSize, l_nBands,\n        eType, 0, papszParmList, \u0026l_fpL, l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS-\u003em_hTIFF = l_hTIFF;\n    poDS-\u003em_fpL = l_fpL;\n    if( bStreaming )\n    {\n        poDS-\u003em_bStreamingOut = true;\n        poDS-\u003em_pszTmpFilename = CPLStrdup(l_osTmpFilename);\n        poDS-\u003em_fpToWrite = VSIFOpenL( pszFilename, \"wb\" );\n        if( poDS-\u003em_fpToWrite == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            delete poDS;\n            return nullptr;\n        }\n    }\n    poDS-\u003enRasterXSize = nXSize;\n    poDS-\u003enRasterYSize = nYSize;\n    poDS-\u003eeAccess = GA_Update;\n    poDS-\u003em_bCrystalized = false;\n    poDS-\u003em_nSamplesPerPixel = static_cast\u003cuint16\u003e(l_nBands);\n    poDS-\u003em_pszFilename = CPLStrdup(pszFilename);\n\n    // Don't try to load external metadata files (#6597).\n    poDS-\u003em_bIMDRPCMetadataLoaded = true;\n\n    // Avoid premature crystalization that will cause directory re-writing if\n    // GetProjectionRef() or GetGeoTransform() are called on the newly created\n    // GeoTIFF.\n    poDS-\u003em_bLookedForProjection = true;\n\n    TIFFGetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, \u0026(poDS-\u003em_nSampleFormat) );\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, \u0026(poDS-\u003em_nPlanarConfig) );\n    // Weird that we need this, but otherwise we get a Valgrind warning on\n    // tiff_write_124.\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, \u0026(poDS-\u003em_nPhotometric) ) )\n        poDS-\u003em_nPhotometric = PHOTOMETRIC_MINISBLACK;\n    TIFFGetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, \u0026(poDS-\u003em_nBitsPerSample) );\n    TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, \u0026(poDS-\u003em_nCompression) );\n\n    if( TIFFIsTiled(l_hTIFF) )\n    {\n        TIFFGetField( l_hTIFF, TIFFTAG_TILEWIDTH, \u0026(poDS-\u003em_nBlockXSize) );\n        TIFFGetField( l_hTIFF, TIFFTAG_TILELENGTH, \u0026(poDS-\u003em_nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           \u0026(poDS-\u003em_nRowsPerStrip) ) )\n            poDS-\u003em_nRowsPerStrip = 1;  // Dummy value.\n\n        poDS-\u003em_nBlockXSize = nXSize;\n        poDS-\u003em_nBlockYSize =\n            std::min( static_cast\u003cint\u003e(poDS-\u003em_nRowsPerStrip) , nYSize );\n    }\n\n    poDS-\u003em_nBlocksPerBand =\n        DIV_ROUND_UP(nYSize, poDS-\u003em_nBlockYSize)\n        * DIV_ROUND_UP(nXSize, poDS-\u003em_nBlockXSize);\n\n    poDS-\u003em_eProfile = GetProfile(\n        CSLFetchNameValue( papszParmList, \"PROFILE\" ) );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS-\u003em_nCompression == COMPRESSION_JPEG\n        \u0026\u0026 poDS-\u003em_nPhotometric == PHOTOMETRIC_YCBCR\n        \u0026\u0026 CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        int nColorMode = 0;\n\n        poDS-\u003eSetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\");\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, \u0026nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n#ifdef HAVE_LERC\n    if( poDS-\u003em_nCompression == COMPRESSION_LERC )\n    {\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_LERC_PARAMETERS, \u0026nLercParamCount,\n                          \u0026panLercParms ) \u0026\u0026\n            nLercParamCount == 2 )\n        {\n            memcpy( poDS-\u003em_anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(poDS-\u003em_anLercAddCompressionAndVersion) );\n        }\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( poDS-\u003em_nPhotometric == PHOTOMETRIC_PALETTE\n        \u0026\u0026 TIFFGetField( l_hTIFF, TIFFTAG_COLORMAP,\n                         \u0026panRed, \u0026panGreen, \u0026panBlue) )\n    {\n\n        poDS-\u003em_poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 \u003c\u003c poDS-\u003em_nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor \u003e= 0; iColor-- )\n        {\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast\u003cshort\u003e(panRed[iColor] / divisor),\n                static_cast\u003cshort\u003e(panGreen[iColor] / divisor),\n                static_cast\u003cshort\u003e(panBlue[iColor] / divisor),\n                static_cast\u003cshort\u003e(255)\n            };\n\n            poDS-\u003em_poColorTable-\u003eSetColorEntry( iColor, \u0026oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CPLFetchBool( papszParmList, \"SPARSE_OK\", false ) )\n        poDS-\u003em_bFillEmptyTilesAtClosing = true;\n\n    poDS-\u003em_bWriteEmptyTiles = bStreaming ||\n        (poDS-\u003em_nCompression != COMPRESSION_NONE \u0026\u0026\n         poDS-\u003em_bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed striped files in the\n    // right order and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset.\n    if( CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n         CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n    {\n        poDS-\u003em_bWriteEmptyTiles = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS-\u003em_papszCreationOptions = CSLDuplicate( papszParmList );\n\n    poDS-\u003em_nZLevel = GTiffGetZLevel(papszParmList);\n    poDS-\u003em_nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    poDS-\u003em_nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    poDS-\u003em_nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    poDS-\u003em_bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    poDS-\u003em_nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    poDS-\u003em_nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    poDS-\u003em_dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n    poDS-\u003eInitCreationOrOpenOptions(papszParmList);\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand \u003c l_nBands; ++iBand )\n    {\n        if( poDS-\u003em_nBitsPerSample == 8 ||\n            (poDS-\u003em_nBitsPerSample == 16 \u0026\u0026 eType != GDT_Float32) ||\n            poDS-\u003em_nBitsPerSample == 32 ||\n            poDS-\u003em_nBitsPerSample == 64 ||\n            poDS-\u003em_nBitsPerSample == 128)\n        {\n            poDS-\u003eSetBand( iBand + 1, new GTiffRasterBand( poDS, iBand + 1 ) );\n        }\n        else\n        {\n            poDS-\u003eSetBand( iBand + 1, new GTiffOddBitsBand( poDS, iBand + 1 ) );\n            poDS-\u003eGetRasterBand( iBand + 1 )-\u003e\n                SetMetadataItem( \"NBITS\",\n                                 CPLString().Printf(\"%d\",poDS-\u003em_nBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    poDS-\u003eGetDiscardLsbOption(papszParmList);\n\n    if( poDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 l_nBands != 1 )\n        poDS-\u003eSetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        poDS-\u003eSetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    poDS-\u003eoOvManager.Initialize( poDS, pszFilename );\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                           CopyImageryAndMask()                       */\n/************************************************************************/\n\nCPLErr GTiffDataset::CopyImageryAndMask(GTiffDataset* poDstDS,\n                                        GDALDataset* poSrcDS,\n                                        GDALRasterBand* poSrcMaskBand,\n                                        GDALProgressFunc pfnProgress,\n                                        void * pProgressData )\n{\n    CPLErr eErr = CE_None;\n\n    const auto eType = poDstDS-\u003eGetRasterBand(1)-\u003eGetRasterDataType();\n    const int nDataTypeSize = GDALGetDataTypeSizeBytes(eType);\n    const int l_nBands = poDstDS-\u003eGetRasterCount();\n    void *pBlockBuffer = VSI_MALLOC3_VERBOSE(\n        poDstDS-\u003em_nBlockXSize, poDstDS-\u003em_nBlockYSize, l_nBands * nDataTypeSize);\n    if( pBlockBuffer == nullptr )\n    {\n        eErr = CE_Failure;\n    }\n    const int nYSize = poDstDS-\u003enRasterYSize;\n    const int nXSize = poDstDS-\u003enRasterXSize;\n    const int nYBlocks = DIV_ROUND_UP(nYSize, poDstDS-\u003em_nBlockYSize);\n    const int nXBlocks = DIV_ROUND_UP(nXSize, poDstDS-\u003em_nBlockXSize);\n    const int nBlocks = nXBlocks * nYBlocks;\n\n    CPLAssert(l_nBands == 1 || poDstDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG );\n\n    const bool bIsOddBand =\n        dynamic_cast\u003cGTiffOddBitsBand*\u003e(poDstDS-\u003eGetRasterBand(1)) != nullptr;\n\n    if( poDstDS-\u003em_poMaskDS )\n    {\n        CPLAssert( poDstDS-\u003em_poMaskDS-\u003em_nBlockXSize == poDstDS-\u003em_nBlockXSize );\n        CPLAssert( poDstDS-\u003em_poMaskDS-\u003em_nBlockYSize == poDstDS-\u003em_nBlockYSize );\n    }\n\n    int iBlock = 0;\n    for( int iY = 0, nYBlock = 0; iY \u003c nYSize \u0026\u0026 eErr == CE_None;\n            iY = ((nYSize - iY \u003c poDstDS-\u003em_nBlockYSize) ? nYSize :\n                iY + poDstDS-\u003em_nBlockYSize),\n            nYBlock++ )\n    {\n        const int nReqYSize = std::min(nYSize - iY, poDstDS-\u003em_nBlockYSize);\n        for( int iX = 0, nXBlock = 0; iX \u003c nXSize \u0026\u0026 eErr == CE_None;\n                iX = ((nXSize - iX \u003c poDstDS-\u003em_nBlockXSize) ? nXSize :\n                    iX + poDstDS-\u003em_nBlockXSize),\n                nXBlock++ )\n        {\n            const int nReqXSize = std::min(nXSize - iX, poDstDS-\u003em_nBlockXSize);\n            if( nReqXSize \u003c poDstDS-\u003em_nBlockXSize ||\n                nReqYSize \u003c poDstDS-\u003em_nBlockYSize )\n            {\n                memset(pBlockBuffer, 0, static_cast\u003csize_t\u003e(\n                    poDstDS-\u003em_nBlockXSize) * poDstDS-\u003em_nBlockYSize *\n                    l_nBands * nDataTypeSize);\n            }\n\n            if( !bIsOddBand )\n            {\n                eErr = poSrcDS-\u003eRasterIO( GF_Read,\n                    iX, iY, nReqXSize, nReqYSize,\n                    pBlockBuffer, nReqXSize, nReqYSize,\n                    eType,\n                    l_nBands, nullptr,\n                    nDataTypeSize * l_nBands,\n                    poDstDS-\u003em_nBlockXSize * nDataTypeSize * l_nBands,\n                    nDataTypeSize,\n                    nullptr );\n                if( eErr == CE_None )\n                {\n                    eErr = poDstDS-\u003eWriteEncodedTileOrStrip(\n                        iBlock, pBlockBuffer, false);\n                }\n            }\n            else\n            {\n                // In the odd bit case, this is a bit messy to ensure\n                // the strile gets written synchronously.\n                // We load the content of the n-1 bands in the cache,\n                // and for the last band we invoke WriteBlock() directly\n                // We also force FlushBlockBuf()\n                std::vector\u003cGDALRasterBlock*\u003e apoLockedBlocks;\n                for( int i = 0; eErr == CE_None \u0026\u0026 i \u003c l_nBands - 1; i++ )\n                {\n                    auto poBlock = poDstDS-\u003eGetRasterBand(i+1)-\u003eGetLockedBlockRef(\n                        nXBlock, nYBlock, TRUE);\n                    if( poBlock )\n                    {\n                        eErr = poSrcDS-\u003eGetRasterBand(i+1)-\u003eRasterIO(\n                            GF_Read,\n                            iX, iY, nReqXSize, nReqYSize,\n                            poBlock-\u003eGetDataRef(), nReqXSize, nReqYSize,\n                            eType,\n                            nDataTypeSize,\n                            nDataTypeSize * poDstDS-\u003em_nBlockXSize, nullptr);\n                        poBlock-\u003eMarkDirty();\n                        apoLockedBlocks.emplace_back(poBlock);\n                    }\n                    else\n                    {\n                        eErr = CE_Failure;\n                    }\n                }\n                if( eErr == CE_None )\n                {\n                    eErr = poSrcDS-\u003eGetRasterBand(l_nBands)-\u003eRasterIO(\n                            GF_Read,\n                            iX, iY, nReqXSize, nReqYSize,\n                            pBlockBuffer, nReqXSize, nReqYSize,\n                            eType,\n                            nDataTypeSize,\n                            nDataTypeSize * poDstDS-\u003em_nBlockXSize, nullptr);\n                }\n                if( eErr == CE_None )\n                {\n                    // Avoid any attempt to load from disk\n                    poDstDS-\u003em_nLoadedBlock = iBlock;\n                    eErr = poDstDS-\u003eGetRasterBand(l_nBands)-\u003eWriteBlock(\n                        nXBlock, nYBlock, pBlockBuffer);\n                    if( eErr == CE_None )\n                        eErr = poDstDS-\u003eFlushBlockBuf();\n                }\n                for( auto poBlock: apoLockedBlocks )\n                {\n                    poBlock-\u003eMarkClean();\n                    poBlock-\u003eDropLock();\n                }\n            }\n\n            if( eErr == CE_None \u0026\u0026 poDstDS-\u003em_poMaskDS )\n            {\n                if( nReqXSize \u003c poDstDS-\u003em_nBlockXSize ||\n                    nReqYSize \u003c poDstDS-\u003em_nBlockYSize )\n                {\n                    memset(pBlockBuffer, 0,\n                            static_cast\u003csize_t\u003e(poDstDS-\u003em_nBlockXSize) *\n                            poDstDS-\u003em_nBlockYSize);\n                }\n                eErr = poSrcMaskBand-\u003eRasterIO(\n                    GF_Read,\n                    iX, iY, nReqXSize, nReqYSize,\n                    pBlockBuffer, nReqXSize, nReqYSize,\n                    GDT_Byte,\n                    1, poDstDS-\u003em_nBlockXSize, nullptr);\n                if( eErr == CE_None )\n                {\n                    // Avoid any attempt to load from disk\n                    poDstDS-\u003em_poMaskDS-\u003em_nLoadedBlock = iBlock;\n                    eErr = poDstDS-\u003em_poMaskDS-\u003eGetRasterBand(1)-\u003e\n                        WriteBlock(nXBlock, nYBlock, pBlockBuffer);\n                    if( eErr == CE_None )\n                        eErr = poDstDS-\u003em_poMaskDS-\u003eFlushBlockBuf();\n                }\n            }\n            if( poDstDS-\u003em_bWriteError )\n                eErr = CE_Failure;\n\n            iBlock ++;\n            if( pfnProgress \u0026\u0026 !pfnProgress(\n                static_cast\u003cdouble\u003e(iBlock) / nBlocks, nullptr, pProgressData) )\n            {\n                eErr = CE_Failure;\n            }\n        }\n    }\n    poDstDS-\u003eFlushCache(); // mostly to wait for thread completion\n    VSIFree(pBlockBuffer);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                             CreateCopy()                             */\n/************************************************************************/\n\nGDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS,\n                          int bStrict, char ** papszOptions,\n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    if( poSrcDS-\u003eGetRasterCount() == 0 )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return nullptr;\n    }\n\n    GDALRasterBand * const poPBand = poSrcDS-\u003eGetRasterBand(1);\n    const GDALDataType eType = poPBand-\u003eGetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    const int l_nBands = poSrcDS-\u003eGetRasterCount();\n    for( int iBand = 2; iBand \u003c= l_nBands; ++iBand )\n    {\n        if( eType != poSrcDS-\u003eGetRasterBand(iBand)-\u003eGetRasterDataType() )\n        {\n            if( bStrict )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n                return nullptr;\n            }\n            else\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const GTiffProfile eProfile = GetProfile(\n        CSLFetchNameValue(papszOptions, \"PROFILE\"));\n\n    const bool bGeoTIFF = eProfile != GTiffProfile::BASELINE;\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand-\u003eGetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != nullptr\n        \u0026\u0026 atoi(poPBand-\u003eGetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) \u003e 0\n        \u0026\u0026 CSLFetchNameValue( papszCreateOptions, \"NBITS\") == nullptr )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand-\u003eGetMetadataItem( \"NBITS\",\n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == nullptr\n        \u0026\u0026 eType == GDT_Byte\n        \u0026\u0026 poPBand-\u003eGetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\",\n                             poPBand-\u003eGetMetadataItem(\n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Color profile.  Copy from band metadata if found.              */\n/* -------------------------------------------------------------------- */\n    if( bGeoTIFF )\n    {\n        const char* pszOptionsMD[] = {\n            \"SOURCE_ICC_PROFILE\",\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\",\n            \"SOURCE_WHITEPOINT\",\n            \"TIFFTAG_TRANSFERFUNCTION_RED\",\n            \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n            \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\",\n            nullptr\n        };\n\n        // Copy all the tags.  Options will override tags in the source.\n        int i = 0;\n        while(pszOptionsMD[i] != nullptr)\n        {\n            char const *pszMD =\n                CSLFetchNameValue(papszOptions, pszOptionsMD[i]);\n            if( pszMD == nullptr )\n                pszMD = poSrcDS-\u003eGetMetadataItem( pszOptionsMD[i],\n                                                  \"COLOR_PROFILE\" );\n\n            if( (pszMD != nullptr) \u0026\u0026 !EQUAL(pszMD, \"\") )\n            {\n                papszCreateOptions =\n                    CSLSetNameValue( papszCreateOptions, pszOptionsMD[i],\n                                     pszMD );\n\n                // If an ICC profile exists, other tags are not needed.\n                if( EQUAL(pszOptionsMD[i], \"SOURCE_ICC_PROFILE\") )\n                    break;\n            }\n\n            ++i;\n        }\n    }\n\n    double dfExtraSpaceForOverviews = 0;\n    const bool bCopySrcOverviews = CPLFetchBool(papszCreateOptions, \"COPY_SRC_OVERVIEWS\", false);\n    std::unique_ptr\u003cGDALDataset\u003e poOvrDS;\n    int nSrcOverviews = 0;\n    if( bCopySrcOverviews )\n    {\n        const char* pszOvrDS = CSLFetchNameValue(papszCreateOptions, \"@OVERVIEW_DATASET\");\n        if( pszOvrDS )\n        {\n            // Empty string is used by COG driver to indicate that we want\n            // to ignore source overviews.\n            if( !EQUAL(pszOvrDS, \"\") )\n            {\n                poOvrDS.reset(GDALDataset::Open(pszOvrDS));\n                if( !poOvrDS )\n                {\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                if( poOvrDS-\u003eGetRasterCount() != l_nBands )\n                {\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                nSrcOverviews = poOvrDS-\u003eGetRasterBand(1)-\u003eGetOverviewCount() + 1;\n            }\n        }\n        else\n        {\n            nSrcOverviews = poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverviewCount();\n        }\n        if( nSrcOverviews )\n        {\n            for( int j = 1; j \u003c= l_nBands; ++j )\n            {\n                const int nOtherBandOverviewCount = poOvrDS ?\n                    poOvrDS-\u003eGetRasterBand(j)-\u003eGetOverviewCount() + 1:\n                    poSrcDS-\u003eGetRasterBand(j)-\u003eGetOverviewCount();\n                if( nOtherBandOverviewCount != nSrcOverviews )\n                {\n                    ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                        \"COPY_SRC_OVERVIEWS cannot be used when the bands have \"\n                        \"not the same number of overview levels.\" );\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                for( int i = 0; i \u003c nSrcOverviews; ++i )\n                {\n                    GDALRasterBand* poOvrBand = poOvrDS ?\n                        (i == 0 ? poOvrDS-\u003eGetRasterBand(j) :\n                                  poOvrDS-\u003eGetRasterBand(j)-\u003eGetOverview(i-1)) :\n                        poSrcDS-\u003eGetRasterBand(j)-\u003eGetOverview(i);\n                    if( poOvrBand == nullptr )\n                    {\n                        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when one \"\n                            \"overview band is NULL.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                    GDALRasterBand* poOvrFirstBand = poOvrDS ?\n                        (i == 0 ? poOvrDS-\u003eGetRasterBand(1) :\n                                  poOvrDS-\u003eGetRasterBand(1)-\u003eGetOverview(i-1)) :\n                        poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(i);\n                    if( poOvrBand-\u003eGetXSize() != poOvrFirstBand-\u003eGetXSize() ||\n                        poOvrBand-\u003eGetYSize() != poOvrFirstBand-\u003eGetYSize() )\n                    {\n                        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when the \"\n                            \"overview bands have not the same dimensions \"\n                            \"among bands.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                }\n            }\n\n            for( int i = 0; i \u003c nSrcOverviews; ++i )\n            {\n                GDALRasterBand* poOvrFirstBand = poOvrDS ?\n                        (i == 0 ? poOvrDS-\u003eGetRasterBand(1) :\n                                  poOvrDS-\u003eGetRasterBand(1)-\u003eGetOverview(i-1)) :\n                        poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(i);\n                dfExtraSpaceForOverviews +=\n                    static_cast\u003cdouble\u003e(\n                      poOvrFirstBand-\u003eGetXSize()) *\n                      poOvrFirstBand-\u003eGetYSize();\n            }\n            dfExtraSpaceForOverviews *=\n                                l_nBands * GDALGetDataTypeSizeBytes(eType);\n        }\n        else\n        {\n            CPLDebug(\"GTiff\", \"No source overviews to copy\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we use optimized way of copying from an input JPEG       */\n/*      dataset?                                                        */\n/* -------------------------------------------------------------------- */\n\n// TODO(schwehr): Refactor bDirectCopyFromJPEG to be a const.\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bDirectCopyFromJPEG = false;\n#endif\n\n    // Note: JPEG_DIRECT_COPY is not defined by default, because it is mainly\n    // useful for debugging purposes.\n#ifdef JPEG_DIRECT_COPY\n    if( CPLFetchBool(papszCreateOptions, \"JPEG_DIRECT_COPY\", false) \u0026\u0026\n        GTIFF_CanDirectCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug(\"GTiff\", \"Using special direct copy mode from a JPEG dataset\");\n\n        bDirectCopyFromJPEG = true;\n    }\n#endif\n\n#ifdef HAVE_LIBJPEG\n    bool bCopyFromJPEG = false;\n\n    // When CreateCopy'ing() from a JPEG dataset, and asking for COMPRESS=JPEG,\n    // use DCT coefficients (unless other options are incompatible, like\n    // strip/tile dimensions, specifying JPEG_QUALITY option, incompatible\n    // PHOTOMETRIC with the source colorspace, etc.) to avoid the lossy steps\n    // involved by decompression/recompression.\n    if( !bDirectCopyFromJPEG \u0026\u0026\n        GTIFF_CanCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug( \"GTiff\", \"Using special copy mode from a JPEG dataset\" );\n\n        bCopyFromJPEG = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      If the source is RGB, then set the PHOTOMETRIC=RGB value        */\n/* -------------------------------------------------------------------- */\n\n    const bool bForcePhotometric =\n        CSLFetchNameValue(papszOptions, \"PHOTOMETRIC\") != nullptr;\n\n    if( l_nBands \u003e= 3 \u0026\u0026 !bForcePhotometric \u0026\u0026\n#ifdef HAVE_LIBJPEG\n        !bCopyFromJPEG \u0026\u0026\n#endif\n        poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorInterpretation() == GCI_RedBand \u0026\u0026\n        poSrcDS-\u003eGetRasterBand(2)-\u003eGetColorInterpretation() == GCI_GreenBand \u0026\u0026\n        poSrcDS-\u003eGetRasterBand(3)-\u003eGetColorInterpretation() == GCI_BlueBand )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PHOTOMETRIC\", \"RGB\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n    const int nXSize = poSrcDS-\u003eGetRasterXSize();\n    const int nYSize = poSrcDS-\u003eGetRasterYSize();\n    TIFF *l_hTIFF =\n        CreateLL( pszFilename, nXSize, nYSize, l_nBands,\n                  eType, dfExtraSpaceForOverviews, papszCreateOptions, \u0026l_fpL,\n                  l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    CSLDestroy( papszCreateOptions );\n    papszCreateOptions = nullptr;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        return nullptr;\n    }\n\n    uint16 l_nPlanarConfig = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, \u0026l_nPlanarConfig );\n\n    uint16 l_nCompression = 0;\n\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, \u0026(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Set the alpha channel if it is the last one.                    */\n/* -------------------------------------------------------------------- */\n    if( poSrcDS-\u003eGetRasterBand(l_nBands)-\u003eGetColorInterpretation() ==\n        GCI_AlphaBand )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, \u0026count, \u0026v ) )\n        {\n            const int nBaseSamples = l_nBands - count;\n            if( l_nBands \u003e nBaseSamples \u0026\u0026 l_nBands - nBaseSamples - 1 \u003c count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast\u003cuint16 *\u003e(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                pasNewExtraSamples[l_nBands - nBaseSamples - 1] =\n                    GTiffGetAlphaValue(\n                        CPLGetConfigOption(\n                            \"GTIFF_ALPHA\",\n                            CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n                        DEFAULT_ALPHA_TYPE);\n\n                TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, count,\n                              pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( l_nBands \u003e= 3\n            \u0026\u0026 (poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorInterpretation()\n                == GCI_YCbCr_YBand)\n            \u0026\u0026 (poSrcDS-\u003eGetRasterBand(2)-\u003eGetColorInterpretation()\n                == GCI_YCbCr_CbBand)\n            \u0026\u0026 (poSrcDS-\u003eGetRasterBand(3)-\u003eGetColorInterpretation()\n                == GCI_YCbCr_CrBand) )\n        {\n            // Do nothing.\n        }\n        else\n        {\n            // Assume RGB if it is not explicitly YCbCr.\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( (l_nBands == 1 || l_nBands == 2) \u0026\u0026\n        poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable() != nullptr\n        \u0026\u0026 eType == GDT_Byte )\n    {\n        unsigned short anTRed[256] = { 0 };\n        unsigned short anTGreen[256] = { 0 };\n        unsigned short anTBlue[256] = { 0 };\n        GDALColorTable *poCT = poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable();\n\n        for( int iColor = 0; iColor \u003c 256; ++iColor )\n        {\n            if( iColor \u003c poCT-\u003eGetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT-\u003eGetColorEntryAsRGB( iColor, \u0026sRGB );\n\n                anTRed[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c1);\n                anTGreen[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c2);\n                anTBlue[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = 0;\n                anTGreen[iColor] = 0;\n                anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( (l_nBands == 1 || l_nBands == 2)\n             \u0026\u0026 poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable() != nullptr\n             \u0026\u0026 eType == GDT_UInt16 )\n    {\n        unsigned short *panTRed = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTGreen = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTBlue = static_cast\u003cunsigned short *\u003e(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n\n        GDALColorTable *poCT = poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable();\n\n        for( int iColor = 0; iColor \u003c 65536; ++iColor )\n        {\n            if( iColor \u003c poCT-\u003eGetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT-\u003eGetColorEntryAsRGB( iColor, \u0026sRGB );\n\n                panTRed[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c1);\n                panTGreen[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c2);\n                panTBlue[iColor] = static_cast\u003cunsigned short\u003e(257 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = 0;\n                panTGreen[iColor] = 0;\n                panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable() != nullptr )\n        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n            \"Unable to export color table to GeoTIFF file.  Color tables \"\n            \"can only be written to 1 band or 2 bands Byte or \"\n            \"UInt16 GeoTIFF files.\" );\n\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        uint16 l_nPhotometric = 0;\n        TIFFGetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, \u0026l_nPhotometric);\n        // Check done in tif_jpeg.c later, but not with a very clear error message\n        if( l_nPhotometric == PHOTOMETRIC_PALETTE )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                     \"JPEG compression not supported with paletted image\");\n            XTIFFClose( l_hTIFF );\n            VSIUnlink(l_osTmpFilename);\n            CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n            return nullptr;\n        }\n    }\n\n    if( l_nBands == 2\n        \u0026\u0026 poSrcDS-\u003eGetRasterBand(1)-\u003eGetColorTable() != nullptr\n        \u0026\u0026 (eType == GDT_Byte || eType == GDT_UInt16) )\n    {\n        uint16 v[1] = { EXTRASAMPLE_UNASSALPHA };\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v );\n    }\n\n    const int nMaskFlags = poSrcDS-\u003eGetRasterBand(1)-\u003eGetMaskFlags();\n    bool bCreateMask = false;\n    CPLString osHiddenStructuralMD;\n    if( (l_nBands == 1 || l_nPlanarConfig == PLANARCONFIG_CONTIG) \u0026\u0026\n        bCopySrcOverviews )\n    {\n        osHiddenStructuralMD += \"LAYOUT=IFDS_BEFORE_DATA\\n\";\n        osHiddenStructuralMD += \"BLOCK_ORDER=ROW_MAJOR\\n\";\n        osHiddenStructuralMD += \"BLOCK_LEADER=SIZE_AS_UINT4\\n\";\n        osHiddenStructuralMD += \"BLOCK_TRAILER=LAST_4_BYTES_REPEATED\\n\";\n        osHiddenStructuralMD += \"KNOWN_INCOMPATIBLE_EDITION=NO\\n \"; // Final space intended, so this can be replaced by YES\n    }\n    if( !(nMaskFlags \u0026 (GMF_ALL_VALID|GMF_ALPHA|GMF_NODATA) )\n        \u0026\u0026 (nMaskFlags \u0026 GMF_PER_DATASET) \u0026\u0026 !bStreaming )\n    {\n        bCreateMask = true;\n        if( GTiffDataset::MustCreateInternalMask() \u0026\u0026\n            !osHiddenStructuralMD.empty() )\n        {\n            osHiddenStructuralMD += \"MASK_INTERLEAVED_WITH_IMAGERY=YES\\n\";\n        }\n    }\n    if( !osHiddenStructuralMD.empty() )\n    {\n        const int nHiddenMDSize = static_cast\u003cint\u003e(osHiddenStructuralMD.size());\n        osHiddenStructuralMD = CPLOPrintf(\n            \"GDAL_STRUCTURAL_METADATA_SIZE=%06d bytes\\n\", nHiddenMDSize) + osHiddenStructuralMD;\n        VSI_TIFFWrite(l_hTIFF, osHiddenStructuralMD.c_str(), osHiddenStructuralMD.size());\n    }\n \n\n    // FIXME? libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    const bool bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, l_hTIFF, false, eProfile,\n                                         pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/*      Write NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( eProfile == GTiffProfile::GDALGEOTIFF )\n    {\n        int bSuccess = FALSE;\n        const double dfNoData =\n            poSrcDS-\u003eGetRasterBand(1)-\u003eGetNoDataValue( \u0026bSuccess );\n        if( bSuccess )\n            GTiffDataset::WriteNoDataValue( l_hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Are we addressing PixelIsPoint mode?                            */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    if( poSrcDS-\u003eGetMetadataItem( GDALMD_AREA_OR_POINT )\n        \u0026\u0026 EQUAL(poSrcDS-\u003eGetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const OGRSpatialReference* l_poSRS = nullptr;\n    double l_adfGeoTransform[6] = { 0.0 };\n\n    if( poSrcDS-\u003eGetGeoTransform( l_adfGeoTransform ) == CE_None )\n    {\n        if( bGeoTIFF )\n        {\n            l_poSRS = poSrcDS-\u003eGetSpatialRef();\n\n            if( l_adfGeoTransform[2] == 0.0 \u0026\u0026 l_adfGeoTransform[4] == 0.0\n                \u0026\u0026 l_adfGeoTransform[5] \u003c 0.0 )\n            {\n                double dfOffset = 0.0;\n                {\n                    // In the case the SRS has a vertical component and we have\n                    // a single band, encode its scale/offset in the GeoTIFF tags\n                    int bHasScale = FALSE;\n                    double dfScale =\n                        poSrcDS-\u003eGetRasterBand(1)-\u003eGetScale(\u0026bHasScale);\n                    int bHasOffset = FALSE;\n                    dfOffset =\n                        poSrcDS-\u003eGetRasterBand(1)-\u003eGetOffset(\u0026bHasOffset);\n                    const bool bApplyScaleOffset =\n                        l_poSRS \u0026\u0026 l_poSRS-\u003eIsVertical() \u0026\u0026\n                        poSrcDS-\u003eGetRasterCount() == 1;\n                    if( bApplyScaleOffset \u0026\u0026 !bHasScale )\n                        dfScale = 1.0;\n                    if( !bApplyScaleOffset || !bHasOffset )\n                        dfOffset = 0.0;\n                    const double adfPixelScale[3] = {\n                        l_adfGeoTransform[1], fabs(l_adfGeoTransform[5]),\n                        bApplyScaleOffset ? dfScale : 0.0 };\n\n                    TIFFSetField( l_hTIFF, TIFFTAG_GEOPIXELSCALE, 3,\n                                  adfPixelScale );\n                }\n\n                double adfTiePoints[6] = {\n                    0.0,\n                    0.0,\n                    0.0,\n                    l_adfGeoTransform[0],\n                    l_adfGeoTransform[3],\n                    dfOffset\n                };\n\n                if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n                {\n                    adfTiePoints[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfTiePoints[4] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double adfMatrix[16] = { 0.0 };\n\n                adfMatrix[0] = l_adfGeoTransform[1];\n                adfMatrix[1] = l_adfGeoTransform[2];\n                adfMatrix[3] = l_adfGeoTransform[0];\n                adfMatrix[4] = l_adfGeoTransform[4];\n                adfMatrix[5] = l_adfGeoTransform[5];\n                adfMatrix[7] = l_adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n\n                if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n                {\n                    adfMatrix[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfMatrix[7] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CPLFetchBool( papszOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", l_adfGeoTransform );\n        else if( CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", l_adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS-\u003eGetGCPCount() \u003e 0 \u0026\u0026 bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS-\u003eGetGCPs();\n        double *padfTiePoints = static_cast\u003cdouble *\u003e(\n            CPLMalloc(6 * sizeof(double) * poSrcDS-\u003eGetGCPCount()) );\n\n        for( int iGCP = 0; iGCP \u003c poSrcDS-\u003eGetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint \u0026\u0026 !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] -= 0.5;\n                padfTiePoints[iGCP*6+1] -= 0.5;\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                      6*poSrcDS-\u003eGetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n\n        l_poSRS = poSrcDS-\u003eGetGCPSpatialRef();\n\n        if( CPLFetchBool( papszOptions, \"TFW\", false )\n            || CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n        {\n            ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                \"TFW=ON or WORLDFILE=ON creation options are ignored when \"\n                \"GCPs are available\" );\n        }\n    }\n    else\n    {\n        l_poSRS = poSrcDS-\u003eGetSpatialRef();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy xml:XMP data                                               */\n/* -------------------------------------------------------------------- */\n    char **papszXMP = poSrcDS-\u003eGetMetadata(\"xml:XMP\");\n    if( papszXMP != nullptr \u0026\u0026 *papszXMP != nullptr )\n    {\n        int nTagSize = static_cast\u003cint\u003e(strlen(*papszXMP));\n        TIFFSetField( l_hTIFF, TIFFTAG_XMLPACKET, nTagSize, *papszXMP );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection = l_poSRS != nullptr;\n    bool bExportSRSToPAM = false;\n    if( (bHasProjection || bPixelIsPoint) \u0026\u0026 bGeoTIFF )\n    {\n        GTIF *psGTIF = GTiffDatasetGTIFNew( l_hTIFF );\n\n        if( bHasProjection )\n        {\n            char* pszWKT = nullptr;\n            OGRErr eErr;\n            {\n                CPLErrorStateBackuper oErrorStateBackuper;\n                CPLErrorHandlerPusher oErrorHandler(CPLQuietErrorHandler);\n                eErr = l_poSRS-\u003eexportToWkt(\u0026pszWKT);\n            }\n            if( eErr == OGRERR_NONE \u0026\u0026 strstr(pszWKT, \"custom_proj4\") == nullptr )\n            {\n                GTIFSetFromOGISDefnEx( psGTIF, pszWKT,\n                                    GetGTIFFKeysFlavor(papszOptions),\n                                    GetGeoTIFFVersion(papszOptions) );\n            }\n            else\n            {\n                bExportSRSToPAM = true;\n            }\n            CPLFree(pszWKT);\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet( psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                        RasterPixelIsPoint );\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n    bool l_bDontReloadFirstBlock = false;\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        GTIFF_CopyFromJPEG_WriteAdditionalTags(l_hTIFF,\n                                               poSrcDS);\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    if( bCopySrcOverviews )\n    {\n        TIFFDeferStrileArrayWriting( l_hTIFF );\n    }\n#endif\n    TIFFWriteCheck( l_hTIFF, TIFFIsTiled(l_hTIFF), \"GTiffCreateCopy()\" );\n    TIFFWriteDirectory( l_hTIFF );\n    if( bStreaming )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( l_hTIFF, 0 );\n        TIFFWriteDirectory( l_hTIFF );\n\n        if( VSIFSeekL( l_fpL, 0, SEEK_END ) != 0 )\n            ReportError(pszFilename, CE_Failure, CPLE_FileIO, \"Cannot seek\");\n        const int nSize = static_cast\u003cint\u003e( VSIFTellL(l_fpL) );\n\n        vsi_l_offset nDataLength = 0;\n        VSIGetMemFileBuffer( l_osTmpFilename, \u0026nDataLength, FALSE);\n        TIFFSetDirectory( l_hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( l_hTIFF, nSize );\n        TIFFWriteDirectory( l_hTIFF );\n    }\n    TIFFSetDirectory( l_hTIFF,\n                    static_cast\u003ctdir_t\u003e(TIFFNumberOfDirectories(l_hTIFF) - 1) );\n    const toff_t l_nDirOffset = TIFFCurrentDirOffset( l_hTIFF );\n    TIFFFlush( l_hTIFF );\n    XTIFFClose( l_hTIFF );\n\n    VSIFSeekL(l_fpL, 0, SEEK_SET);\n\n    // fpStreaming will assigned to the instance and not closed here.\n    VSILFILE *fpStreaming = nullptr;\n    if( bStreaming )\n    {\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( l_osTmpFilename, \u0026nDataLength, FALSE);\n        fpStreaming = VSIFOpenL( pszFilename, \"wb\" );\n        if( fpStreaming == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n            return nullptr;\n        }\n        if( static_cast\u003cvsi_l_offset\u003e(\n                VSIFWriteL( pabyBuffer, 1, static_cast\u003cint\u003e(nDataLength),\n                            fpStreaming ) ) != nDataLength )\n        {\n            ReportError(pszFilename, CE_Failure, CPLE_FileIO,\n                        \"Could not write %d bytes\",\n                        static_cast\u003cint\u003e(nDataLength) );\n            CPL_IGNORE_RET_VAL(VSIFCloseL( fpStreaming ));\n            VSIUnlink(l_osTmpFilename);\n            CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    l_hTIFF =\n        VSI_TIFFOpen( bStreaming ? l_osTmpFilename.c_str() : pszFilename,\n                      \"r+\",\n                      l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS-\u003eSetDescription( pszFilename );\n    poDS-\u003eeAccess = GA_Update;\n    poDS-\u003em_pszFilename = CPLStrdup(pszFilename);\n    poDS-\u003em_fpL = l_fpL;\n    poDS-\u003em_bIMDRPCMetadataLoaded = true;\n\n    const bool bAppend = CPLFetchBool(papszOptions, \"APPEND_SUBDATASET\", false);\n    if( poDS-\u003eOpenOffset( l_hTIFF,\n                          bAppend ? l_nDirOffset : TIFFCurrentDirOffset(l_hTIFF),\n                          GA_Update,\n                          false, // bAllowRGBAInterface\n                          true // bReadGeoTransform\n                         ) != CE_None )\n    {\n        delete poDS;\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        return nullptr;\n    }\n    poDS-\u003eoOvManager.Initialize( poDS, pszFilename );\n\n    if( bStreaming )\n    {\n        VSIUnlink(l_osTmpFilename);\n        poDS-\u003em_fpToWrite = fpStreaming;\n    }\n    poDS-\u003em_eProfile = eProfile;\n\n    int nCloneInfoFlags = GCIF_PAM_DEFAULT \u0026 ~GCIF_MASK;\n\n    // If we explicitly asked not to tag the alpha band as such, do not\n    // reintroduce this alpha color interpretation in PAM.\n    if( poSrcDS-\u003eGetRasterBand(l_nBands)-\u003eGetColorInterpretation() ==\n        GCI_AlphaBand \u0026\u0026\n        GTiffGetAlphaValue(\n            CPLGetConfigOption(\n                \"GTIFF_ALPHA\",\n                CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n            DEFAULT_ALPHA_TYPE) == EXTRASAMPLE_UNSPECIFIED )\n    {\n        nCloneInfoFlags \u0026= ~GCIF_COLORINTERP;\n    }\n    // Ignore source band color interpretation if requesting PHOTOMETRIC=RGB\n    else if( l_nBands \u003e= 3 \u0026\u0026\n        EQUAL(CSLFetchNameValueDef(papszOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") )\n    {\n        for( int i = 1; i \u003c= 3; i++)\n        {\n            poDS-\u003eGetRasterBand(i)-\u003eSetColorInterpretation(\n                static_cast\u003cGDALColorInterp\u003e(GCI_RedBand + (i-1)));\n        }\n        nCloneInfoFlags \u0026= ~GCIF_COLORINTERP;\n        if( !(l_nBands == 4 \u0026\u0026 CSLFetchNameValue(papszOptions, \"ALPHA\") != nullptr) )\n        {\n            for( int i = 4; i \u003c= l_nBands; i++)\n            {\n                poDS-\u003eGetRasterBand(i)-\u003eSetColorInterpretation(\n                    poSrcDS-\u003eGetRasterBand(i)-\u003eGetColorInterpretation());\n            }\n        }\n    }\n\n    CPLString osOldGTIFF_REPORT_COMPD_CSVal(\n        CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"\"));\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"YES\");\n    poDS-\u003eCloneInfo( poSrcDS, nCloneInfoFlags );\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\",\n        osOldGTIFF_REPORT_COMPD_CSVal.empty() ? nullptr :\n        osOldGTIFF_REPORT_COMPD_CSVal.c_str());\n\n    if( (!bGeoTIFF || bExportSRSToPAM) \u0026\u0026 (poDS-\u003eGetPamFlags() \u0026 GPF_DISABLED) == 0 )\n    {\n        // Copy georeferencing info to PAM if the profile is not GeoTIFF\n        poDS-\u003eGDALPamDataset::SetSpatialRef(poDS-\u003eGetSpatialRef());\n        double adfGeoTransform[6];\n        if( poDS-\u003eGetGeoTransform(adfGeoTransform) == CE_None )\n        {\n            poDS-\u003eGDALPamDataset::SetGeoTransform(adfGeoTransform);\n        }\n        poDS-\u003eGDALPamDataset::SetGCPs(poDS-\u003eGetGCPCount(),\n                                      poDS-\u003eGetGCPs(),\n                                      poDS-\u003eGetGCPSpatialRef());\n    }\n\n    poDS-\u003em_papszCreationOptions = CSLDuplicate( papszOptions );\n    poDS-\u003em_bDontReloadFirstBlock = l_bDontReloadFirstBlock;\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() does not merge metadata, it just replaces it        */\n/*      totally.  So we have to merge it.                               */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS-\u003eGetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS-\u003eGetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS-\u003eSetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    // Depending on the PHOTOMETRIC tag, the TIFF file may not have the same\n    // band count as the source. Will fail later in GDALDatasetCopyWholeRaster\n    // anyway.\n    for( int nBand = 1;\n         nBand \u003c= std::min(poDS-\u003eGetRasterCount(), poSrcDS-\u003eGetRasterCount()) ;\n         ++nBand )\n    {\n        GDALRasterBand* poSrcBand = poSrcDS-\u003eGetRasterBand(nBand);\n        GDALRasterBand* poDstBand = poDS-\u003eGetRasterBand(nBand);\n        papszSRC_MD = poSrcBand-\u003eGetMetadata();\n        papszDST_MD = CSLDuplicate(poDstBand-\u003eGetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDstBand-\u003eSetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n\n        char** papszCatNames = poSrcBand-\u003eGetCategoryNames();\n        if( nullptr != papszCatNames )\n            poDstBand-\u003eSetCategoryNames( papszCatNames );\n    }\n\n    l_hTIFF = static_cast\u003cTIFF *\u003e( poDS-\u003eGetInternalHandle(nullptr) );\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = poSrcDS-\u003eGetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            poDS-\u003eSetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Second chance: now that we have a PAM dataset, it is possible   */\n/*      to write metadata that we could not write as a TIFF tag.        */\n/* -------------------------------------------------------------------- */\n    if( !bHasWrittenMDInGeotiffTAG \u0026\u0026 !bStreaming )\n    {\n        GTiffDataset::WriteMetadata(\n            poDS, l_hTIFF, true, eProfile,\n            pszFilename, papszOptions,\n            true /* don't write RPC and IMD file again */ );\n    }\n\n    if( !bStreaming )\n        GTiffDataset::WriteRPC(\n            poDS, l_hTIFF, true, eProfile,\n            pszFilename, papszOptions,\n            true /* write only in PAM AND if needed */ );\n\n    // Propagate ISIS3 or VICAR metadata, but only as PAM metadata.\n    for( const char* pszMDD: { \"json:ISIS3\", \"json:VICAR\" } )\n    {\n        char **papszMD = poSrcDS-\u003eGetMetadata(pszMDD);\n        if( papszMD )\n        {\n            poDS-\u003eSetMetadata( papszMD, pszMDD);\n            poDS-\u003ePushMetadataToPam();\n        }\n    }\n\n    poDS-\u003em_bWriteCOGLayout = bCopySrcOverviews;\n\n    // To avoid unnecessary directory rewriting.\n    poDS-\u003em_bMetadataChanged = false;\n    poDS-\u003em_bGeoTIFFInfoChanged = false;\n    poDS-\u003em_bNoDataChanged = false;\n    poDS-\u003em_bForceUnsetGTOrGCPs = false;\n    poDS-\u003em_bForceUnsetProjection = false;\n    poDS-\u003em_bStreamingOut = bStreaming;\n\n    // Don't try to load external metadata files (#6597).\n    poDS-\u003em_bIMDRPCMetadataLoaded = true;\n\n    // We must re-set the compression level at this point, since it has been\n    // lost a few lines above when closing the newly create TIFF file The\n    // TIFFTAG_ZIPQUALITY \u0026 TIFFTAG_JPEGQUALITY are not store in the TIFF file.\n    // They are just TIFF session parameters.\n\n    poDS-\u003em_nZLevel = GTiffGetZLevel(papszOptions);\n    poDS-\u003em_nLZMAPreset = GTiffGetLZMAPreset(papszOptions);\n    poDS-\u003em_nZSTDLevel = GTiffGetZSTDPreset(papszOptions);\n    poDS-\u003em_nWebPLevel = GTiffGetWebPLevel(papszOptions);\n    poDS-\u003em_bWebPLossless = GTiffGetWebPLossless(papszOptions);\n    poDS-\u003em_nJpegQuality = GTiffGetJpegQuality(papszOptions);\n    poDS-\u003em_nJpegTablesMode = GTiffGetJpegTablesMode(papszOptions);\n    poDS-\u003eGetDiscardLsbOption(papszOptions);\n#if HAVE_LERC\n    poDS-\u003em_dfMaxZError = GTiffGetLERCMaxZError(papszOptions);\n#endif\n    poDS-\u003eInitCreationOrOpenOptions(papszOptions);\n\n    if( l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        GTiffSetDeflateSubCodec(l_hTIFF);\n\n        if( poDS-\u003em_nZLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, poDS-\u003em_nZLevel );\n        }\n    }\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( poDS-\u003em_nJpegQuality != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, poDS-\u003em_nJpegQuality );\n        }\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, poDS-\u003em_nJpegTablesMode );\n    }\n    if( l_nCompression == COMPRESSION_LZMA )\n    {\n        if( poDS-\u003em_nLZMAPreset != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, poDS-\u003em_nLZMAPreset );\n        }\n    }\n    if( l_nCompression == COMPRESSION_ZSTD ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        if( poDS-\u003em_nZSTDLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, poDS-\u003em_nZSTDLevel );\n        }\n    }\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, poDS-\u003em_dfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP )\n    {\n        if( poDS-\u003em_nWebPLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, poDS-\u003em_nWebPLevel );\n        }\n\n        if( poDS-\u003em_bWebPLossless)\n        {\n          TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, poDS-\u003em_bWebPLossless );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CPLFetchBool( papszOptions, \"SPARSE_OK\", false ) )\n        poDS-\u003em_bFillEmptyTilesAtClosing = true;\n\n    poDS-\u003em_bWriteEmptyTiles =\n        (bCopySrcOverviews \u0026\u0026 poDS-\u003em_bFillEmptyTilesAtClosing) ||\n        bStreaming ||\n        (poDS-\u003em_nCompression != COMPRESSION_NONE \u0026\u0026\n            poDS-\u003em_bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed striped files in the\n    // rightorder and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset\n    if( CPLTestBool( CSLFetchNameValueDef(\n                            papszOptions,\n                            \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n        CPLTestBool( CSLFetchNameValueDef(\n                            papszOptions,\n                            \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n    {\n        poDS-\u003em_bWriteEmptyTiles = true;\n    }\n\n    // Precreate (internal) mask, so that the IBuildOverviews() below\n    // has a chance to create also the overviews of the mask.\n    CPLErr eErr = CE_None;\n\n    if( bCreateMask )\n    {\n        eErr = poDS-\u003eCreateMaskBand( nMaskFlags );\n        if( poDS-\u003em_poMaskDS )\n        {\n            poDS-\u003em_poMaskDS-\u003em_bFillEmptyTilesAtClosing = poDS-\u003em_bFillEmptyTilesAtClosing;\n            poDS-\u003em_poMaskDS-\u003em_bWriteEmptyTiles = poDS-\u003em_bWriteEmptyTiles;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create and then copy existing overviews if requested            */\n/*  We do it such that all the IFDs are at the beginning of the file,   */\n/*  and that the imagery data for the smallest overview is written      */\n/*  first, that way the file is more usable when embedded in a          */\n/*  compressed stream.                                                  */\n/* -------------------------------------------------------------------- */\n\n    // For scaled progress due to overview copying.\n    const int nBandsWidthMask = l_nBands +  (bCreateMask ? 1 : 0);\n    double dfTotalPixels =\n        static_cast\u003cdouble\u003e(nXSize) * nYSize * nBandsWidthMask;\n    double dfCurPixels = 0;\n\n    if( eErr == CE_None \u0026\u0026 bCopySrcOverviews )\n    {\n        std::unique_ptr\u003cGDALDataset\u003e poMaskOvrDS;\n        const char* pszMaskOvrDS = CSLFetchNameValue(papszOptions, \"@MASK_OVERVIEW_DATASET\");\n        if( pszMaskOvrDS )\n        {\n            poMaskOvrDS.reset(GDALDataset::Open(pszMaskOvrDS));\n            if( !poMaskOvrDS )\n            {\n                delete poDS;\n                return nullptr;\n            }\n            if( poMaskOvrDS-\u003eGetRasterCount() != 1 )\n            {\n                delete poDS;\n                return nullptr;\n            }\n        }\n        if( nSrcOverviews )\n        {\n            eErr = poDS-\u003eCreateOverviewsFromSrcOverviews(poSrcDS, poOvrDS.get());\n\n            if( eErr == CE_None \u0026\u0026\n                (poMaskOvrDS != nullptr ||\n                 (poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(0) \u0026\u0026\n                  poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(0)-\u003eGetMaskFlags() == GMF_PER_DATASET)) )\n            {\n                int nOvrBlockXSize = 0;\n                int nOvrBlockYSize = 0;\n                GTIFFGetOverviewBlockSize(\n                    GDALRasterBand::ToHandle(poDS-\u003eGetRasterBand(1)),\n                    \u0026nOvrBlockXSize, \u0026nOvrBlockYSize);\n                eErr = poDS-\u003eCreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n            }\n        }\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n        TIFFForceStrileArrayWriting( poDS-\u003em_hTIFF );\n\n        if( poDS-\u003em_poMaskDS )\n        {\n            TIFFForceStrileArrayWriting( poDS-\u003em_poMaskDS-\u003em_hTIFF );\n        }\n\n        for( int i = 0; i \u003c poDS-\u003em_nOverviewCount; i++)\n        {\n            TIFFForceStrileArrayWriting( poDS-\u003em_papoOverviewDS[i]-\u003em_hTIFF );\n\n            if( poDS-\u003em_papoOverviewDS[i]-\u003em_poMaskDS )\n            {\n                TIFFForceStrileArrayWriting(\n                    poDS-\u003em_papoOverviewDS[i]-\u003em_poMaskDS-\u003em_hTIFF );\n            }\n        }\n#endif\n\n        if( eErr == CE_None \u0026\u0026 nSrcOverviews )\n        {\n            if( poDS-\u003em_nOverviewCount != nSrcOverviews )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                        \"Did only manage to instantiate %d overview levels, \"\n                        \"whereas source contains %d\",\n                        poDS-\u003em_nOverviewCount, nSrcOverviews);\n                eErr = CE_Failure;\n            }\n\n            for( int i = 0; eErr == CE_None \u0026\u0026 i \u003c nSrcOverviews; ++i )\n            {\n                GDALRasterBand* poOvrBand = poOvrDS ?\n                    (i == 0 ? poOvrDS-\u003eGetRasterBand(1) : poOvrDS-\u003eGetRasterBand(1)-\u003eGetOverview(i-1)) :\n                    poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(i);\n                const double dfOvrPixels =\n                    static_cast\u003cdouble\u003e(poOvrBand-\u003eGetXSize()) *\n                                poOvrBand-\u003eGetYSize();\n                dfTotalPixels += dfOvrPixels * l_nBands;\n                if( poOvrBand-\u003eGetMaskFlags() == GMF_PER_DATASET ||\n                    poMaskOvrDS != nullptr )\n                {\n                    dfTotalPixels += dfOvrPixels;\n                }\n                else if( i == 0 \u0026\u0026\n                         poDS-\u003eGetRasterBand(1)-\u003eGetMaskFlags() == GMF_PER_DATASET )\n                {\n                    ReportError( pszFilename, CE_Warning, CPLE_AppDefined,\n                             \"Source dataset has a mask band on full \"\n                             \"resolution, overviews on the regular bands, \"\n                             \"but lacks overviews on the mask band.\");\n                }\n            }\n\n            char* papszCopyWholeRasterOptions[2] = { nullptr, nullptr };\n            if( l_nCompression != COMPRESSION_NONE )\n                papszCopyWholeRasterOptions[0] =\n                    const_cast\u003cchar*\u003e( \"COMPRESSED=YES\" );\n            // Now copy the imagery.\n            // Begin with the smallest overview.\n            for( int iOvrLevel = nSrcOverviews - 1;\n                    eErr == CE_None \u0026\u0026 iOvrLevel \u003e= 0; --iOvrLevel )\n            {\n                auto poDstDS = poDS-\u003em_papoOverviewDS[iOvrLevel];\n\n                // Create a fake dataset with the source overview level so that\n                // GDALDatasetCopyWholeRaster can cope with it.\n                GDALDataset* poSrcOvrDS = poOvrDS ?\n                    (iOvrLevel == 0 ? poOvrDS.get() :\n                        GDALCreateOverviewDataset(poOvrDS.get(), iOvrLevel - 1, TRUE)) :\n                    GDALCreateOverviewDataset(poSrcDS, iOvrLevel, TRUE);\n                GDALRasterBand* poSrcOvrBand = poOvrDS ?\n                    (iOvrLevel == 0 ? poOvrDS-\u003eGetRasterBand(1):\n                        poOvrDS-\u003eGetRasterBand(1)-\u003eGetOverview(iOvrLevel - 1)) :\n                    poSrcDS-\u003eGetRasterBand(1)-\u003eGetOverview(iOvrLevel);\n                double dfNextCurPixels =\n                    dfCurPixels +\n                    static_cast\u003cdouble\u003e(poSrcOvrBand-\u003eGetXSize()) *\n                    poSrcOvrBand-\u003eGetYSize() * l_nBands;\n\n                poDstDS-\u003em_bBlockOrderRowMajor = true;\n                poDstDS-\u003em_bLeaderSizeAsUInt4 = true;\n                poDstDS-\u003em_bTrailerRepeatedLast4BytesRepeated = true;\n                poDstDS-\u003em_bFillEmptyTilesAtClosing = poDS-\u003em_bFillEmptyTilesAtClosing;\n                poDstDS-\u003em_bWriteEmptyTiles = poDS-\u003em_bWriteEmptyTiles;\n                GDALRasterBand* poSrcMaskBand = nullptr;\n                if( poDstDS-\u003em_poMaskDS )\n                {\n                    poDstDS-\u003em_poMaskDS-\u003em_bBlockOrderRowMajor = true;\n                    poDstDS-\u003em_poMaskDS-\u003em_bLeaderSizeAsUInt4 = true;\n                    poDstDS-\u003em_poMaskDS-\u003em_bTrailerRepeatedLast4BytesRepeated = true;\n                    poDstDS-\u003em_poMaskDS-\u003em_bFillEmptyTilesAtClosing = poDS-\u003em_bFillEmptyTilesAtClosing;\n                    poDstDS-\u003em_poMaskDS-\u003em_bWriteEmptyTiles = poDS-\u003em_bWriteEmptyTiles;\n\n                    poSrcMaskBand = poMaskOvrDS ?\n                        (iOvrLevel == 0 ? poMaskOvrDS-\u003eGetRasterBand(1) :\n                            poMaskOvrDS-\u003eGetRasterBand(1)-\u003eGetOverview(iOvrLevel - 1)) :\n                        poSrcOvrBand-\u003eGetMaskBand();\n                }\n\n                if( l_nBands == 1 || poDstDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG)\n                {\n                    if( poDstDS-\u003em_poMaskDS )\n                    {\n                        dfNextCurPixels +=\n                            static_cast\u003cdouble\u003e(poSrcOvrBand-\u003eGetXSize()) *\n                                                poSrcOvrBand-\u003eGetYSize();\n                    }\n                    void* pScaledData =\n                        GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                  dfNextCurPixels / dfTotalPixels,\n                                                  pfnProgress, pProgressData );\n\n                    eErr = CopyImageryAndMask(poDstDS, poSrcOvrDS,\n                                      poSrcMaskBand,\n                                      GDALScaledProgress, pScaledData);\n\n\n                    dfCurPixels = dfNextCurPixels;\n                    GDALDestroyScaledProgress(pScaledData);\n                }\n                else\n                {\n                    void* pScaledData =\n                        GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                dfNextCurPixels / dfTotalPixels,\n                                                pfnProgress, pProgressData );\n\n                    eErr =\n                        GDALDatasetCopyWholeRaster(\n                            GDALDataset::ToHandle(poSrcOvrDS),\n                            GDALDataset::ToHandle(poDstDS),\n                            papszCopyWholeRasterOptions,\n                            GDALScaledProgress, pScaledData );\n\n                    dfCurPixels = dfNextCurPixels;\n                    GDALDestroyScaledProgress(pScaledData);\n\n                    poDstDS-\u003eFlushCache();\n\n                    // Copy mask of the overview.\n                    if( eErr == CE_None \u0026\u0026\n                        (poMaskOvrDS ||\n                         poSrcOvrBand-\u003eGetMaskFlags() == GMF_PER_DATASET) \u0026\u0026\n                        poDstDS-\u003em_poMaskDS != nullptr )\n                    {\n                        dfNextCurPixels +=\n                            static_cast\u003cdouble\u003e(poSrcOvrBand-\u003eGetXSize()) *\n                                                poSrcOvrBand-\u003eGetYSize();\n                        pScaledData =\n                            GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                dfNextCurPixels / dfTotalPixels,\n                                                pfnProgress, pProgressData );\n                        eErr =\n                            GDALRasterBandCopyWholeRaster(\n                                poSrcMaskBand,\n                                poDstDS-\u003em_poMaskDS-\u003eGetRasterBand(1),\n                                papszCopyWholeRasterOptions,\n                                GDALScaledProgress, pScaledData );\n                        dfCurPixels = dfNextCurPixels;\n                        GDALDestroyScaledProgress(pScaledData);\n                        poDstDS-\u003em_poMaskDS-\u003eFlushCache();\n                    }\n                }\n\n                if( poSrcOvrDS != poOvrDS.get() )\n                    delete poSrcOvrDS;\n                poSrcOvrDS = nullptr;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n    double dfNextCurPixels =\n        dfCurPixels + static_cast\u003cdouble\u003e(nXSize) * nYSize * l_nBands;\n    void* pScaledData = GDALCreateScaledProgress(\n        dfCurPixels / dfTotalPixels,\n        dfNextCurPixels / dfTotalPixels,\n        pfnProgress, pProgressData);\n\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bTryCopy = true;\n#endif\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        eErr = GTIFF_CopyFromJPEG( poDS, poSrcDS,\n                                   pfnProgress, pProgressData,\n                                   bTryCopy );\n\n        // In case of failure in the decompression step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n#ifdef JPEG_DIRECT_COPY\n    if( bDirectCopyFromJPEG )\n    {\n        eErr = GTIFF_DirectCopyFromJPEG(poDS, poSrcDS,\n                                        pfnProgress, pProgressData,\n                                        bTryCopy);\n\n        // In case of failure in the reading step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n    bool bWriteMask = true;\n    if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy \u0026\u0026\n#endif\n        (poDS-\u003em_bTreatAsSplit || poDS-\u003em_bTreatAsSplitBitmap) )\n    {\n        // For split bands, we use TIFFWriteScanline() interface.\n        CPLAssert(poDS-\u003em_nBitsPerSample == 8 || poDS-\u003em_nBitsPerSample == 1);\n\n        if( poDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 poDS-\u003enBands \u003e 1 )\n        {\n            GByte* pabyScanline =\n                static_cast\u003cGByte *\u003e(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(l_hTIFF)) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            for( int j = 0; j \u003c nYSize \u0026\u0026 eErr == CE_None; ++j )\n            {\n                eErr =\n                    poSrcDS-\u003eRasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, l_nBands, nullptr, poDS-\u003enBands, 0, 1,\n                        nullptr );\n                if( eErr == CE_None \u0026\u0026\n                    TIFFWriteScanline( l_hTIFF, pabyScanline, j, 0) == -1 )\n                {\n                    ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !GDALScaledProgress( (j + 1) * 1.0 / nYSize,\n                                         nullptr, pScaledData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree( pabyScanline );\n        }\n        else\n        {\n            GByte* pabyScanline = static_cast\u003cGByte *\u003e(\n                VSI_MALLOC_VERBOSE(nXSize) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            else\n                eErr = CE_None;\n            for( int iBand = 1; iBand \u003c= l_nBands \u0026\u0026 eErr == CE_None; ++iBand )\n            {\n                for( int j = 0; j \u003c nYSize \u0026\u0026 eErr == CE_None; ++j )\n                {\n                    eErr = poSrcDS-\u003eGetRasterBand(iBand)-\u003eRasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, 0, 0, nullptr );\n                    if( poDS-\u003em_bTreatAsSplitBitmap )\n                    {\n                        for( int i = 0; i \u003c nXSize; ++i )\n                        {\n                            const GByte byVal = pabyScanline[i];\n                            if( (i \u0026 0x7) == 0 )\n                                pabyScanline[i \u003e\u003e 3] = 0;\n                            if( byVal )\n                                pabyScanline[i \u003e\u003e 3] |= 0x80 \u003e\u003e (i \u0026 0x7);\n                        }\n                    }\n                    if( eErr == CE_None \u0026\u0026\n                        TIFFWriteScanline(\n                            l_hTIFF, pabyScanline, j,\n                            static_cast\u003cuint16\u003e(iBand - 1)) == -1 )\n                    {\n                        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !GDALScaledProgress(\n                           (j + 1 + (iBand - 1) * nYSize) * 1.0 /\n                           (l_nBands * nYSize),\n                           nullptr, pScaledData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n\n        // Necessary to be able to read the file without re-opening.\n        TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( l_hTIFF );\n\n        TIFFFlushData( l_hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( l_hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n\n        TIFFFlush( l_hTIFF );\n\n        if( poDS-\u003em_nDirOffset != TIFFCurrentDirOffset( l_hTIFF ) )\n        {\n            poDS-\u003em_nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\", \"directory moved during flush.\" );\n        }\n    }\n    else if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy \u0026\u0026\n#endif\n        eErr == CE_None )\n    {\n        const char* papszCopyWholeRasterOptions[3] = { nullptr, nullptr, nullptr };\n        int iNextOption = 0;\n        papszCopyWholeRasterOptions[iNextOption++] =\n                \"SKIP_HOLES=YES\" ;\n        if( l_nCompression != COMPRESSION_NONE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                \"COMPRESSED=YES\";\n        }\n        // For streaming with separate, we really want that bands are written\n        // after each other, even if the source is pixel interleaved.\n        else if( bStreaming \u0026\u0026 poDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                \"INTERLEAVE=BAND\";\n        }\n\n        if( bCopySrcOverviews \u0026\u0026\n            (l_nBands == 1 || poDS-\u003em_nPlanarConfig == PLANARCONFIG_CONTIG) )\n        {\n            poDS-\u003em_bBlockOrderRowMajor = true;\n            poDS-\u003em_bLeaderSizeAsUInt4 = true;\n            poDS-\u003em_bTrailerRepeatedLast4BytesRepeated = true;\n            if( poDS-\u003em_poMaskDS )\n            {\n                poDS-\u003em_poMaskDS-\u003em_bBlockOrderRowMajor = true;\n                poDS-\u003em_poMaskDS-\u003em_bLeaderSizeAsUInt4 = true;\n                poDS-\u003em_poMaskDS-\u003em_bTrailerRepeatedLast4BytesRepeated = true;\n            }\n\n            if( poDS-\u003em_poMaskDS )\n            {\n                GDALDestroyScaledProgress(pScaledData);\n                pScaledData = GDALCreateScaledProgress(\n                                dfCurPixels / dfTotalPixels,\n                                1.0,\n                                pfnProgress, pProgressData);\n            }\n\n            eErr = CopyImageryAndMask(poDS, poSrcDS,\n                              poSrcDS-\u003eGetRasterBand(1)-\u003eGetMaskBand(),\n                              GDALScaledProgress, pScaledData);\n            if( poDS-\u003em_poMaskDS )\n            {\n                bWriteMask = false;\n            }\n        }\n        else\n        {\n            eErr = GDALDatasetCopyWholeRaster(\n                /* (GDALDatasetH) */ poSrcDS,\n                /* (GDALDatasetH) */ poDS,\n                papszCopyWholeRasterOptions,\n                GDALScaledProgress, pScaledData );\n        }\n    }\n\n    GDALDestroyScaledProgress(pScaledData);\n\n    if( eErr == CE_None \u0026\u0026 !bStreaming \u0026\u0026 bWriteMask )\n    {\n        pScaledData = GDALCreateScaledProgress(\n            dfNextCurPixels / dfTotalPixels,\n            1.0,\n            pfnProgress, pProgressData);\n        if( poDS-\u003em_poMaskDS )\n        {\n            const char* l_papszOptions[2] = { \"COMPRESSED=YES\", nullptr };\n            eErr = GDALRasterBandCopyWholeRaster(\n                                    poSrcDS-\u003eGetRasterBand(1)-\u003eGetMaskBand(),\n                                    poDS-\u003eGetRasterBand(1)-\u003eGetMaskBand(),\n                                    const_cast\u003cchar **\u003e(l_papszOptions),\n                                    GDALScaledProgress, pScaledData );\n        }\n        else\n        {\n            eErr = GDALDriver::DefaultCopyMasks( poSrcDS, poDS, bStrict,\n                                                 nullptr,\n                                                 GDALScaledProgress, pScaledData );\n        }\n        GDALDestroyScaledProgress(pScaledData);\n    }\n\n    poDS-\u003em_bWriteCOGLayout = false;\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = nullptr;\n\n        if( CPLTestBool(CPLGetConfigOption(\"GTIFF_DELETE_ON_ERROR\", \"YES\")) )\n        {\n            if( !bStreaming )\n            {\n                // Should really delete more carefully.\n                VSIUnlink( pszFilename );\n            }\n        }\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                          GetSpatialRef()                             */\n/************************************************************************/\n\nconst OGRSpatialReference* GTiffDataset::GetSpatialRef() const\n\n{\n    if( m_nGCPCount == 0 )\n    {\n        const_cast\u003cGTiffDataset*\u003e(this)-\u003eLoadGeoreferencingAndPamIfNeeded();\n        const_cast\u003cGTiffDataset*\u003e(this)-\u003eLookForProjection();\n\n        return m_oSRS.IsEmpty() ? nullptr : \u0026m_oSRS;\n    }\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           SetSpatialRef()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetSpatialRef( const OGRSpatialReference * poSRS )\n\n{\n    if( m_bStreamingOut \u0026\u0026 m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify projection at that point in \"\n            \"a streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n    LookForProjection();\n\n    if( poSRS == nullptr || poSRS-\u003eIsEmpty() )\n    {\n        if( !m_oSRS.IsEmpty() )\n        {\n            m_bForceUnsetProjection = true;\n        }\n        m_oSRS.Clear();\n    }\n    else\n    {\n        m_oSRS = *poSRS;\n        m_oSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n    }\n\n    m_bGeoTIFFInfoChanged = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          GetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::GetGeoTransform( double * padfTransform )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    memcpy( padfTransform, m_adfGeoTransform, sizeof(double) * 6 );\n\n    if( !m_bGeoTransformValid )\n        return CE_Failure;\n\n    // Same logic as in the .gtx driver, for the benefit of GDALOpenVerticalShiftGrid()\n    // when used with PROJ-data's US geoids.\n    if( CPLFetchBool(papszOpenOptions,\n                                \"SHIFT_ORIGIN_IN_MINUS_180_PLUS_180\", false) )\n    {\n        if( padfTransform[0] \u003c -180.0 - padfTransform[1] )\n            padfTransform[0] += 360.0;\n        else if( padfTransform[0] \u003e 180.0 )\n            padfTransform[0] -= 360.0;\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          SetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGeoTransform( double * padfTransform )\n\n{\n    if( m_bStreamingOut \u0026\u0026 m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify geotransform at that point in a \"\n            \"streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        if( m_nGCPCount \u003e 0 )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                     \"GCPs previously set are going to be cleared \"\n                     \"due to the setting of a geotransform.\");\n            m_bForceUnsetGTOrGCPs = true;\n            GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n            CPLFree( m_pasGCPList );\n            m_nGCPCount = 0;\n            m_pasGCPList = nullptr;\n        }\n        else if( padfTransform[0] == 0.0 \u0026\u0026\n                 padfTransform[1] == 0.0 \u0026\u0026\n                 padfTransform[2] == 0.0 \u0026\u0026\n                 padfTransform[3] == 0.0 \u0026\u0026\n                 padfTransform[4] == 0.0 \u0026\u0026\n                 padfTransform[5] == 0.0 )\n        {\n            if( m_bGeoTransformValid )\n            {\n                m_bForceUnsetGTOrGCPs = true;\n                m_bGeoTIFFInfoChanged = true;\n            }\n            m_bGeoTransformValid = false;\n            memcpy( m_adfGeoTransform, padfTransform, sizeof(double)*6 );\n            return CE_None;\n        }\n\n        memcpy( m_adfGeoTransform, padfTransform, sizeof(double)*6 );\n        m_bGeoTransformValid = true;\n        m_bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Attempt to call SetGeoTransform() on a read-only GeoTIFF file.\" );\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                            GetGCPCount()                             */\n/************************************************************************/\n\nint GTiffDataset::GetGCPCount()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return m_nGCPCount;\n}\n\n/************************************************************************/\n/*                          GetGCPSpatialRef()                          */\n/************************************************************************/\n\nconst OGRSpatialReference *GTiffDataset::GetGCPSpatialRef() const\n\n{\n    const_cast\u003cGTiffDataset*\u003e(this)-\u003eLoadGeoreferencingAndPamIfNeeded();\n\n    if( m_nGCPCount \u003e 0 )\n    {\n        const_cast\u003cGTiffDataset*\u003e(this)-\u003eLookForProjection();\n    }\n    if( !m_oSRS.IsEmpty() )\n        return \u0026m_oSRS;\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                               GetGCPs()                              */\n/************************************************************************/\n\nconst GDAL_GCP *GTiffDataset::GetGCPs()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return m_pasGCPList;\n}\n\n/************************************************************************/\n/*                               SetGCPs()                              */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGCPs( int nGCPCountIn, const GDAL_GCP *pasGCPListIn,\n                              const OGRSpatialReference *poGCPSRS )\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        LookForProjection();\n\n        if( m_nGCPCount \u003e 0 \u0026\u0026 nGCPCountIn == 0 )\n        {\n            m_bForceUnsetGTOrGCPs = true;\n        }\n        else if( nGCPCountIn \u003e 0 \u0026\u0026\n                 m_bGeoTransformValid )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                     \"A geotransform previously set is going to be cleared \"\n                     \"due to the setting of GCPs.\");\n            m_adfGeoTransform[0] = 0.0;\n            m_adfGeoTransform[1] = 1.0;\n            m_adfGeoTransform[2] = 0.0;\n            m_adfGeoTransform[3] = 0.0;\n            m_adfGeoTransform[4] = 0.0;\n            m_adfGeoTransform[5] = 1.0;\n            m_bGeoTransformValid = false;\n            m_bForceUnsetGTOrGCPs = true;\n        }\n\n        if( poGCPSRS == nullptr || poGCPSRS-\u003eIsEmpty() )\n        {\n            if( !m_oSRS.IsEmpty() )\n            {\n                m_bForceUnsetProjection = true;\n            }\n            m_oSRS.Clear();\n        }\n        else\n        {\n            m_oSRS = *poGCPSRS;\n            m_oSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n        }\n\n        if( m_nGCPCount \u003e 0 )\n        {\n            GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n            CPLFree( m_pasGCPList );\n        }\n\n        m_nGCPCount = nGCPCountIn;\n        m_pasGCPList = GDALDuplicateGCPs(m_nGCPCount, pasGCPListIn);\n\n        m_bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"SetGCPs() is only supported on newly created GeoTIFF files.\");\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadataDomainList()\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszDomainList = CSLDuplicate(m_oGTiffMDMD.GetDomainList());\n    char **papszBaseList = GDALDataset::GetMetadataDomainList();\n\n    const int nbBaseDomains = CSLCount(papszBaseList);\n\n    for( int domainId = 0; domainId \u003c nbBaseDomains; ++domainId )\n    {\n        if( CSLFindString(papszDomainList, papszBaseList[domainId]) \u003c 0 )\n        {\n            papszDomainList = CSLAddString(papszDomainList,papszBaseList[domainId]);\n        }\n    }\n\n    CSLDestroy(papszBaseList);\n\n    return BuildMetadataDomainList(\n        papszDomainList,\n        TRUE,\n        \"\", \"ProxyOverviewRequest\", MD_DOMAIN_RPC, MD_DOMAIN_IMD,\n        \"SUBDATASETS\", \"EXIF\",\n        \"xml:XMP\", \"COLOR_PROFILE\", nullptr);\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"ProxyOverviewRequest\") )\n        return GDALPamDataset::GetMetadata( pszDomain );\n\n    if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"DERIVED_SUBDATASETS\"))\n    {\n        return GDALDataset::GetMetadata(pszDomain);\n    }\n\n    else if( pszDomain != nullptr \u0026\u0026 (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n        LoadMetadata();\n\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"SUBDATASETS\") )\n        ScanDirectories();\n\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"EXIF\") )\n        LoadEXIFMetadata();\n\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"COLOR_PROFILE\") )\n        LoadICCProfile();\n\n    else if( pszDomain == nullptr || EQUAL(pszDomain, \"\") )\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n\n    return m_oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\nCPLErr GTiffDataset::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_bStreamingOut \u0026\u0026 m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, MD_DOMAIN_RPC) )\n    {\n        // So that a subsequent GetMetadata() wouldn't override our new values\n        LoadMetadata();\n        m_bForceUnsetRPC = (CSLCount(papszMD) == 0);\n    }\n\n    if( (papszMD != nullptr) \u0026\u0026\n        (pszDomain != nullptr) \u0026\u0026\n        EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        m_bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        m_bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update \u0026\u0026\n            GDALPamDataset::GetMetadata(pszDomain) != nullptr )\n            GDALPamDataset::SetMetadata(nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) \u0026\u0026\n        CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT) != nullptr )\n    {\n        const char* pszPrevValue =\n                GetMetadataItem(GDALMD_AREA_OR_POINT);\n        const char* pszNewValue =\n                CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT);\n        if( pszPrevValue == nullptr || pszNewValue == nullptr ||\n            !EQUAL(pszPrevValue, pszNewValue) )\n        {\n            LookForProjection();\n            m_bGeoTIFFInfoChanged = true;\n        }\n    }\n\n    if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"xml:XMP\") )\n    {\n        if( papszMD != nullptr \u0026\u0026 *papszMD != nullptr )\n        {\n            int nTagSize = static_cast\u003cint\u003e(strlen(*papszMD));\n            TIFFSetField( m_hTIFF, TIFFTAG_XMLPACKET, nTagSize, *papszMD );\n        }\n        else\n        {\n            TIFFUnsetField( m_hTIFF, TIFFTAG_XMLPACKET );\n        }\n    }\n\n    return m_oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffDataset::GetMetadataItem( const char *pszName,\n                                           const char *pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n    {\n        return GDALPamDataset::GetMetadataItem( pszName, pszDomain );\n    }\n    else if( pszDomain != nullptr \u0026\u0026 (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n    {\n        LoadMetadata();\n    }\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"SUBDATASETS\") )\n    {\n        ScanDirectories();\n    }\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"EXIF\") )\n    {\n        LoadEXIFMetadata();\n    }\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        LoadICCProfile();\n    }\n    else if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) \u0026\u0026\n        pszName != nullptr \u0026\u0026 EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n    }\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"_DEBUG_\") \u0026\u0026\n             pszName != nullptr )\n    {\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\n        if( EQUAL(pszName, \"UNREACHED_VIRTUALMEMIO_CODE_PATH\") )\n        {\n            CPLString osMissing;\n            for( int i = 0; i \u003c static_cast\u003cint\u003e(\n                                    CPL_ARRAYSIZE(anReachedVirtualMemIO)); ++i )\n            {\n                if( !anReachedVirtualMemIO[i] )\n                {\n                    if( !osMissing.empty() ) osMissing += \",\";\n                    osMissing += CPLSPrintf(\"%d\", i);\n                }\n            }\n            return (osMissing.size()) ? CPLSPrintf(\"%s\", osMissing.c_str()) : nullptr;\n        }\n        else\n#endif\n        if( EQUAL(pszName, \"TIFFTAG_EXTRASAMPLES\") )\n        {\n            CPLString osRet;\n            uint16 *v = nullptr;\n            uint16 count = 0;\n\n            if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, \u0026count, \u0026v ) )\n            {\n                for( int i = 0; i \u003c static_cast\u003cint\u003e(count); ++i )\n                {\n                    if( i \u003e 0 ) osRet += \",\";\n                    osRet += CPLSPrintf(\"%d\", v[i]);\n                }\n            }\n            return (osRet.size()) ? CPLSPrintf(\"%s\", osRet.c_str()) : nullptr;\n        }\n        else if( EQUAL(pszName, \"TIFFTAG_PHOTOMETRIC\") )\n        {\n            return CPLSPrintf(\"%d\", m_nPhotometric);\n        }\n\n        else if( EQUAL( pszName, \"TIFFTAG_GDAL_METADATA\") )\n        {\n            char* pszText = nullptr;\n            if( !TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, \u0026pszText ) )\n                return nullptr;\n\n            return CPLSPrintf(\"%s\", pszText);\n        }\n        else if( EQUAL( pszName, \"HAS_USED_READ_ENCODED_API\") )\n        {\n            return m_bHasUsedReadEncodedAPI ? \"1\" : \"0\";\n        }\n        return nullptr;\n    }\n\n    else if( pszDomain != nullptr \u0026\u0026 EQUAL(pszDomain, \"TIFF\") \u0026\u0026\n             pszName != nullptr )\n    {\n        if( EQUAL(pszName, \"GDAL_STRUCTURAL_METADATA\") )\n        {\n            const auto nOffset = VSIFTellL(m_fpL);\n            VSIFSeekL( m_fpL, 0, SEEK_SET );\n            GByte abyData[1024];\n            size_t nRead = VSIFReadL(abyData, 1, sizeof(abyData)-1, m_fpL);\n            abyData[nRead] = 0;\n            VSIFSeekL( m_fpL, nOffset, SEEK_SET );\n            if( nRead \u003e 4 )\n            {\n                const int nOffsetOfStructuralMetadata =\n                    (abyData[2] == 0x2B || abyData[3] == 0x2B ) ? 16 : 8;\n                const int nSizePatternLen = static_cast\u003cint\u003e(strlen(\"XXXXXX bytes\\n\"));\n                if( nRead \u003e nOffsetOfStructuralMetadata +\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") + nSizePatternLen \u0026\u0026\n                    memcmp(abyData + nOffsetOfStructuralMetadata,\n                            \"GDAL_STRUCTURAL_METADATA_SIZE=\",\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) == 0 )\n                {\n                    char* pszStructuralMD = reinterpret_cast\u003cchar*\u003e(\n                        abyData + nOffsetOfStructuralMetadata);\n                    const int nLenMD = atoi(pszStructuralMD +\n                                    strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\"));\n                    if( nOffsetOfStructuralMetadata +\n                        strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") +\n                        nSizePatternLen + nLenMD \u003c= nRead )\n                    {\n                        pszStructuralMD[\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") +\n                            nSizePatternLen + nLenMD] = 0;\n                        return CPLSPrintf(\"%s\", pszStructuralMD);\n                    }\n                }\n            }\n            return nullptr;\n        }\n    }\n\n    return m_oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetMetadataItem( const char *pszName,\n                                      const char *pszValue,\n                                      const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_bStreamingOut \u0026\u0026 m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( (pszDomain != nullptr) \u0026\u0026 EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        m_bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        m_bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update \u0026\u0026\n            GDALPamDataset::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamDataset::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) \u0026\u0026\n        pszName != nullptr \u0026\u0026 EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LookForProjection();\n        m_bGeoTIFFInfoChanged = true;\n    }\n\n    return m_oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                         GetInternalHandle()                          */\n/************************************************************************/\n\nvoid *GTiffDataset::GetInternalHandle( const char * /* pszHandleName */ )\n\n{\n    return m_hTIFF;\n}\n\n/************************************************************************/\n/*                         LoadEXIFMetadata()                           */\n/************************************************************************/\n\nvoid GTiffDataset::LoadEXIFMetadata()\n{\n    if( m_bEXIFMetadataLoaded )\n        return;\n    m_bEXIFMetadataLoaded = true;\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n\n    GByte abyHeader[2] = { 0 };\n    if( VSIFSeekL(fp, 0, SEEK_SET) != 0 ||\n        VSIFReadL(abyHeader, 1, 2, fp) != 2 )\n        return;\n\n    const bool bLittleEndian = abyHeader[0] == 'I' \u0026\u0026 abyHeader[1] == 'I';\n    const bool bLeastSignificantBit = CPL_IS_LSB != 0;\n    const bool bSwabflag = bLittleEndian != bLeastSignificantBit;  // != is XOR.\n\n    char** papszMetadata = nullptr;\n    toff_t nOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_EXIFIFD, \u0026nOffset) )\n    {\n        int nExifOffset = static_cast\u003cint\u003e(nOffset);\n        int nInterOffset = 0;\n        int nGPSOffset = 0;\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast\u003cint\u003e(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset);\n    }\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_GPSIFD, \u0026nOffset) )\n    {\n        int nExifOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n        int nInterOffset = 0;\n        int nGPSOffset = static_cast\u003cint\u003e(nOffset);\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast\u003cint\u003e(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset );\n    }\n\n    if( papszMetadata )\n    {\n        m_oGTiffMDMD.SetMetadata( papszMetadata, \"EXIF\" );\n        CSLDestroy( papszMetadata );\n    }\n}\n\n/************************************************************************/\n/*                           LoadMetadata()                             */\n/************************************************************************/\nvoid GTiffDataset::LoadMetadata()\n{\n    if( m_bIMDRPCMetadataLoaded )\n        return;\n    m_bIMDRPCMetadataLoaded = true;\n\n    GDALMDReaderManager mdreadermanager;\n    GDALMDReaderBase* mdreader =\n        mdreadermanager.GetReader(m_pszFilename,\n                                  oOvManager.GetSiblingFiles(), MDR_ANY);\n\n    if( nullptr != mdreader )\n    {\n        mdreader-\u003eFillMetadata(\u0026m_oGTiffMDMD);\n\n        if(mdreader-\u003eGetMetadataDomain(MD_DOMAIN_RPC) == nullptr)\n        {\n            char** papszRPCMD = GTiffDatasetReadRPCTag(m_hTIFF);\n            if( papszRPCMD )\n            {\n                m_oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n                CSLDestroy( papszRPCMD );\n            }\n        }\n\n        m_papszMetadataFiles = mdreader-\u003eGetMetadataFiles();\n    }\n    else\n    {\n        char** papszRPCMD = GTiffDatasetReadRPCTag(m_hTIFF);\n        if( papszRPCMD )\n        {\n            m_oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n            CSLDestroy( papszRPCMD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                            GetFileList()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetFileList()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszFileList = GDALPamDataset::GetFileList();\n\n    LoadMetadata();\n    if(nullptr != m_papszMetadataFiles)\n    {\n        for( int i = 0; m_papszMetadataFiles[i] != nullptr; ++i )\n        {\n            if( CSLFindString( papszFileList, m_papszMetadataFiles[i] ) \u003c 0 )\n            {\n                papszFileList =\n                    CSLAddString( papszFileList, m_papszMetadataFiles[i] );\n            }\n        }\n    }\n\n    if( m_pszGeorefFilename \u0026\u0026\n        CSLFindString(papszFileList, m_pszGeorefFilename) == -1 )\n    {\n        papszFileList = CSLAddString( papszFileList, m_pszGeorefFilename );\n    }\n\n    return papszFileList;\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateMaskBand(int nFlagsIn)\n{\n    ScanDirectories();\n\n    if( m_poMaskDS != nullptr )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n    else if( MustCreateInternalMask() )\n    {\n        if( nFlagsIn != GMF_PER_DATASET )\n        {\n            ReportError(\n                CE_Failure, CPLE_AppDefined,\n                \"The only flag value supported for internal mask is \"\n                \"GMF_PER_DATASET\" );\n            return CE_Failure;\n        }\n\n        int l_nCompression = COMPRESSION_PACKBITS;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"\u003cValue\u003eDEFLATE\u003c/Value\u003e\") != nullptr )\n            l_nCompression = COMPRESSION_ADOBE_DEFLATE;\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            ReportError( CE_Warning, CPLE_AppDefined,\n                      \"File open for read-only accessing, \"\n                      \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlagsIn);\n        }\n\n        if( m_bLayoutIFDSBeforeData \u0026\u0026 !m_bKnownIncompatibleEdition \u0026\u0026\n            !m_bWriteKnownIncompatibleEdition )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                        \"Adding a mask invalidates the \"\n                        \"LAYOUT=IFDS_BEFORE_DATA property\");\n            m_bKnownIncompatibleEdition = true;\n            m_bWriteKnownIncompatibleEdition = true;\n        }\n\n        bool bIsOverview = false;\n        uint32 nSubType = 0;\n        if( TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, \u0026nSubType) )\n        {\n            bIsOverview = (nSubType \u0026 FILETYPE_REDUCEDIMAGE) != 0;\n\n            if( (nSubType \u0026 FILETYPE_MASK) != 0 )\n            {\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        const int bIsTiled = TIFFIsTiled(m_hTIFF);\n\n        FlushDirectory();\n\n        const toff_t nOffset =\n            GTIFFWriteDirectory(\n                m_hTIFF,\n                bIsOverview ?\n                FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                nRasterXSize, nRasterYSize,\n                1, PLANARCONFIG_CONTIG, 1,\n                m_nBlockXSize, m_nBlockYSize,\n                bIsTiled, l_nCompression,\n                PHOTOMETRIC_MASK, PREDICTOR_NONE,\n                SAMPLEFORMAT_UINT, nullptr, nullptr, nullptr, 0, nullptr, \"\", nullptr, nullptr,\n                nullptr, nullptr, m_bWriteCOGLayout, nullptr );\n\n        ReloadDirectory();\n\n        if( nOffset == 0 )\n            return CE_Failure;\n\n        m_poMaskDS = new GTiffDataset();\n        m_poMaskDS-\u003em_poBaseDS = this;\n        m_poMaskDS-\u003em_poImageryDS = this;\n        m_poMaskDS-\u003eShareLockWithParentDataset(this);\n        m_poMaskDS-\u003em_bPromoteTo8Bits =\n            CPLTestBool(\n                CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n        if( m_poMaskDS-\u003eOpenOffset( VSI_TIFFOpenChild(m_hTIFF), nOffset,\n                                  GA_Update ) != CE_None)\n        {\n            delete m_poMaskDS;\n            m_poMaskDS = nullptr;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n\n    return GDALPamDataset::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                        MustCreateInternalMask()                      */\n/************************************************************************/\n\nbool GTiffDataset::MustCreateInternalMask()\n{\n    return CPLTestBool(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\"));\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::CreateMaskBand( int nFlagsIn )\n{\n    m_poGDS-\u003eScanDirectories();\n\n    if( m_poGDS-\u003em_poMaskDS != nullptr )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n\n    if( CPLTestBool( CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\") ) )\n    {\n        return m_poGDS-\u003eCreateMaskBand(nFlagsIn);\n    }\n\n    return GDALPamRasterBand::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                        GetRawBinaryLayout()                          */\n/************************************************************************/\n\nbool GTiffDataset::GetRawBinaryLayout(GDALDataset::RawBinaryLayout\u0026 sLayout)\n{\n    if( eAccess == GA_Update )\n    {\n        FlushCache();\n        Crystalize();\n    }\n\n    if( m_nCompression != COMPRESSION_NONE )\n        return false;\n    if( !CPLIsPowerOfTwo(m_nBitsPerSample) || m_nBitsPerSample \u003c 8 )\n        return false;\n    const auto eDT = GetRasterBand(1)-\u003eGetRasterDataType();\n    if( GDALDataTypeIsComplex( eDT ) )\n        return false;\n\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(m_hTIFF) );\n\n    if( !(( bIsTiled\n            \u0026\u0026 TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, \u0026panByteCounts )\n            \u0026\u0026 TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, \u0026panOffsets ) )\n            || ( !bIsTiled\n            \u0026\u0026 TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, \u0026panByteCounts )\n            \u0026\u0026 TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, \u0026panOffsets ) )) )\n    {\n        return false;\n    }\n\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDT);\n    vsi_l_offset        nImgOffset = panOffsets[0];\n    GIntBig             nPixelOffset = ( m_nPlanarConfig == PLANARCONFIG_CONTIG ) ? static_cast\u003cGIntBig\u003e(nDTSize) * nBands : nDTSize;\n    GIntBig             nLineOffset = nPixelOffset * nRasterXSize;\n    GIntBig             nBandOffset = ( m_nPlanarConfig == PLANARCONFIG_CONTIG \u0026\u0026 nBands \u003e 1 ) ? nDTSize : 0;\n    RawBinaryLayout::Interleaving eInterleaving =\n        (nBands == 1) ?                             RawBinaryLayout::Interleaving::UNKNOWN :\n        (m_nPlanarConfig == PLANARCONFIG_CONTIG ) ? RawBinaryLayout::Interleaving::BIP :\n                                                    RawBinaryLayout::Interleaving::BSQ;\n    if( bIsTiled )\n    {\n        // Only a single block tiled file with same dimension as the raster\n        // might be acceptable\n        if( m_nBlockXSize != nRasterXSize || m_nBlockYSize != nRasterYSize )\n            return false;\n        if( nBands \u003e 1 \u0026\u0026 m_nPlanarConfig != PLANARCONFIG_CONTIG )\n        {\n            nBandOffset = static_cast\u003cGIntBig\u003e(panOffsets[1]) - static_cast\u003cGIntBig\u003e(panOffsets[0]);\n            for( int i = 2; i \u003c nBands; i++ )\n            {\n                if( static_cast\u003cGIntBig\u003e(panOffsets[i]) - static_cast\u003cGIntBig\u003e(panOffsets[i - 1]) != nBandOffset )\n                    return false;\n            }\n        }\n    }\n    else\n    {\n        const int nStrips = DIV_ROUND_UP(nRasterYSize, m_nRowsPerStrip);\n        if( nBands == 1 || m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            vsi_l_offset nLastStripEnd = panOffsets[0] + panByteCounts[0];\n            for( int iStrip = 1; iStrip \u003c nStrips; iStrip++ )\n            {\n                if( nLastStripEnd != panOffsets[iStrip] )\n                    return false;\n                nLastStripEnd = panOffsets[iStrip] + panByteCounts[iStrip];\n            }\n        }\n        else\n        {\n            // Note: we could potentially have BIL order with m_nRowsPerStrip == 1\n            // and if strips are ordered strip_line_1_band_1, ..., strip_line_1_band_N, strip_line2_band1, ... strip_line2_band_N, etc....\n            // but that'd be faily exotic !\n            // So only detect BSQ layout here\n            nBandOffset = static_cast\u003cGIntBig\u003e(panOffsets[nStrips]) - static_cast\u003cGIntBig\u003e(panOffsets[0]);\n            for( int i = 0; i \u003c nBands; i++ )\n            {\n                uint32 iStripOffset = nStrips * i;\n                vsi_l_offset nLastStripEnd = panOffsets[iStripOffset] + panByteCounts[iStripOffset];\n                for( int iStrip = 1; iStrip \u003c nStrips; iStrip++ )\n                {\n                    if( nLastStripEnd != panOffsets[iStripOffset + iStrip] )\n                        return false;\n                    nLastStripEnd = panOffsets[iStripOffset + iStrip] + panByteCounts[iStripOffset + iStrip];\n                }\n                if( i \u003e= 2 \u0026\u0026\n                     static_cast\u003cGIntBig\u003e(panOffsets[iStripOffset]) -\n                        static_cast\u003cGIntBig\u003e(panOffsets[iStripOffset - nStrips]) != nBandOffset )\n                {\n                    return false;\n                }\n            }\n        }\n    }\n\n    sLayout.osRawFilename = m_pszFilename;\n    sLayout.eInterleaving = eInterleaving;\n    sLayout.eDataType = eDT;\n#ifdef CPL_LSB\n    sLayout.bLittleEndianOrder = !TIFFIsByteSwapped(m_hTIFF);\n#else\n    sLayout.bLittleEndianOrder = TIFFIsByteSwapped(m_hTIFF);\n#endif\n    sLayout.nImageOffset = nImgOffset;\n    sLayout.nPixelOffset = nPixelOffset;\n    sLayout.nLineOffset = nLineOffset;\n    sLayout.nBandOffset = nBandOffset;\n\n    return true;\n}\n\n/************************************************************************/\n/*                       PrepareTIFFErrorFormat()                       */\n/*                                                                      */\n/*      sometimes the \"module\" has stuff in it that has special         */\n/*      meaning in a printf() style format, so we try to escape it.     */\n/*      For now we hope the only thing we have to escape is %'s.        */\n/************************************************************************/\n\nstatic char *PrepareTIFFErrorFormat( const char *module, const char *fmt )\n\n{\n    const size_t nModuleSize = strlen(module);\n    const size_t nModFmtSize = nModuleSize * 2 + strlen(fmt) + 2;\n    char *pszModFmt = static_cast\u003cchar *\u003e( CPLMalloc( nModFmtSize ) );\n\n    size_t iOut = 0;  // Used after for.\n\n    for( size_t iIn = 0; iIn \u003c nModuleSize; ++iIn )\n    {\n        if( module[iIn] == '%' )\n        {\n            CPLAssert(iOut \u003c nModFmtSize - 2);\n            pszModFmt[iOut++] = '%';\n            pszModFmt[iOut++] = '%';\n        }\n        else\n        {\n            CPLAssert(iOut \u003c nModFmtSize - 1);\n            pszModFmt[iOut++] = module[iIn];\n        }\n    }\n    CPLAssert(iOut \u003c nModFmtSize);\n    pszModFmt[iOut] = '\\0';\n    strcat( pszModFmt, \":\" );\n    strcat( pszModFmt, fmt );\n\n    return pszModFmt;\n}\n\n/************************************************************************/\n/*                        GTiffWarningHandler()                         */\n/************************************************************************/\nstatic void\nGTiffWarningHandler(const char* module, const char* fmt, va_list ap )\n{\n    if( strstr(fmt,\"nknown field\") != nullptr )\n        return;\n\n    char *pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    if( strstr(fmt, \"does not end in null byte\") != nullptr )\n    {\n        CPLString osMsg;\n        osMsg.vPrintf(pszModFmt, ap);\n        CPLDebug( \"GTiff\", \"%s\", osMsg.c_str() );\n    }\n    else\n    {\n        CPLErrorV( CE_Warning, CPLE_AppDefined, pszModFmt, ap );\n    }\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                         GTiffErrorHandler()                          */\n/************************************************************************/\nstatic void\nGTiffErrorHandler( const char* module, const char* fmt, va_list ap )\n{\n    if( strcmp(fmt, \"Maximum TIFF file size exceeded\") == 0 )\n    {\n        // Ideally there would be a thread-safe way of setting this flag,\n        // but we cannot really use the extended error handler, since the\n        // handler is for all TIFF handles, and not necessarily the ones of\n        // this driver.\n        if( bGlobalInExternalOvr )\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use --config BIGTIFF_OVERVIEW YES configuration option.\";\n        else\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use BIGTIFF=YES creation option.\";\n    }\n\n    char* pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    CPLErrorV( CE_Failure, CPLE_AppDefined, pszModFmt, ap );\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                          GTiffTagExtender()                          */\n/*                                                                      */\n/*      Install tags specially known to GDAL.                           */\n/************************************************************************/\n\nstatic TIFFExtendProc _ParentExtender = nullptr;\n\nstatic void GTiffTagExtender(TIFF *tif)\n\n{\n    const TIFFFieldInfo xtiffFieldInfo[] = {\n        { TIFFTAG_GDAL_METADATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast\u003cchar *\u003e( \"GDALMetadata\" ) },\n        { TIFFTAG_GDAL_NODATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast\u003cchar*\u003e( \"GDALNoDataValue\" ) },\n        { TIFFTAG_RPCCOEFFICIENT, -1, -1, TIFF_DOUBLE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast\u003cchar *\u003e( \"RPCCoefficient\" ) },\n        { TIFFTAG_TIFF_RSID, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast\u003cchar *\u003e( \"TIFF_RSID\" ) },\n        { TIFFTAG_GEO_METADATA, TIFF_VARIABLE2, TIFF_VARIABLE2, TIFF_BYTE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast\u003cchar *\u003e( \"GEO_METADATA\" ) }\n    };\n\n    if( _ParentExtender )\n        (*_ParentExtender)(tif);\n\n    TIFFMergeFieldInfo( tif, xtiffFieldInfo,\n                        sizeof(xtiffFieldInfo) / sizeof(xtiffFieldInfo[0]) );\n}\n\n/************************************************************************/\n/*                          GTiffOneTimeInit()                          */\n/*                                                                      */\n/*      This is stuff that is initialized for the TIFF library just     */\n/*      once.  We deliberately defer the initialization till the        */\n/*      first time we are likely to call into libtiff to avoid          */\n/*      unnecessary paging in of the library for GDAL apps that         */\n/*      don't use it.                                                   */\n/************************************************************************/\n#if defined(HAVE_DLFCN_H) \u0026\u0026 !defined(WIN32)\n#include \u003cdlfcn.h\u003e\n#endif\n\nstatic std::mutex oDeleteMutex;\n#ifdef HAVE_LERC\nstatic TIFFCodec* pLercCodec = nullptr;\n#endif\n\nint GTiffOneTimeInit()\n\n{\n    std::lock_guard\u003cstd::mutex\u003e oLock(oDeleteMutex);\n \n#ifdef HAVE_LERC\n    if( pLercCodec == nullptr )\n    {\n        pLercCodec = TIFFRegisterCODEC(COMPRESSION_LERC, \"LERC\", TIFFInitLERC);\n    }\n#endif\n\n    static bool bOneTimeInitDone = false;\n    if( bOneTimeInitDone )\n        return TRUE;\n\n    bOneTimeInitDone = true;\n\n    // This is a frequent configuration error that is difficult to track down\n    // for people unaware of the issue : GDAL built against internal libtiff\n    // (4.X), but used by an application that links with external libtiff (3.X)\n    // Note: on my conf, the order that cause GDAL to crash - and that is\n    // detected by the following code - is \"-ltiff -lgdal\". \"-lgdal -ltiff\"\n    // works for the GTiff driver but probably breaks the application that\n    // believes it uses libtiff 3.X but we cannot detect that.\n#if !defined(RENAME_INTERNAL_LIBTIFF_SYMBOLS)\n#if defined(HAVE_DLFCN_H) \u0026\u0026 !defined(WIN32)\n    const char* (*pfnVersion)(void);\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n    pfnVersion = reinterpret_cast\u003cconst char* (*)(void)\u003e(dlsym(RTLD_DEFAULT, \"TIFFGetVersion\"));\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic pop\n#endif\n    if( pfnVersion )\n    {\n        const char* pszVersion = pfnVersion();\n        if( pszVersion \u0026\u0026 strstr(pszVersion, \"Version 3.\") != nullptr )\n        {\n            CPLError(\n                CE_Warning, CPLE_AppDefined,\n                \"libtiff version mismatch: You're linking against libtiff 3.X, \"\n                \"but GDAL has been compiled against libtiff \u003e= 4.0.0\" );\n        }\n    }\n#endif  // HAVE_DLFCN_H\n#endif // !defined(RENAME_INTERNAL_LIBTIFF_SYMBOLS)\n\n    _ParentExtender = TIFFSetTagExtender(GTiffTagExtender);\n\n    TIFFSetWarningHandler( GTiffWarningHandler );\n    TIFFSetErrorHandler( GTiffErrorHandler );\n\n    LibgeotiffOneTimeInit();\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                        GDALDeregister_GTiff()                        */\n/************************************************************************/\n\nstatic\nvoid GDALDeregister_GTiff( GDALDriver * )\n\n{\n#ifdef HAVE_LERC\n    if( pLercCodec )\n        TIFFUnRegisterCODEC(pLercCodec);\n    pLercCodec = nullptr;\n#endif\n}\n\n/************************************************************************/\n/*                   GTIFFGetCompressionMethod()                        */\n/************************************************************************/\n\nint GTIFFGetCompressionMethod(const char* pszValue, const char* pszVariableName)\n{\n    int nCompression = COMPRESSION_NONE;\n    if( EQUAL( pszValue, \"NONE\" ) )\n        nCompression = COMPRESSION_NONE;\n    else if( EQUAL( pszValue, \"JPEG\" ) )\n        nCompression = COMPRESSION_JPEG;\n    else if( EQUAL( pszValue, \"LZW\" ) )\n        nCompression = COMPRESSION_LZW;\n    else if( EQUAL( pszValue, \"PACKBITS\" ))\n        nCompression = COMPRESSION_PACKBITS;\n    else if( EQUAL( pszValue, \"DEFLATE\" ) || EQUAL( pszValue, \"ZIP\" ))\n        nCompression = COMPRESSION_ADOBE_DEFLATE;\n    else if( EQUAL( pszValue, \"FAX3\" )\n             || EQUAL( pszValue, \"CCITTFAX3\" ))\n        nCompression = COMPRESSION_CCITTFAX3;\n    else if( EQUAL( pszValue, \"FAX4\" )\n             || EQUAL( pszValue, \"CCITTFAX4\" ))\n        nCompression = COMPRESSION_CCITTFAX4;\n    else if( EQUAL( pszValue, \"CCITTRLE\" ) )\n        nCompression = COMPRESSION_CCITTRLE;\n    else if( EQUAL( pszValue, \"LZMA\" ) )\n        nCompression = COMPRESSION_LZMA;\n    else if( EQUAL( pszValue, \"ZSTD\" ) )\n        nCompression = COMPRESSION_ZSTD;\n#ifdef HAVE_LERC\n    else if( EQUAL( pszValue, \"LERC\" ) ||\n             EQUAL( pszValue, \"LERC_DEFLATE\" ) ||\n             EQUAL( pszValue, \"LERC_ZSTD\" ) )\n    {\n        nCompression = COMPRESSION_LERC;\n    }\n#endif\n    else if( EQUAL( pszValue, \"WEBP\" ) )\n        nCompression = COMPRESSION_WEBP;\n    else\n        CPLError( CE_Warning, CPLE_IllegalArg,\n                  \"%s=%s value not recognised, ignoring.\",\n                  pszVariableName,pszValue );\n\n    if( nCompression != COMPRESSION_NONE \u0026\u0026\n        !TIFFIsCODECConfigured(static_cast\u003cuint16\u003e(nCompression)) )\n    {\n        CPLError(\n            CE_Failure, CPLE_AppDefined,\n            \"Cannot create TIFF file due to missing codec for %s.\", pszValue );\n        return -1;\n    }\n\n    return nCompression;\n}\n\n/************************************************************************/\n/*                     GTiffGetCompressValues()                         */\n/************************************************************************/\n\nCPLString GTiffGetCompressValues(bool\u0026 bHasLZW,\n                                 bool\u0026 bHasDEFLATE,\n                                 bool\u0026 bHasLZMA,\n                                 bool\u0026 bHasZSTD,\n                                 bool\u0026 bHasJPEG,\n                                 bool\u0026 bHasWebP,\n                                 bool bForCOG)\n{\n\n/* -------------------------------------------------------------------- */\n/*      Determine which compression codecs are available that we        */\n/*      want to advertise.  If we are using an old libtiff we won't     */\n/*      be able to find out so we just assume all are available.        */\n/* -------------------------------------------------------------------- */\n    CPLString osCompressValues = \"       \u003cValue\u003eNONE\u003c/Value\u003e\";\n\n    TIFFCodec *codecs = TIFFGetConfiguredCODECs();\n\n    for( TIFFCodec *c = codecs; c-\u003ename; ++c )\n    {\n        if( c-\u003escheme == COMPRESSION_PACKBITS \u0026\u0026 !bForCOG )\n        {\n            osCompressValues +=\n                    \"       \u003cValue\u003ePACKBITS\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_JPEG )\n        {\n            bHasJPEG = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eJPEG\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_LZW )\n        {\n            bHasLZW = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eLZW\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_ADOBE_DEFLATE )\n        {\n            bHasDEFLATE = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eDEFLATE\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_CCITTRLE \u0026\u0026 !bForCOG )\n        {\n            osCompressValues +=\n                    \"       \u003cValue\u003eCCITTRLE\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_CCITTFAX3 \u0026\u0026 !bForCOG )\n        {\n            osCompressValues +=\n                    \"       \u003cValue\u003eCCITTFAX3\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_CCITTFAX4 \u0026\u0026 !bForCOG )\n        {\n            osCompressValues +=\n                    \"       \u003cValue\u003eCCITTFAX4\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_LZMA \u0026\u0026 !bForCOG )\n        {\n            bHasLZMA = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eLZMA\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_ZSTD )\n        {\n            bHasZSTD = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eZSTD\u003c/Value\u003e\";\n        }\n        else if( c-\u003escheme == COMPRESSION_WEBP )\n        {\n            bHasWebP = true;\n            osCompressValues +=\n                    \"       \u003cValue\u003eWEBP\u003c/Value\u003e\";\n        }\n    }\n#ifdef HAVE_LERC\n    osCompressValues +=\n                    \"       \u003cValue\u003eLERC\u003c/Value\u003e\";\n    osCompressValues +=\n                    \"       \u003cValue\u003eLERC_DEFLATE\u003c/Value\u003e\";\n    if( bHasZSTD )\n    {\n        osCompressValues +=\n                    \"       \u003cValue\u003eLERC_ZSTD\u003c/Value\u003e\";\n    }\n#endif\n    _TIFFfree( codecs );\n\n    return osCompressValues;\n}\n\n/************************************************************************/\n/*                          GDALRegister_GTiff()                        */\n/************************************************************************/\n\nvoid GDALRegister_GTiff()\n\n{\n    if( GDALGetDriverByName( \"GTiff\" ) != nullptr )\n        return;\n\n    CPLString osOptions;\n\n    bool bHasLZW = false;\n    bool bHasDEFLATE = false;\n    bool bHasLZMA = false;\n    bool bHasZSTD = false;\n    bool bHasJPEG = false;\n    bool bHasWebP = false;\n    CPLString osCompressValues(GTiffGetCompressValues(\n        bHasLZW, bHasDEFLATE, bHasLZMA, bHasZSTD, bHasJPEG, bHasWebP,\n        false /* bForCOG */));\n\n    GDALDriver *poDriver = new GDALDriver();\n\n/* -------------------------------------------------------------------- */\n/*      Build full creation option list.                                */\n/* -------------------------------------------------------------------- */\n    osOptions = \"\u003cCreationOptionList\u003e\"\n              \"   \u003cOption name='COMPRESS' type='string-select'\u003e\";\n    osOptions += osCompressValues;\n    osOptions += \"   \u003c/Option\u003e\";\n    if( bHasLZW || bHasDEFLATE || bHasZSTD )\n        osOptions += \"\"\n\"   \u003cOption name='PREDICTOR' type='int' description='Predictor Type (1=default, 2=horizontal differencing, 3=floating point prediction)'/\u003e\";\n    osOptions += \"\"\n\"   \u003cOption name='DISCARD_LSB' type='string' description='Number of least-significant bits to set to clear as a single value or comma-separated list of values for per-band values'/\u003e\";\n    if( bHasJPEG )\n    {\n        osOptions += \"\"\n\"   \u003cOption name='JPEG_QUALITY' type='int' description='JPEG quality 1-100' default='75'/\u003e\"\n\"   \u003cOption name='JPEGTABLESMODE' type='int' description='Content of JPEGTABLES tag. 0=no JPEGTABLES tag, 1=Quantization tables only, 2=Huffman tables only, 3=Both' default='1'/\u003e\";\n#ifdef JPEG_DIRECT_COPY\n        osOptions += \"\"\n\"   \u003cOption name='JPEG_DIRECT_COPY' type='boolean' description='To copy without any decompression/recompression a JPEG source file' default='NO'/\u003e\";\n#endif\n    }\n    if( bHasDEFLATE )\n    {\n#ifdef LIBDEFLATE_SUPPORT\n        osOptions += \"\"\n\"   \u003cOption name='ZLEVEL' type='int' description='DEFLATE compression level 1-12' default='6'/\u003e\";\n#else\n        osOptions += \"\"\n\"   \u003cOption name='ZLEVEL' type='int' description='DEFLATE compression level 1-9' default='6'/\u003e\";\n#endif\n    }\n    if( bHasLZMA )\n        osOptions += \"\"\n\"   \u003cOption name='LZMA_PRESET' type='int' description='LZMA compression level 0(fast)-9(slow)' default='6'/\u003e\";\n    if( bHasZSTD )\n        osOptions += \"\"\n\"   \u003cOption name='ZSTD_LEVEL' type='int' description='ZSTD compression level 1(fast)-22(slow)' default='9'/\u003e\";\n#ifdef HAVE_LERC\n    osOptions += \"\"\n\"   \u003cOption name='MAX_Z_ERROR' type='float' description='Maximum error for LERC compression' default='0'/\u003e\";\n#endif\n    if ( bHasWebP )\n    {\n      osOptions += \"\"\n#if WEBP_ENCODER_ABI_VERSION \u003e= 0x0100\n\"   \u003cOption name='WEBP_LOSSLESS' type='boolean' description='Whether lossless compression should be used' default='FALSE'/\u003e\"\n#endif\n\"   \u003cOption name='WEBP_LEVEL' type='int' description='WEBP quality level. Low values result in higher compression ratios' default='75'/\u003e\";\n    }\n    osOptions += \"\"\n\"   \u003cOption name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/\u003e\"\n\"   \u003cOption name='NBITS' type='int' description='BITS for sub-byte files (1-7), sub-uint16 (9-15), sub-uint32 (17-31), or float32 (16)'/\u003e\"\n\"   \u003cOption name='INTERLEAVE' type='string-select' default='PIXEL'\u003e\"\n\"       \u003cValue\u003eBAND\u003c/Value\u003e\"\n\"       \u003cValue\u003ePIXEL\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='TILED' type='boolean' description='Switch to tiled format'/\u003e\"\n\"   \u003cOption name='TFW' type='boolean' description='Write out world file'/\u003e\"\n\"   \u003cOption name='RPB' type='boolean' description='Write out .RPB (RPC) file'/\u003e\"\n\"   \u003cOption name='RPCTXT' type='boolean' description='Write out _RPC.TXT file'/\u003e\"\n\"   \u003cOption name='BLOCKXSIZE' type='int' description='Tile Width'/\u003e\"\n\"   \u003cOption name='BLOCKYSIZE' type='int' description='Tile/Strip Height'/\u003e\"\n\"   \u003cOption name='PHOTOMETRIC' type='string-select'\u003e\"\n\"       \u003cValue\u003eMINISBLACK\u003c/Value\u003e\"\n\"       \u003cValue\u003eMINISWHITE\u003c/Value\u003e\"\n\"       \u003cValue\u003ePALETTE\u003c/Value\u003e\"\n\"       \u003cValue\u003eRGB\u003c/Value\u003e\"\n\"       \u003cValue\u003eCMYK\u003c/Value\u003e\"\n\"       \u003cValue\u003eYCBCR\u003c/Value\u003e\"\n\"       \u003cValue\u003eCIELAB\u003c/Value\u003e\"\n\"       \u003cValue\u003eICCLAB\u003c/Value\u003e\"\n\"       \u003cValue\u003eITULAB\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/\u003e\"\n\"   \u003cOption name='ALPHA' type='string-select' description='Mark first extrasample as being alpha'\u003e\"\n\"       \u003cValue\u003eNON-PREMULTIPLIED\u003c/Value\u003e\"\n\"       \u003cValue\u003ePREMULTIPLIED\u003c/Value\u003e\"\n\"       \u003cValue\u003eUNSPECIFIED\u003c/Value\u003e\"\n\"       \u003cValue aliasOf='NON-PREMULTIPLIED'\u003eYES\u003c/Value\u003e\"\n\"       \u003cValue aliasOf='UNSPECIFIED'\u003eNO\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='PROFILE' type='string-select' default='GDALGeoTIFF'\u003e\"\n\"       \u003cValue\u003eGDALGeoTIFF\u003c/Value\u003e\"\n\"       \u003cValue\u003eGeoTIFF\u003c/Value\u003e\"\n\"       \u003cValue\u003eBASELINE\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='PIXELTYPE' type='string-select'\u003e\"\n\"       \u003cValue\u003eDEFAULT\u003c/Value\u003e\"\n\"       \u003cValue\u003eSIGNEDBYTE\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='BIGTIFF' type='string-select' description='Force creation of BigTIFF file'\u003e\"\n\"     \u003cValue\u003eYES\u003c/Value\u003e\"\n\"     \u003cValue\u003eNO\u003c/Value\u003e\"\n\"     \u003cValue\u003eIF_NEEDED\u003c/Value\u003e\"\n\"     \u003cValue\u003eIF_SAFER\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='ENDIANNESS' type='string-select' default='NATIVE' description='Force endianness of created file. For DEBUG purpose mostly'\u003e\"\n\"       \u003cValue\u003eNATIVE\u003c/Value\u003e\"\n\"       \u003cValue\u003eINVERTED\u003c/Value\u003e\"\n\"       \u003cValue\u003eLITTLE\u003c/Value\u003e\"\n\"       \u003cValue\u003eBIG\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='COPY_SRC_OVERVIEWS' type='boolean' default='NO' description='Force copy of overviews of source dataset (CreateCopy())'/\u003e\"\n\"   \u003cOption name='SOURCE_ICC_PROFILE' type='string' description='ICC profile'/\u003e\"\n\"   \u003cOption name='SOURCE_PRIMARIES_RED' type='string' description='x,y,1.0 (xyY) red chromaticity'/\u003e\"\n\"   \u003cOption name='SOURCE_PRIMARIES_GREEN' type='string' description='x,y,1.0 (xyY) green chromaticity'/\u003e\"\n\"   \u003cOption name='SOURCE_PRIMARIES_BLUE' type='string' description='x,y,1.0 (xyY) blue chromaticity'/\u003e\"\n\"   \u003cOption name='SOURCE_WHITEPOINT' type='string' description='x,y,1.0 (xyY) whitepoint'/\u003e\"\n\"   \u003cOption name='TIFFTAG_TRANSFERFUNCTION_RED' type='string' description='Transfer function for red'/\u003e\"\n\"   \u003cOption name='TIFFTAG_TRANSFERFUNCTION_GREEN' type='string' description='Transfer function for green'/\u003e\"\n\"   \u003cOption name='TIFFTAG_TRANSFERFUNCTION_BLUE' type='string' description='Transfer function for blue'/\u003e\"\n\"   \u003cOption name='TIFFTAG_TRANSFERRANGE_BLACK' type='string' description='Transfer range for black'/\u003e\"\n\"   \u003cOption name='TIFFTAG_TRANSFERRANGE_WHITE' type='string' description='Transfer range for white'/\u003e\"\n\"   \u003cOption name='STREAMABLE_OUTPUT' type='boolean' default='NO' description='Enforce a mode compatible with a streamable file'/\u003e\"\n\"   \u003cOption name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used'\u003e\"\n\"       \u003cValue\u003eSTANDARD\u003c/Value\u003e\"\n\"       \u003cValue\u003eESRI_PE\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n#if LIBGEOTIFF_VERSION \u003e= 1600\n\"   \u003cOption name='GEOTIFF_VERSION' type='string-select' default='AUTO' description='Which version of GeoTIFF must be used'\u003e\"\n\"       \u003cValue\u003eAUTO\u003c/Value\u003e\"\n\"       \u003cValue\u003e1.0\u003c/Value\u003e\"\n\"       \u003cValue\u003e1.1\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n#endif\n\"\u003c/CreationOptionList\u003e\";\n\n/* -------------------------------------------------------------------- */\n/*      Set the driver details.                                         */\n/* -------------------------------------------------------------------- */\n    poDriver-\u003eSetDescription( \"GTiff\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DCAP_RASTER, \"YES\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_LONGNAME, \"GeoTIFF\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_HELPTOPIC, \"drivers/raster/gtiff.html\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_MIMETYPE, \"image/tiff\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_EXTENSION, \"tif\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_EXTENSIONS, \"tif tiff\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_CREATIONDATATYPES,\n                               \"Byte UInt16 Int16 UInt32 Int32 Float32 \"\n                               \"Float64 CInt16 CInt32 CFloat32 CFloat64\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_CREATIONOPTIONLIST, osOptions );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_OPENOPTIONLIST,\n\"\u003cOpenOptionList\u003e\"\n\"   \u003cOption name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/\u003e\"\n\"   \u003cOption name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used (for writing)'\u003e\"\n\"       \u003cValue\u003eSTANDARD\u003c/Value\u003e\"\n\"       \u003cValue\u003eESRI_PE\u003c/Value\u003e\"\n\"   \u003c/Option\u003e\"\n\"   \u003cOption name='GEOREF_SOURCES' type='string' description='Comma separated list made with values INTERNAL/TABFILE/WORLDFILE/PAM/NONE that describe the priority order for georeferencing' default='PAM,INTERNAL,TABFILE,WORLDFILE'/\u003e\"\n\"   \u003cOption name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/\u003e\"\n\"\u003c/OpenOptionList\u003e\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DMD_SUBDATASETS, \"YES\" );\n    poDriver-\u003eSetMetadataItem( GDAL_DCAP_VIRTUALIO, \"YES\" );\n\n#ifdef INTERNAL_LIBTIFF\n    poDriver-\u003eSetMetadataItem( \"LIBTIFF\", \"INTERNAL\" );\n#else\n    poDriver-\u003eSetMetadataItem( \"LIBTIFF\", TIFFLIB_VERSION_STR );\n#endif\n\n#define STRINGIFY(x) #x\n#define XSTRINGIFY(x) STRINGIFY(x)\n    poDriver-\u003eSetMetadataItem( \"LIBGEOTIFF\", XSTRINGIFY(LIBGEOTIFF_VERSION) );\n\n    poDriver-\u003epfnOpen = GTiffDataset::Open;\n    poDriver-\u003epfnCreate = GTiffDataset::Create;\n    poDriver-\u003epfnCreateCopy = GTiffDataset::CreateCopy;\n    poDriver-\u003epfnUnloadDriver = GDALDeregister_GTiff;\n    poDriver-\u003epfnIdentify = GTiffDataset::Identify;\n\n    GetGDALDriverManager()-\u003eRegisterDriver( poDriver );\n}\n",
        "name": "geotiff.cpp",
        "path": "deps/libgdal/gdal/frmts/gtiff/geotiff.cpp",
        "url": "/github.com/yocontra/node-gdal-next/-/blob/deps/libgdal/gdal/frmts/gtiff/geotiff.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 6341,
          "offsetAndLengths": [
            [
              16,
              19
            ]
          ],
          "preview": "            if( TIFFReadRGBATileExt("
        }
      ],
      "repository": {
        "name": "github.com/yocontra/node-gdal-next",
        "url": "/github.com/yocontra/node-gdal-next"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "757df93e6f42f021e801d818970e9f19215df35f"
        },
        "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam \u003cwarmerdam@pobox.com\u003e\n * Copyright (c) 2007-2015, Even Rouault \u003ceven dot rouault at spatialys dot com\u003e\n *\n * SPDX-License-Identifier: MIT\n ****************************************************************************/\n\n#include \"gtiffrgbaband.h\"\n#include \"gtiffdataset.h\"\n\n#include \"tiffio.h\"\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand(GTiffDataset *poDSIn, int nBandIn)\n    : GTiffRasterBand(poDSIn, nBandIn)\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus(int, int, int, int, int, double *)\n{\n    return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n           GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock(int, int, void *)\n\n{\n    ReportError(CE_Failure, CPLE_AppDefined,\n                \"RGBA interpreted raster bands are read-only.\");\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock(int nBlockXOff, int nBlockYOff, void *pImage)\n\n{\n    m_poGDS-\u003eCrystalize();\n\n    const auto nBlockBufSize =\n        4 * static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if (m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE)\n    {\n        for (int iBand = 0; iBand \u003c m_poGDS-\u003em_nSamplesPerPixel; iBand++)\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS-\u003em_nBlocksPerBand;\n            if (!m_poGDS-\u003eIsBlockAvailable(nBlockIdBand, nullptr, nullptr,\n                                           nullptr))\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if (!m_poGDS-\u003eIsBlockAvailable(nBlockId, nullptr, nullptr, nullptr))\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Allocate a temporary buffer for this strip.                     */\n    /* -------------------------------------------------------------------- */\n    if (m_poGDS-\u003em_pabyBlockBuf == nullptr)\n    {\n        m_poGDS-\u003em_pabyBlockBuf = static_cast\u003cGByte *\u003e(\n            VSI_MALLOC3_VERBOSE(4, nBlockXSize, nBlockYSize));\n        if (m_poGDS-\u003em_pabyBlockBuf == nullptr)\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read the strip                                                  */\n    /* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if (m_poGDS-\u003em_nLoadedBlock != nBlockId)\n    {\n        if (TIFFIsTiled(m_poGDS-\u003em_hTIFF))\n        {\n            if (TIFFReadRGBATileExt(\n                    m_poGDS-\u003em_hTIFF, nBlockXOff * nBlockXSize,\n                    nBlockYOff * nBlockYSize,\n                    reinterpret_cast\u003cuint32_t *\u003e(m_poGDS-\u003em_pabyBlockBuf),\n                    !m_poGDS-\u003em_bIgnoreReadErrors) == 0 \u0026\u0026\n                !m_poGDS-\u003em_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBATile() failed.\");\n\n                memset(m_poGDS-\u003em_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if (TIFFReadRGBAStripExt(\n                    m_poGDS-\u003em_hTIFF, nBlockId * nBlockYSize,\n                    reinterpret_cast\u003cuint32_t *\u003e(m_poGDS-\u003em_pabyBlockBuf),\n                    !m_poGDS-\u003em_bIgnoreReadErrors) == 0 \u0026\u0026\n                !m_poGDS-\u003em_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBAStrip() failed.\");\n\n                memset(m_poGDS-\u003em_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS-\u003em_nLoadedBlock = eErr == CE_None ? nBlockId : -1;\n\n    /* -------------------------------------------------------------------- */\n    /*      Handle simple case of eight bit data, and pixel interleaving.   */\n    /* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if (nBlockYOff * nBlockYSize \u003e GetYSize() - nBlockYSize \u0026\u0026\n        !TIFFIsTiled(m_poGDS-\u003em_hTIFF))\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for (int iDestLine = 0; iDestLine \u003c nThisBlockYSize; ++iDestLine)\n    {\n        const auto nSrcOffset =\n            static_cast\u003cGPtrDiff_t\u003e(nThisBlockYSize - iDestLine - 1) *\n            nBlockXSize * 4;\n\n        GDALCopyWords(m_poGDS-\u003em_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n                      static_cast\u003cGByte *\u003e(pImage) +\n                          static_cast\u003cGPtrDiff_t\u003e(iDestLine) * nBlockXSize,\n                      GDT_Byte, 1, nBlockXSize);\n    }\n\n    if (eErr == CE_None)\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if (nBand == 1)\n        return GCI_RedBand;\n    if (nBand == 2)\n        return GCI_GreenBand;\n    if (nBand == 3)\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n",
        "name": "gtiffrgbaband.cpp",
        "path": "frmts/gtiff/gtiffrgbaband.cpp",
        "url": "/github.com/OSGeo/gdal/-/blob/frmts/gtiff/gtiffrgbaband.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 99,
          "offsetAndLengths": [
            [
              16,
              19
            ]
          ],
          "preview": "            if (TIFFReadRGBATileExt("
        }
      ],
      "repository": {
        "name": "github.com/OSGeo/gdal",
        "url": "/github.com/OSGeo/gdal"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "94700bd96ffbe6160b1d0a1e98ff91d24a997208"
        },
        "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam \u003cwarmerdam@pobox.com\u003e\n * Copyright (c) 2007-2015, Even Rouault \u003ceven dot rouault at spatialys dot com\u003e\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n#include \"gtiffrgbaband.h\"\n#include \"gtiffdataset.h\"\n\n#include \"tiffio.h\"\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand(GTiffDataset *poDSIn, int nBandIn)\n    : GTiffRasterBand(poDSIn, nBandIn)\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus(int, int, int, int, int, double *)\n{\n    return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n           GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock(int, int, void *)\n\n{\n    ReportError(CE_Failure, CPLE_AppDefined,\n                \"RGBA interpreted raster bands are read-only.\");\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock(int nBlockXOff, int nBlockYOff, void *pImage)\n\n{\n    m_poGDS-\u003eCrystalize();\n\n    const auto nBlockBufSize =\n        4 * static_cast\u003cGPtrDiff_t\u003e(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if (m_poGDS-\u003em_nPlanarConfig == PLANARCONFIG_SEPARATE)\n    {\n        for (int iBand = 0; iBand \u003c m_poGDS-\u003em_nSamplesPerPixel; iBand++)\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS-\u003em_nBlocksPerBand;\n            if (!m_poGDS-\u003eIsBlockAvailable(nBlockIdBand))\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if (!m_poGDS-\u003eIsBlockAvailable(nBlockId))\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Allocate a temporary buffer for this strip.                     */\n    /* -------------------------------------------------------------------- */\n    if (m_poGDS-\u003em_pabyBlockBuf == nullptr)\n    {\n        m_poGDS-\u003em_pabyBlockBuf = static_cast\u003cGByte *\u003e(\n            VSI_MALLOC3_VERBOSE(4, nBlockXSize, nBlockYSize));\n        if (m_poGDS-\u003em_pabyBlockBuf == nullptr)\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read the strip                                                  */\n    /* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if (m_poGDS-\u003em_nLoadedBlock != nBlockId)\n    {\n        if (TIFFIsTiled(m_poGDS-\u003em_hTIFF))\n        {\n            if (TIFFReadRGBATileExt(\n                    m_poGDS-\u003em_hTIFF, nBlockXOff * nBlockXSize,\n                    nBlockYOff * nBlockYSize,\n                    reinterpret_cast\u003cuint32_t *\u003e(m_poGDS-\u003em_pabyBlockBuf),\n                    !m_poGDS-\u003em_bIgnoreReadErrors) == 0 \u0026\u0026\n                !m_poGDS-\u003em_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBATile() failed.\");\n\n                memset(m_poGDS-\u003em_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if (TIFFReadRGBAStripExt(\n                    m_poGDS-\u003em_hTIFF, nBlockId * nBlockYSize,\n                    reinterpret_cast\u003cuint32_t *\u003e(m_poGDS-\u003em_pabyBlockBuf),\n                    !m_poGDS-\u003em_bIgnoreReadErrors) == 0 \u0026\u0026\n                !m_poGDS-\u003em_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBAStrip() failed.\");\n\n                memset(m_poGDS-\u003em_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS-\u003em_nLoadedBlock = eErr == CE_None ? nBlockId : -1;\n\n    /* -------------------------------------------------------------------- */\n    /*      Handle simple case of eight bit data, and pixel interleaving.   */\n    /* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if (nBlockYOff * nBlockYSize \u003e GetYSize() - nBlockYSize \u0026\u0026\n        !TIFFIsTiled(m_poGDS-\u003em_hTIFF))\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for (int iDestLine = 0; iDestLine \u003c nThisBlockYSize; ++iDestLine)\n    {\n        const auto nSrcOffset =\n            static_cast\u003cGPtrDiff_t\u003e(nThisBlockYSize - iDestLine - 1) *\n            nBlockXSize * 4;\n\n        GDALCopyWords(m_poGDS-\u003em_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n                      static_cast\u003cGByte *\u003e(pImage) +\n                          static_cast\u003cGPtrDiff_t\u003e(iDestLine) * nBlockXSize,\n                      GDT_Byte, 1, nBlockXSize);\n    }\n\n    if (eErr == CE_None)\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if (nBand == 1)\n        return GCI_RedBand;\n    if (nBand == 2)\n        return GCI_GreenBand;\n    if (nBand == 3)\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n",
        "name": "gtiffrgbaband.cpp",
        "path": "3rdParty/Harlinn.gdal/frmts/gtiff/gtiffrgbaband.cpp",
        "url": "/github.com/Harlinn/Harlinn.Windows/-/blob/3rdParty/Harlinn.gdal/frmts/gtiff/gtiffrgbaband.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 114,
          "offsetAndLengths": [
            [
              16,
              19
            ]
          ],
          "preview": "            if (TIFFReadRGBATileExt("
        }
      ],
      "repository": {
        "name": "github.com/Harlinn/Harlinn.Windows",
        "url": "/github.com/Harlinn/Harlinn.Windows"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 10,
  "ElapsedMilliseconds": 1466,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
