[
    "CPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                  void * pImage )\n\n{\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( nBlocksPerRow != 0 );\n    const int nBlockBufSize = 4 * nBlockXSize * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n#ifdef INTERNAL_LIBTIFF\n    if( poGDS->nCompression == COMPRESSION_OJPEG )\n    {\n        // Need to fetch all offsets for Old-JPEG compression\n        if( poGDS->pabyBlockBuf == nullptr )\n        {\n            toff_t *panByteCounts = nullptr;\n            toff_t *panOffsets = nullptr;\n            const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(poGDS->hTIFF) );\n\n            if( bIsTiled )\n            {\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets );\n            }\n            else\n            {\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets );\n            }\n        }\n    }\n#endif\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        for( int iBand = 0; iBand < poGDS->nSamplesPerPixel; iBand ++ )\n        {\n            int nBlockIdBand = nBlockId + iBand * poGDS->nBlocksPerBand;\n            if( !poGDS->IsBlockAvailable(nBlockIdBand) )\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if( !poGDS->IsBlockAvailable(nBlockId) )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( poGDS->pabyBlockBuf == nullptr )\n    {\n        poGDS->pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE( 4, nBlockXSize, nBlockYSize ) );\n        if( poGDS->pabyBlockBuf == nullptr )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if( poGDS->nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBATileExt(\n                   poGDS->hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf),\n                   !poGDS->bIgnoreReadErrors) == 0\n                && !poGDS->bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBATile(\n                   poGDS->hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf)) == 0\n                && !poGDS->bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n\n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBAStripExt(\n                   poGDS->hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf),\n                   !poGDS->bIgnoreReadErrors) == 0\n                && !poGDS->bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBAStrip(\n                   poGDS->hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf)) == 0\n                && !poGDS->bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n\n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    poGDS->nLoadedBlock = nBlockId;\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if( nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize\n        && !TIFFIsTiled( poGDS->hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for( int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine )\n    {\n        const int nSrcOffset =\n            (nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords(\n            poGDS->pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n            static_cast<GByte *>(pImage)+iDestLine*nBlockXSize, GDT_Byte, 1,\n            nBlockXSize );\n    }\n\n    if( eErr == CE_None )\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}",
    "CPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                  void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    CPLAssert( nBlocksPerRow != 0 );\n    const auto nBlockBufSize = 4 * static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        for( int iBand = 0; iBand < m_poGDS->m_nSamplesPerPixel; iBand ++ )\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS->m_nBlocksPerBand;\n            if( !m_poGDS->IsBlockAvailable(nBlockIdBand) )\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if( !m_poGDS->IsBlockAvailable(nBlockId) )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_pabyBlockBuf == nullptr )\n    {\n        m_poGDS->m_pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE( 4, nBlockXSize, nBlockYSize ) );\n        if( m_poGDS->m_pabyBlockBuf == nullptr )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if( m_poGDS->m_nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( m_poGDS->m_hTIFF ) )\n        {\n#if TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBATileExt(\n                   m_poGDS->m_hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf),\n                   !m_poGDS->m_bIgnoreReadErrors) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBATile(\n                   m_poGDS->m_hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf)) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n\n                memset( m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n#if TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBAStripExt(\n                   m_poGDS->m_hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf),\n                   !m_poGDS->m_bIgnoreReadErrors) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBAStrip(\n                   m_poGDS->m_hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf)) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n\n                memset( m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS->m_nLoadedBlock = nBlockId;\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if( nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize\n        && !TIFFIsTiled( m_poGDS->m_hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for( int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine )\n    {\n        const auto nSrcOffset =\n            static_cast<GPtrDiff_t>(nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords(\n            m_poGDS->m_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n            static_cast<GByte *>(pImage)+static_cast<GPtrDiff_t>(iDestLine)*nBlockXSize, GDT_Byte, 1,\n            nBlockXSize );\n    }\n\n    if( eErr == CE_None )\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}",
    "CPLErr GTiffRGBABand::IReadBlock(int nBlockXOff, int nBlockYOff, void *pImage)\n\n{\n    m_poGDS->Crystalize();\n\n    const auto nBlockBufSize =\n        4 * static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n    {\n        for (int iBand = 0; iBand < m_poGDS->m_nSamplesPerPixel; iBand++)\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS->m_nBlocksPerBand;\n            if (!m_poGDS->IsBlockAvailable(nBlockIdBand, nullptr, nullptr,\n                                           nullptr))\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if (!m_poGDS->IsBlockAvailable(nBlockId, nullptr, nullptr, nullptr))\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Allocate a temporary buffer for this strip.                     */\n    /* -------------------------------------------------------------------- */\n    if (m_poGDS->m_pabyBlockBuf == nullptr)\n    {\n        m_poGDS->m_pabyBlockBuf = static_cast<GByte *>(\n            VSI_MALLOC3_VERBOSE(4, nBlockXSize, nBlockYSize));\n        if (m_poGDS->m_pabyBlockBuf == nullptr)\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read the strip                                                  */\n    /* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if (m_poGDS->m_nLoadedBlock != nBlockId)\n    {\n        if (TIFFIsTiled(m_poGDS->m_hTIFF))\n        {\n            if (TIFFReadRGBATileExt(\n                    m_poGDS->m_hTIFF, nBlockXOff * nBlockXSize,\n                    nBlockYOff * nBlockYSize,\n                    reinterpret_cast<uint32_t *>(m_poGDS->m_pabyBlockBuf),\n                    !m_poGDS->m_bIgnoreReadErrors) == 0 &&\n                !m_poGDS->m_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBATile() failed.\");\n\n                memset(m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if (TIFFReadRGBAStripExt(\n                    m_poGDS->m_hTIFF, nBlockId * nBlockYSize,\n                    reinterpret_cast<uint32_t *>(m_poGDS->m_pabyBlockBuf),\n                    !m_poGDS->m_bIgnoreReadErrors) == 0 &&\n                !m_poGDS->m_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBAStrip() failed.\");\n\n                memset(m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS->m_nLoadedBlock = eErr == CE_None ? nBlockId : -1;\n\n    /* -------------------------------------------------------------------- */\n    /*      Handle simple case of eight bit data, and pixel interleaving.   */\n    /* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if (nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize &&\n        !TIFFIsTiled(m_poGDS->m_hTIFF))\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for (int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine)\n    {\n        const auto nSrcOffset =\n            static_cast<GPtrDiff_t>(nThisBlockYSize - iDestLine - 1) *\n            nBlockXSize * 4;\n\n        GDALCopyWords(m_poGDS->m_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n                      static_cast<GByte *>(pImage) +\n                          static_cast<GPtrDiff_t>(iDestLine) * nBlockXSize,\n                      GDT_Byte, 1, nBlockXSize);\n    }\n\n    if (eErr == CE_None)\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}"
]